{"0x1": "BUG代码 0x1：APC_INDEX_MISMATCH\n项目 • 2023/06/15APC_INDEX_MISMATCH Bug 检查 的值为 0x00000001。 Bug 检查指示异步过程调用(APC) 状态索引不匹配。参数说明1 系统函数 (系统调用) 或辅助角色例程的地址。2 当前线程的 ApcStateIndex 字段的值。3 当前线程的 CombinedApcDisable 字段的值。 此字段由两个单独的 16 位字段组成：(Thread>SpecialApcDisable<< 16) | 线程>KernelApcDisable。4 呼叫类型：0 - 系统调用1 - 辅助角色例程检查出现此 Bug 的最常见原因是文件系统或驱动程序的调用序列不匹配，以禁用和重新启用 APC。 键数据项是 Thread>CombinedApcDisable 字段。 CombinedApcDisable 字段由两个单独的 16 位字段组成：SpecialApcDisable 和 KernelApcDisable。 任一字段的负值表示驱动程序已分别禁用特殊或正常 APC () ，而不重新启用它们。 正值表示驱动程序启用特殊或正常 APC 的次数过多。可以使用 WinDbg 或基本故障排除技术来解决此问题。） 重要本文面向程序员。 如果你是 Microsoft 客户，并且计算机显示蓝屏错误代码，请参阅 蓝屏错误疑难解答 。APC_INDEX_MISMATCH参数原因解决方法使用 WinDbg 进行调试！analyze 调试器扩展显示有关 Bug 检查的信息，可帮助你确定根本原因。可以使用 ！apc 扩展显示一个或多个 APC 的内容。还可以在此停止代码之前的代码中设置断点，并尝试单步执行错误代码。有关使用 WinDbg 的详细信息，请参阅 使用 Windows 调试器 (WinDbg) 进行故障转储分析 。不使用 WinDbg 进行调试如果你没有能力使用 Windows 调试器来解决此问题：在 事件查看器 中，检查系统日志以获取更多错误消息，这些错误消息可以帮助你识别导致检查此 Bug 的设备或驱动程序。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以按Windows10规格 获取有关所需硬件的信息。有关更多常规故障排除信息，请参阅 蓝屏数据。注解此 Bug 检查是内核中出现内部错误的结果。 退出系统调用时会发生此错误。 造成此 Bug检查的一个可能原因是文件系统或驱动程序的系统调用序列不匹配，以进入或离开受保护的区域或关键区域。 例如，对 KeEnterCriticalRegion 的每个调用都必须具有对KeLeaveCriticalRegion 的匹配调用。如果你正在开发驱动程序，则可以使用 静态驱动程序验证程序（Windows 驱动程序工具包中提供的静态分析工具）在交付驱动程序之前检测代码中的问题。 使用CriticalRegions 规则运行静态驱动程序验证程序，验证源代码是否按正确的顺序使用这些系统调用。另请参阅Bug 检查代码参考0x1:APC_INDEX_MISMATCH\n\n问题原因：\n\n第三方软件问题，通常是第三方杀毒软件或电脑管家软件\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态\n\n", "0x2": "BUG代码 0x2：DEVICE_QUEUE_NOT_BUSY\n项目 • 2023/06/20DEVICE_QUEUE_NOT_BUSY Bug 检查 的值为 0x00000002。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。0x2:EATA_BUS_ERROR\n错误分析：系统内存存储器奇偶校验产生错误， 通常是因为有缺陷的内存（包括物理内存、二级缓存或者显卡显存）时设备驱动程序访问不存在的内存地址等原因引起的。 另外， 硬盘被病毒或者其他问题所损伤， 以出现这个停机码。\n解决方案：\n（1）检查病毒\n（2）使用“chkdsk /r”命令检查所有磁盘分区。\n（3）用Memtest86等内存测试软件检查内存。\n（4）检查硬件是否正确安装， 比如：是否牢固、金手指是否有污渍。\n", "0x3": "BUG代码 0x3：INVALID_AFFINITY_SET\n项目 • 2023/06/20INVALID_AFFINITY_SET Bug 检查 的值为 0x00000003。此 Bug 检查很少出现。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法", "0x4": "BUG代码 0x4：INVALID_DATA_ACCESS_TRAP\n项目 • 2023/06/20INVALID_DATA_ACCESS_TRAP Bug 检查 的值为 0x00000004。 它表示数据访问陷阱不正确。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x5": "BUG代码 0x5：INVALID_PROCESS_ATTACH_ATTEMPT\n项目 • 2023/06/20INVALID_PROCESS_ATTACH_ATTEMPT Bug 检查 的值为 0x00000005。 这通常表示线程在不允许的情况下附加到进程。 例如，如果线程已附加到非法) 的进程 (调用KeAttachProcess，或者从某些函数调用返回的线程处于附加状态 () 无效，则可能会出现此 Bug 检查。此 Bug 检查很少出现。参数 描述1 指向目标进程的调度程序对象的指针;如果已附加线程，则为指向原始进程的 对象的指针。2 指向当前线程当前附加到的进程调度程序对象的指针。3 线程的 APC 状态索引的值。4 非零值指示 DPC 正在当前处理器上运行。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。如果驱动程序调用 KeAttachProcess 函数，并且线程已附加到另一个进程，则可能会出现此 Bug 检查。 最好使用 KeStackAttachProcess 函数。 如果当前线程已附加到另一个进程， KeStackAttachProcess 函数会在将当前线程附加到新进程之前保存当前 APC 状态。错误地调用 KeStackAttachProcess 也可能导致此 Bug 检查，例如，如果 DPC 在当前处理器上运行。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_PROCESS_ATTACH_ATTEMPT参数备注有关此区域的一般信息，请参阅使用 Windows Kernel-Mode 进程和线程管理器 和 内核调度程序对象简介。", "0x6": "BUG代码 0x6：INVALID_PROCESS_DETACH_ATTEMPT\n项目 • 2023/06/20INVALID_PROCESS_DETACH_ATTEMPT Bug 检查的值为 0x00000006。此 Bug 检查很少出现。 此 Bug 检查可能是在驱动程序实现的PLOAD_IMAGE_NOTIFY_ROUTINE 回调函数中调用 KeStackAttachProcess 例程并随后调用 KeUnstackDetachProcess 导致的。 回调在加载映像的进程线程中运行。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x7": "BUG代码 0x7：INVALID_SOFTWARE_INTERRUPT\n项目 • 2023/06/20INVALID_SOFTWARE_INTERRUPT Bug 检查 的值为 0x00000007。此 Bug 检查很少出现。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x8": "BUG代码 0x8：IRQL_NOT_DISPATCH_LEVEL\n项目 • 2023/06/20IRQL_NOT_DISPATCH_LEVEL Bug 检查 的值为 0x00000008。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x9": "BUG代码 0x9：IRQL_NOT_GREATER_OR_EQUAL\n项目 • 2023/06/20IRQL_NOT_GREATER_OR_EQUAL Bug 检查 的值为 0x00000009。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0xA": "BUG代码 0xA：IRQL_NOT_LESS_OR_EQUAL\n项目 • 2023/06/15IRQL_NOT_LESS_OR_EQUAL Bug 检查 值为 0x0000000A。 此 Bug 检查指示 MicrosoftWindows 或内核模式驱动程序在 IRQL) 的中断请求级别 (访问无效地址的分页内存。 原因通常是指针错误或页性问题。参数说明1 无法访问的虚拟内存地址。在此地址上使用 ！pool 查看它是否为分页池。 其他可用于收集有关失败信息的命令包括 ！pte、 ！address 和 ln (List Nearest Symbols) 。2 发生故障时的 IRQL。值：2 - 发生故障时已DISPATCH_LEVEL IRQL。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。IRQL_NOT_LESS_OR_EQUAL参数参数说明3 描述导致故障的操作的位字段。 请注意，位 3 仅适用于支持此报告级别的芯片集。位 0 值：0 - 读取操作1 - 写入操作第 3 位值：0 - 不是执行操作1 - 执行操作位 0 和位 3 组合值：0x0 - 尝试从参数 1 中的地址读取时出错0x1 - 尝试写入参数 1 中的地址时出错0x8 - 尝试从参数 1 中的地址执行代码时出错此值由以下因素引起：在 DISPATCH_LEVEL 调用无法在 DISPATCH_LEVEL 调用的函数。忘记释放旋转锁。在代码必须不可分页时将代码标记为可分页。 例如，如果代码获取一个旋转锁，或在延迟的过程调用中调用。4 故障时的指令指针。在此地址上使用 ln (List Nearest Symbols) 命令查看函数的名称。此 Bug 检查是由使用不正确地址的内核模式设备驱动程序引起的。此 Bug 检查指示在 IRQL) 的中断请求 (级别提升时尝试访问无效地址。 原因是内存指针错误或设备驱动程序代码的页性问题。可用于对导致 Bug 检查的编码错误类型进行分类的一般准则如下：如果参数 1 小于 0x1000，则问题可能是 NULL 指针取消引用。如果 ！pool 报告参数 1 是分页池 (或其他类型的可分页内存) ，则 IRQL 过高，无法访问此数据。 在较低的 IRQL 下运行，或在非分页池中分配数据。如果参数 3 指示 Bug 检查是尝试执行可分页代码，则 IRQL 过高，无法调用此函数。 在较低的 IRQL 下运行，或者不要将代码标记为可分页。原因这可能是由释放后使用或位翻转引起的错误指针。 使用 ！pte、 ！address 和 ln (列表最接近的符号) 调查参数 1 的有效性。解决方法如果内核调试器可用，请获取堆栈跟踪。 首先运行 ！analyze 调试器扩展，以显示有关Bug 检查的信息。 ！analyze 扩展有助于确定根本原因。 接下来，输入其中一个 k* (显示堆栈回溯) 命令以查看调用堆栈。收集信息检查驱动程序的名称（如果已在蓝屏上列出）。检查系统登录事件查看器中是否有其他错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。 在与蓝屏相同的时间范围内查找系统日志中发生的严重错误。驱动程序验证程序驱动程序验证程序是一个实时运行的工具，用于检查驱动程序的行为。 例如，驱动程序验证程序检查内存资源（如内存池）的使用。 如果在执行驱动程序代码时标识错误，它会主动创建一个异常，以允许进一步检查该部分驱动程序代码。 驱动程序验证程序管理器内置于 Windows 中，可在所有 Windows 电脑上使用。若要启动驱动程序验证程序管理器，请在命令提示符下键入 验证程序 。 你可以配置要验证的驱动程序。 验证驱动程序的代码在运行时会增加开销，因此请尝试验证尽可能少的驱动程序。 有关详细信息，请参阅驱动程序验证程序。以下代码演示了一个调试示例：dbgcmdkd> .Bugcheck [Lists Bug check data.]Bugcheck code 0000000aArguments 00000000 0000001c 00000000 00000000kd> kb [Lists the stack trace.]ChildEBP RetAddr Args to Child8013ed5c 801263ba 00000000 00000000 e12ab000 NT!_DbgBreakPoint8013eecc 801389ee 0000000a 00000000 0000001c NT!_KeBugCheckEx+0x1948013eecc 00000000 0000000a 00000000 0000001c NT!_KiTrap0E+0x2568013ed5c 801263ba 00000000 00000000 e12ab0008013ef64 00000246 fe551aa1 ff690268 00000002 NT!_KeBugCheckEx+0x194kd> kv [Lists the trap frames.]ChildEBP RetAddr Args to Child生成此 Bug 检查的错误通常在安装有故障的设备驱动程序、系统服务或 BIOS 之后发生。如果在升级到较新版本的 Windows 时遇到0xA:IRQL_NOT_LESS_OR_EQUAL\n\n问题原因：\n\n通常是第三方软件兼容或系统故障\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0xA:IRQL_NOT_LESS_OR_EQUAL\n错误分析：主要是由问题的驱动程序、有缺陷或不兼容的硬件与软件造成的。 从技术角度讲。 表明在内核模式中存在以太高的进程内部请求级别（IRQL）访问其没有权限访问的内存地址。\n解决方案：请用前面介绍的解决方案中的", "0xB": "BUG代码 0xB：NO_EXCEPTION_HANDLING_SUPPORT\n项目 • 2023/06/20NO_EXCEPTION_HANDLING_SUPPORT Bug 检查的值为 0x0000000B。此 Bug 检查很少出现。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。另请参阅Bug 检查代码参考", "0xC": "BUG代码 0xC：MAXIMUM_WAIT_OBJECTS_EXCEEDED\n项目 • 2023/06/20MAXIMUM_WAIT_OBJECTS_EXCEEDED Bug 检查 的值为 0x0000000C。 这表示当前线程超出了允许的等待对象数。无此 Bug 检查由 KeWaitForMultipleObjects 或 FsRtlCancellableWaitForMultipleObjects不当使用所导致。调用方可能会在此例程的 WaitBlockArray 参数中传递指向缓冲区的指针。 系统将使用此缓冲区来跟踪等待对象。如果提供了缓冲区， 则 Count 参数不能超过 MAXIMUM_WAIT_OBJECTS。 如果未提供缓冲区， Count 参数不能超过THREAD_WAIT_OBJECTS。如果 Count 的值超过允许的值，则会发出此 Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MAXIMUM_WAIT_OBJECTS_EXCEEDED参数原因", "0xD": "BUG代码 0xD：MUTEX_LEVEL_NUMBER_VIOLATION\n项目 • 2023/06/20MUTEX_LEVEL_NUMBER_VIOLATION Bug 检查的值为 0x0000000D。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0xE": "BUG代码 0xE：NO_USER_MODE_CONTEXT\n项目 • 2023/06/20NO_USER_MODE_CONTEXT Bug 检查 的值为 0x0000000E。在启动系统线程的过程中，如果控制从初始线程过程返回，则会发生 Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0xF": "BUG代码 0xF：SPIN_LOCK_ALREADY_OWNED\n项目 • 2023/06/20SPIN_LOCK_ALREADY_OWNED Bug 检查 的值为 0x0000000F。 这表示当旋转锁已拥有时，已启动对旋转锁的请求。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SPIN_LOCK_ALREADY_OWNED参数无原因通常，此错误是由对旋转锁的递归请求引起的。 如果已启动类似于对旋转锁的递归请求（例如，当某个线程已获取旋转锁，然后同一线程调用函数时，该函数也会尝试获取旋转锁）时，也可能发生此情况。 在这种情况下，不会阻止第二次尝试获取旋转锁，因为这样做会导致不可恢复的死锁。 如果在多个处理器上调用，则会阻止一个处理器，直到另一个处理器释放锁。当为所有线程和所有旋转锁分配 IRQL 时，如果没有显式递归，也可能发生此错误。 旋转锁 IRQL 始终大于或等于 DPC 级别，但对于线程来说并非如此。 但是，持有旋转锁的线程必须维护大于或等于旋转锁的 IRQL。 将线程 IRQL 降低到它所持有的旋转锁的 IRQL 级别以下，可以在处理器上计划另一个线程。 然后，此新线程可能会尝试获取相同的旋转锁。解决方法确保不会以递归方式获取锁。 并且，对于持有旋转锁的线程，请确保不要将线程 IRQL 降低到低于其所持有的旋转锁的 IRQL 级别。", "0x10": "BUG代码 0x10：SPIN_LOCK_NOT_OWNED\n项目 • 2023/06/20SPIN_LOCK_NOT_OWNED Bug 检查 的值为 0x00000010。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x11": "BUG代码 0x11：THREAD_NOT_MUTEX_OWNER\n项目 • 2023/06/20THREAD_NOT_MUTEX_OWNER Bug 检查 的值为 0x00000011。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x12": "BUG代码 0x12：TRAP_CAUSE_UNKNOWN\n项目 • 2023/06/20TRAP_CAUSE_UNKNOWN Bug 检查 的值为 0x00000012。 这表示发生了未知异常。参数 描述1 TRAP_CAUSE_UNKNOWN类型VALUES1 - 意外中断。 (参数 2 - 中断向量)2 - 未知浮点异常。3 - 启用和断言状态位 (查看处理器定义) 。2 依赖于 Arg13 保留4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。若要开始，请使用 k、kb、kc、kd、kp、kP、kv (Display Stack Backtrace) 命令检查堆栈跟踪 。 可以指定处理器编号来检查所有处理器上的堆栈。还可以在导致此停止代码的代码中设置断点，并尝试单步执行错误代码。！idt 扩展可用于显示指定中断调度表 (IDT) (ISR) 中断服务例程。调试中断风暴中所述的一些技术可用于意外中断。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TRAP_CAUSE_UNKNOWN参数解决方法有关使用故障转储的一般信息，请参阅 使用 Windows 调试器 (WinDbg) 进行故障转储分析 。如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。检查事件查看器中的系统日志，了解可能有助于识别导致此 Bug 检查的设备或驱动程序的其他错误消息。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以在Windows10规范 中获取有关所需硬件的信息。有关其他常规故障排除信息，请参阅 蓝屏数据。0x12:TRAP_CAUSE_UNKNOWN\n错误分析：如果遇到这个错误信息， 那么很不幸， 应为KeBudCheck分析的结果是错误原因未知。\n解决方案：既然微软都帮不上忙， 就得靠自己了， 请仔细回想这个错误是什么时候出现的; 第一次发生时你对系统做了哪些操作; 发生时正在进行什么操作。 从这些信息中找出可能的原因， 从而选择相应解决方案尝试排除。\n", "0x13": "BUG代码 0x13：EMPTY_THREAD_REAPER_LIST\n项目 • 2023/06/20EMPTY_THREAD_REAPER_LIST Bug 检查 的值为 0x00000013。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x14": "BUG代码 0x14：CREATE_DELETE_LOCK_NOT_LOCKED\n项目 • 2023/06/20CREATE_DELETE_LOCK_NOT_LOCKED Bug 检查 的值为 0x00000014。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x15": "BUG代码 0x15：LAST_CHANCE_CALLED_FROM_KMODE\n项目 • 2023/06/20LAST_CHANCE_CALLED_FROM_KMODE Bug 检查 的值为 0x00000015。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x16": "BUG代码 0x16：CID_HANDLE_CREATION\n项目 • 2023/06/20CID_HANDLE_CREATION Bug 检查的值为 0x00000016。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x17": "BUG代码 0x17：CID_HANDLE_DELETION\n项目 • 2023/06/20CID_HANDLE_DELETION Bug 检查 的值为 0x00000017。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x18": "BUG代码 0x18：REFERENCE_BY_POINTER\n项目 • 2023/06/20REFERENCE_BY_POINTER Bug 检查 的值为 0x00000018。 这表示对象的引用计数对于对象的当前状态是非法的。参数 描述1 要降低其引用计数的对象的对象类型。2 正在降低引用计数的对象。3 保留4 保留对象的引用计数对于对象的当前状态是非法的。 每次驱动程序使用指向 对象的指针时，驱动程序都会调用内核例程，使对象的引用计数增加 1。 当驱动程序使用 指针完成时，驱动程序会调用另一个内核例程，以将引用计数减少 1。驱动程序必须匹配对例程的调用，这些例程增加 (引用) ，减少 (引用) 引用计数。 此 Bug检查是由对象的引用计数不一致引起的。 通常，不一致是由驱动程序导致的，该驱动程序将对象的引用计数减少太多，并发出额外的调用来取消引用对象。 此 Bug 检查可能发生，因为对象的引用计数为零，而对象仍有打开的句柄。 如果对象的引用计数低于零，无论对象是否有打开的句柄，也可能发生此情况。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。REFERENCE_BY_POINTER参数原因解决方法确保驱动程序匹配对增加和减少对象的引用计数的例程的调用。 确保驱动程序不会对取消引用对象的例程进行额外调用， (请参阅参数 2) 。可以使用调试器来帮助分析此问题。 有关详细信息，请参阅使用 Windows 调试程序(WinDbg) 进行故障转储分析。 !analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。若要查找对象上的句柄和指针计数，请使用 ！object 调试器命令。kd> ！object address其中 address 是参数 2 中给定对象的地址。还可以在导致此停止代码的代码中设置断点，并尝试单步执行错误代码。如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。检查事件查看器中的系统日志，了解可能有助于识别导致此 Bug 检查的设备或驱动程序的其他错误消息。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以在Windows10规范 中获取有关所需硬件的信息。有关其他常规故障排除信息，请参阅 蓝屏数据。0x18:REFERENCE_BY_POINTER\n\n问题原因：\n\nWindows系统缺陷\n\n解决方案：\n\n此蓝屏概率很低，一般重启即可恢复。\n\n如频繁出现蓝屏，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n", "0x19": "BUG代码 0x19：BAD_POOL_HEADER\n项目 • 2023/06/20BAD_POOL_HEADER Bug 检查 的值为 0x00000019。 这表示池标头已损坏。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x2 正在检查的池条目池块的大小 0 特殊池模式检查失败。(所有者可能已损坏池块。)0x3 正在检查的池条目read-back flinkfreelist 值读回 闪烁 自由列表值池自由列表已损坏。(在正常列表中，参数 2、3 和 4 的值应相同。)0x5 池条目之一 保留 另一个池条目 一对相邻的池条目具有相互矛盾的标头。 其中至少有一个已损坏。0x6 一个错误计算的条目保留 导致错误计算的错误条目池块标头以前的大小太大。0x7 0 保留 错误的池条目 池块标头大小已损坏。0x8 0 保留 错误的池条目 池块标头大小为零。0x9 一个错误计算的条目保留 导致错误计算的错误条目池块标头大小已损坏， () 太大。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BAD_POOL_HEADER参数参数 1 参数 2 参数 3 参数 4 错误消息的原因0xA 应找到的池条目 保留 应包含池条目的页面的虚拟地址池块标头大小已损坏。0xD、0xE、0xF、0x23、0x24、0x25预留 预留 预留 释放块的池标头在释放后已修改。 这通常不是释放块的先前所有者的过错;相反，它通常 (但不总是) ，因为释放块之前的块被溢出。0x20 应找到的池条目 下一个池条目 保留 池块标头大小已损坏。0X21 正在释放的池指针为池块分配的字节数池块后找到的损坏值正在释放的池块之后的数据已损坏。 通常，这意味着使用者 (调用堆栈) 已溢出块。0X22 正在释放的地址 预留 预留 正在释放的地址没有跟踪条目。这通常是因为调用堆栈正在尝试释放已释放或从未分配的指针。在当前请求时，池已损坏。这不一定是由于调用方造成的。必须使用内核调试器来访问内部池链接，以找出问题可能的原因。然后，可以对可疑池标记使用特殊池，或在可疑驱动程序上使用驱动程序验证程序“特殊池”选项。 ！analyze 扩展可能有助于查明可疑驱动程序，但池损坏通常不是这种情况。使用 蓝屏数据 中所述的步骤收集停止代码参数。 使用停止代码参数确定要跟踪的代码行为的特定类型。原因解决方法驱动程序验证程序驱动程序验证程序是一个实时运行的工具，用于检查驱动程序的行为。 如果在执行驱动程序代码时发现错误，它会主动创建一个异常，以允许进一步审查驱动程序代码的这一部分。 驱动程序验证程序管理器内置于 Windows 中，可在所有 Windows PC 上使用。 若要启动驱动程序验证程序管理器，请在命令提示下键入“验证程序” 。 你可以配置要验证的驱动程序。 验证驱动程序的代码在运行时会增加开销，因此请尝试验证尽可能少的驱动程序。 有关详细信息，请参阅驱动程序验证程序。Windows 内存诊断如果此 Bug 检查出现不一致，则可能与物理内存故障有关。运行 Windows 内存诊断工具以测试内存。 在控制面板搜索框中，键入“内存”，然后选择“ 诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 查找“内存诊断结果”条目以查看结果 。0x19:BAD_POOL_HEADER\n\n问题原因：\n\nWindows系统故障\n\n硬件故障（通常是RAM）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n如不能恢复，请连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如不能执行恢复出厂设置或恢复出厂设置后故障依旧，建议携机去联想售后服务中心检测硬件。\n\n", "0x1A": "BUG代码 0x1A：MEMORY_MANAGEMENT\n项目 • 2023/04/07MEMORY_MANAGEMENT Bug 检查的值为 0x0000001A。 Bug 检查指示发生了严重的内存管理错误。参数 1 标识完全冲突。参数 1 错误原因0x31 映像重新定位修复表或代码流已损坏。 此错误可能是硬件错误。0x3f 页内操作失败，出现循环冗余检查 (CRC) 错误。 参数 2 包含页面文件偏移量。 参数3 包含页 CRC 值。 参数 4 包含预期的 CRC 值。0x403 ) PPN (页表和页帧编号不同步。此错误可能是硬件错误，尤其是在参数 3 和 4 仅相差一位的情况下。0x404 在删除系统页的过程中，发现 PFN 与当前页表条目 (PTE) 指针之间不一致。 参数 2是预期的 PTE。 参数 3 是 PTE 内容。 参数 4 是 PFN 的 PTE。0x411 PTE 已损坏。 参数 2 是 PTE 的地址。0x1010 调用方正在解锁当前未锁定的可分页分区。 (此分区从未锁定或已解锁两次。)0x1233 驱动程序尝试映射未锁定的物理内存页。 此操作是非法的，因为页面的内容或属性可以随时更改。 代码中的 Bug 发出了映射调用。 参数 2 是驱动程序尝试映射的物理页的 PFN。0x1234 调用方正在尝试锁定不存在的可分页分区。0x1235 调用方尝试用无效映射保护 MDL。0x1236 调用方指定了包含未锁定（或无效）物理页的 MDL。 参数 2 包含指向 MDL 的指针。 参数 3 包含指向无效 PFN 的指针。 参数 4 包含无效的 PFN 值。） 重要本文面向程序员。 如果你是 Microsoft 客户，并且计算机显示蓝屏错误代码，请参阅 蓝屏错误疑难解答 。MEMORY_MANAGEMENT参数参数 1 错误原因0x1240 调用方为非驻留的虚拟地址范围生成 MDL 是非法的。 参数 2 是 MDL。 参数 3 是PTE 指针。0x3300 在写入操作期间，引用的虚拟地址被错误地标记为“写入时复制”。 参数 2 是 的值FaultingAddress。 参数 3 是 PTE 内容。 参数 4表 示虚拟地址空间类型。0x3451 已调出的内核线程堆栈的 PTE 已损坏。0x3453 由于未完成的引用，无法删除退出进程的所有页表页。 此错误通常表示进程页表结构已损坏。0x3470 缓存的内核堆栈在空闲列表中时已损坏。 此内存损坏表示存在严重问题，调用堆栈可能是受害者或罪魁祸首。 参数 2 是虚拟地址。 参数 3 是虚拟地址 Cookie。0x4477 驱动程序尝试写入系统进程的用户空间中未分配的地址。 参数 2 包含尝试写入的地址。0x5100 分配位图已损坏。 内存管理器即将覆盖已在使用的虚拟地址。0x5305 调用方正在指定要释放的无效池地址（参数 2）。 参数 2 是正在评估的虚拟地址。参数 3 是区域大小。0x6001 内存存储组件的专用内存范围已损坏，因此无法访问。 参数 2 是返回的状态。 参数3 是存储专用内存范围内的虚拟地址。 参数 4 是 MDL。0x88860x8887（Windows 7 及更高版本）。 备用列表中的两个本应具有相同页面优先级值的页没有相同的页优先级值。 参数 4 中捕获了不同的值。0x88880x8889内部内存管理结构已损坏。0x888A 内部内存管理结构（可能是 PTE 或 PFN）已损坏。0x9696 PFN (参数 2) 遇到损坏的链接，该链接不再连接到其顶级进程。 此错误指示 PFN 结构已损坏。0x15000 调用方要么提供错误的地址，要么在错误的进程上下文中调用此例程。 这两项操作都是非法的，因为我们无法保护由于此错误而找不到的范围。 参数 2 是正在评估的虚拟地址。0x15001 在取消保护以前保护的内存的过程中出错。 如果调用方在错误的进程上下文中错误地调用 MmUnsecureVirtualMemory ，则可能会发生此错误。0x41202 在确定非零 PTE 的页面保护过程中，已确定 PTE 已损坏。 参数 2 是 PTE 指针。 参数 3 是 PTE 内容。 参数 4 是虚拟地址描述符。0x41286 调用方试图释放无效的池地址。0x41785 工作集列表已损坏。参数 1 错误原因0x41287 保持工作集同步时出现非法页错误。 参数 2 包含引用的虚拟地址。0x41790 页表页已损坏。 在 64 位版本的 Windows 上，参数 2 包含损坏页表页的 PFN 地址。 在 32 位版本的 Windows 上，参数 2 包含指向已用 PTE 数量的指针，参数 3包含已用 PTE 的数量。0x41792 检测到损坏的 PTE。 参数 2 包含 PTE 的地址。 参数 3 和 4 包含 PTE 的低部分和高部分。0x61941 分页层次结构已损坏。 参数 2 是指向导致错误的虚拟地址的指针。0x61948 在递减 I/O 空间区域的引用计数的过程中，找不到该区域的记帐节点。 通常，此错误意味着参数范围从未锁定或已被解锁。 参数 2 是基本 I/O 帧。 参数 3 是区域中的页数。 参数 4 是找不到节点的特定 I/O 帧。0x61949 值为 IoPageFrameNode null。 参数 2 为 PageFrameIndex。0x6194A 正在取消映射的 I/O 空间物理页上的引用计数递减时出错。 当前未引用的条目正在取消引用。 参数 2 和 3 描述调用方未映射的 I/O 空间范围。 参数 4 是应引用但未引用的 I/O 空间物理页。0x03030308 加载程序正在使用要删除 (或截断) 的范围。 无法安全地删除它，因此系统必须发出停止代码。 参数 2 为 HighestPhysicalPage。这些参数 1 值在早期版本的 Windows 中使用。参数 1 错误原因0x777 调用方正在解锁当前未锁定的系统缓存地址。 (该地址要么从未映射过，要么被解锁两次。)0x778 系统使用的是最后一个系统缓存视图地址，而不是保留它。0x7800x781映射参数系统缓存视图的 PTE 已损坏。0x1000 的调用方 MmGetSystemAddressForMdl* 尝试将完全缓存的物理页映射为未缓存。 此操作将导致硬件转换缓冲区条目发生冲突，因此操作系统拒绝此操作。 由于调用方在请求的内存描述符列表 (MDL) 中指定了“故障时检查 Bug”，因此系统检查发出Bug。0x1241 在调用生成 MDL 时，MDL 的虚拟地址意外异步取消映射。 参数 2 是 MDL。 参数 3是 PTE 指针。0x5003 工作集可用列表已损坏。 这可能是硬件错误。参数 1 错误原因0x5200 可用池列表上的页已损坏。 此错误可能是驱动程序中的免写 Bug 或上一页的溢出导致的。 参数 2 包含可用池块的地址。 参数 4 包含预期位于该地址的值。 参数 3 包含找到的实际值。0x88840x8885（Windows 7 及更高版本）。 备用列表中应具有相同页面优先级值的两页没有相同的页优先级值。 参数 4 中捕获了不同的值。0x41201 在查询虚拟地址的过程中，发现 PFN 与当前 PTE 指针之间不一致。 参数 2 是对应的 PTE。 参数 3 是 PTE 内容。 参数 4 是虚拟地址描述符。0x41283 PTE 中编码的工作集索引已损坏。0x41284 PTE 或工作集列表已损坏。0x41793 页表页已损坏。 参数 2 包含指向上次处理的 PTE 的指针。 参数 3 包含找到的非零PTE 数。 参数 4 包含页表中预期数量的非零 PTE。此内存参数已弃用，Windows 10版本 1803 后不再可用。0x61940 PDE 意外失效。0x61946 正在创建的 MDL 存在缺陷。 此错误几乎始终意味着调用 MmProbeAndLockPages 的驱动程序出错。 通常，当要求驱动程序处理分页读取时，驱动程序会尝试创建写入MDL。0x03030303 启动加载器已损坏。 （此值仅适用于 Intel Itanium 计算机。）！analyze 调试扩展显示有关 Bug 检查的信息。 调试扩展中的信息可能有助于确定根本原因。你还可能会发现运行 Windows 内存诊断工具来检查影响物理内存模块的问题。Bug 检查代码参考解决方法另请参阅0x1A:MEMORY_MANAGEMENT\n\n问题原因：\n\nWindows系统和第三方应用兼容性问题\n\n第三方软件冲突\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0x1A:MEMORY_MANAGEMENT\n错误分析：这个内存管理错误往往是由硬件引起的， 比如： 新安装的硬件、内存本身有问题等。\n解决方案：如果是在安装Windows时出现， 有可能是由于你的电脑达不到安装Windows的最小内存和磁盘要求。\n", "0x1B": "BUG代码 0x1B：PFN_SHARE_COUNT\n项目 • 2023/06/20PFN_SHARE_COUNT Bug 检查 的值为 0x0000001B。此 Bug 检查代码不再由 Windows 操作系统使用。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。另请参阅Bug 检查代码参考", "0x1C": "BUG代码 0x1C：PFN_REFERENCE_COUNT\n项目 • 2023/06/20PFN_REFERENCE_COUNT Bug 检查 的值为 0x0000001C。 这表示检测到引用计数错误。它可能是由计数器溢出、下溢或释放后使用的对象引起的。 检查堆栈以确定故障。 注意：此 Bug 检查代码用于报告多种类型的引用计数错误，不一定与内存管理器页帧编号(PPN) 相关。参数 描述1 未使用2 未使用3 未使用4 未使用!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PARAMETERS解决方法", "0x1D": "BUG代码 0x1D：NO_SPIN_LOCK_AVAILABLE\n项目 • 2023/06/20NO_SPIN_LOCK_AVAILABLE Bug 检查 的值为 0x0000001D。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x1E": "BUG代码 0x1E：dbgcmdkd> .Bugcheck get the Bug check dataBugcheck code 0000001eArguments c0000005 8013cd0a 00000000 0362cffffkd> kb start with a stack trace FramePtr RetAddr Param1 Param2 Param3 Function Name 8013ed5c 801263ba 00000000 00000000 fe40cb00 NT!_DbgBreakPoint 8013eecc 8013313c 0000001e c0000005 8013cd0a NT!_KeBugCheckEx+0x194fe40cad0 8013318e fe40caf8 801359ff fe40cb00NT!PspUnhandledExceptionInSystemThread+0x18fe40cad8 801359ff fe40cb00 00000000 fe40cb00NT!PspSystemThreadStartup+0x4afe40cf7c 8013cb8e fe43a44c ff6ce388 00000000 NT!_except_handler3+0x4700000000 00000000 00000000 00000000 00000000 NT!KiThreadStartup+0xekd> dd fe40caf8 L2 dump EXCEPTION_POINTERS structure0xFE40CAF8 fe40cd88 fe40cbc4 ..@...@.kd> .exr fe40cd88 first DWORD is the exception recordException Record @ FE40CD88: ExceptionCode: c0000005 ExceptionFlags: 00000000 Chained Record: 00000000ExceptionAddress: 8013cd0aNumberParameters: 00000002 Parameter[0]: 00000000 Parameter[1]: 0362cfffkd> .cxr fe40cbc4 second DWORD is the context recordCtxFlags: 00010017eax=00087000 ebx=00000000 ecx=03ff0000 edx=ff63d000 esi=0362cfffedi=036b3fffeip=8013cd0a esp=fe40ce50 ebp=fe40cef8 iopl=0 nv dn ei pl nz ac pocyvip=0 vif=0cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=000106170x8013cd0a f3a4 rep movsbkd> kb kb gives stack for context recordChildEBP RetAddr Args to Childfe40ce54 80402e09 ff6c4000 ff63d000 03ff0000 NT!_RtlMoveMemory@12+0x3efe40ce68 80403c18 ffbc0c28 ff6ce008 ff6c4000 HAL!_HalpCopyBufferMap@20+0x49fe40ce9c fe43b1e4 ff6cef90 ffbc0c28 ff6ce009HAL!_IoFlushAdapterBuffers@24+0x148fe40ceb8 fe4385b4 ff6ce388 6cd00800 ffbc0c28QIC117!_kdi_FlushDMABuffers@20+0x28fe40cef8 fe439894 ff6cd008 ffb6c820 fe40cf4cQIC117!_cqd_CmdReadWrite@8+0x26efe40cf18 fe437d92 ff6cd008 ffb6c820 ff6e4e50 QIC117!_cqd_DispatchFRB@8+0x210fe40cf30 fe43a4f5 ff6cd008 ffb6c820 00000000 QIC117!_cqd_ProcessFRB@8+0x134fe40cf4c 80133184 ff6ce388 00000000 00000000 QIC117!_kdi_ThreadRun@4+0xa9fe40cf7c 8013cb8e fe43a44c ff6ce388 00000000NT!_PspSystemThreadStartup@8+0x400x1E:MKMODE_EXCEPTION_NOT_HANDLED\n\n问题原因：\n\nWindows系统和第三方应用兼容性问题\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0x1E:KMODE_EXCEPTION_NOT_HANDLED\n错误分析：Windows内核检查到一个非法或者未知的进程指令， 这个停机码一般是由问题的内存或是与前面0xA相似的原因造成的。\n解决方案：\n（1）硬件兼容有问题：请对照前面提到的最新硬件兼容性列表， 查看所有硬件是否包含在该列表中。\n（2）有问题的设备驱动、系统服务或内存冲突和中断冲突： 如果在蓝屏信息中出现了驱动程序的名字，请试着在安装模式或者故障恢复控制台中禁用或删除驱动程序， 并禁用所有刚安装的驱动和软件。 如果错误出现在系统启动过程中， 请进入安全模式， 将蓝屏信息中所标明的文件重命名或者删除。\n（3）如果错误信息中明确指出Win32K.sys： 很有可能是第三方远程控制软件造成的， 需要从故障恢复控制台中将对该软件的服务关闭。\n（4）在安装Windows后第一次重启时出现：最大嫌疑可能时系统分区的磁盘空间不足或BIOS兼容有问题。\n（5）如果是在关闭某个软件时出现的：很有可能时软件本省存在设计缺陷， 请升级或卸载它。\n", "0x1F": "BUG代码 0x1F：SHARED_RESOURCE_CONV_ERROR\n项目 • 2023/06/20SHARED_RESOURCE_CONV_ERROR Bug 检查 的值为 0x0000001F。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x20": "BUG代码 0x20：KERNEL_APC_PENDING_DURING_EXIT\n项目 • 2023/06/20KERNEL_APC_PENDING_DURING_EXIT Bug 检查的值为 0x00000020。 这表示在线程退出时，APC) (异步过程调用仍处于挂起状态。参数 描述1 在退出期间发现挂起的 APC 的地址2 线程的 APC 禁用计数3 当前 IRQL4 保留关键数据项是线程的 APC 禁用计数 (参数 2) 。 如果计数不为零，它将指示问题的根源。每次驱动程序调用 KeEnterCriticalRegion、 FsRtlEnterFileSystem 或获取互斥时，APC禁用计数都会递减。每次驱动程序调用 KeLeaveCriticalRegion、 KeReleaseMutex 或 FsRtlExitFileSystem时，APC 禁用计数都会递增。由于这些调用应始终成对，因此当线程退出时，APC 禁用计数应为零。 负值表示驱动程序已禁用 APC 调用，但未重新启用它们。 正值指示反之则为 true。如果看到此错误，请非常怀疑计算机上安装的所有驱动程序，尤其是异常或非标准驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_APC_PENDING_DURING_EXIT参数原因当前 IRQL (参数 3) 应为零。 否则，驱动程序的取消例程可能已在提升的 IRQL 处返回，导致此 Bug 检查。 在这种情况下，请仔细记下 (运行的内容和崩溃时关闭) 的内容，并记下崩溃时安装的所有驱动程序。 在这种情况下，原因通常是驱动程序中的严重 Bug。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x21": "BUG代码 0x21：QUOTA_UNDERFLOW\n项目 • 2023/06/20QUOTA_UNDERFLOW Bug 检查 的值为 0x00000021。 这表示向特定块返回的配额比以前收取的配额多，从而处理了配额费用。参数 描述1 最初收费的进程（如果可用）。2 配额类型。 有关所有可能的配额类型值的列表，请参阅 Windows 驱动程序工具包 (WDK) 中的头文件 Ps.h。3 要返回的初始收费配额量。4 未返回的剩余配额量。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。QUOTA_UNDERFLOW参数", "0x22": "BUG代码 0x22：FILE_SYSTEM\n项目 • 2023/06/20FILE_SYSTEM Bug 检查 的值为 0x00000022。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x23": "BUG代码 0x23：FAT_FILE_SYSTEM\n项目 • 2023/06/20FAT_FILE_SYSTEM Bug 检查 的值为 0x00000023。 这表示 FAT 文件系统中出现了问题。参数 描述1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 如果 FatExceptionFilter 位于堆栈上，则此参数指定异常记录的地址。3 如果 FatExceptionFilter 位于堆栈上，则此参数指定上下文记录的地址。4 保留此 Bug 检查的一个可能原因是磁盘损坏。 文件系统损坏或磁盘上) 扇区 (坏块可能会导致此错误。 损坏的 SCSI 和 IDE 驱动程序也会对系统读取和写入磁盘的能力产生不利影响，从而导致错误。另一个可能的原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引编制过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要调试此问题，请执行以下操作： 将 .cxr (显示上下文记录) 命令与参数 3 配合使用，然后使用 kb (显示堆栈回溯) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FAT_FILE_SYSTEM参数原因解决方法若要解决磁盘损坏问题，请执行以下操作：检查事件查看器是否有来自 SCSI 和 FASTFAT(系统日志) 或 Autochk (应用程序日志) 的错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。 尝试禁用任何持续监视系统的病毒扫描程序、备份程序或磁盘碎片整理程序工具。 还应运行系统制造商提供的硬件诊断。 有关这些过程的详细信息，请参阅计算机的用户手册。 运行 Chkdsk /f /r 以检测并解决任何文件系统结构损坏。 在系统分区上开始磁盘扫描之前，必须重启系统。若要解决非分页池内存耗尽问题，请执行以下操作： 将新的物理内存添加到计算机。 这将增加内核可用的非分页池内存数量。0x23:FAT_FILE_SYSTEM\n0x24:NTFS_FILE_SYSTEM\n错误分析：0x23通常发生在读写FAT16或者FAT32文件系统的系统分区时， 而0x24则是由于NTFS.sys文件出现错误（这个驱动文件的作用是容许系统读写使用NTFS文件系统的磁盘）。 这两个蓝屏 错误很有可能是磁盘本身存在物理损坏， 或是中断要求封包（IRP）损坏而导致的。 其他原因还包括：硬盘磁盘碎片过多; 文件读写操作过于频繁， 并且数据量非常达或者是由于一些磁盘镜像软件或杀毒软件引起的\n解决方案：\n第一步：首先打开命令行提示符， 运行“Chkdsk /r”（注：不是CHKDISK， 感觉象这个， 但是……）命令检查并修复硬盘错误， 如果报告存在怀道（Bad Track）， 请使用硬盘厂商提供的检查工具进行检查和修复。\n第二步：接着禁用所有即使扫描文件的软件， 比如：杀毒软件、防火墙或备份工具。\n第三步：右击C:winntsystem32driversfastfat.sys文件并选择“属性”， 查看其版本是否与当前系统所使用的Windows版本相符。（注：如果是XP， 应该是C:windowssystem32driversfastfat.sys）\n第四步：安装最新的主板驱动程序， 特别IDE驱动。 如果你的光驱、可移动存储器也提供有驱动程序，最好将它们升级至最新版。\n", "0x24": "BUG代码 0x24：NTFS_FILE_SYSTEM\n项目 • 2023/06/20NTFS_FILE_SYSTEM Bug 检查 的值为 0x00000024。 这表示ntfs.sys（允许系统读取和写入 NTFS 驱动器的驱动程序文件）中出现问题。参数 描述1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 如果堆栈上存在 NtfsExceptionFilter ，则此参数指定异常记录的地址。3 如果 NtfsExceptionFilter 位于堆栈上，则此参数指定上下文记录的地址。4 保留此 Bug 检查的一个可能原因是磁盘损坏。 NTFS 文件系统中的损坏或硬盘上) 扇区 (坏块可能会引发此错误。 损坏的硬盘驱动器 (SATA/IDE) 驱动程序也会对系统读取和写入磁盘的能力产生不利影响，从而导致错误。若要调试此问题，请执行以下操作： 将 .cxr (显示上下文记录) 命令与参数 3 配合使用，然后使用 kb (显示堆栈回溯) 。若要解决磁盘损坏问题，请执行以下操作：） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NTFS_FILE_SYSTEM参数原因解决方法检查事件查看器中是否存在与系统日志中显示的硬盘驱动器相关的错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。尝试禁用任何持续监视系统的病毒扫描程序、备份程序或磁盘碎片整理程序工具。还应运行与存储子系统相关的系统制造商提供的硬件诊断。使用扫描磁盘实用工具确认没有文件系统错误。 选择并按住 (或右键单击要扫描的驱动器上的“) ”，然后选择“ 属性”。 选择“ 工具”。 选择“ 立即检查 ”按钮。确认硬盘驱动器上有足够的可用空间。 操作系统和某些应用程序需要足够的可用空间来创建交换文件以及用于其他函数。 根据系统配置，确切要求会有所不同，但通常最好有 10% 到 15% 的可用空间。使用系统文件检查器工具修复丢失或损坏的系统文件。 系统文件检查器是 Windows中的一个实用工具，允许用户扫描 Windows 系统文件中的损坏并还原损坏的文件。使用以下命令运行系统文件检查器工具 (SFC.exe) 。控制台SFC /scannow有关详细信息，请参阅 使用系统文件检查器工具修复丢失或损坏的系统文件 。驱动程序验证程序驱动程序验证程序是一个实时运行的工具，用于检查驱动程序的行为。 如果在执行驱动程序代码时发现错误，它会主动创建一个异常，以允许进一步审查驱动程序代码的这一部分。 驱动程序验证程序管理器内置于 Windows 中，可在所有 WindowsPC 上使用。 若要启动驱动程序验证程序管理器，请在命令提示下键入“验证程序”。 你可以配置要验证的驱动程序。 验证驱动程序的代码在运行时会增加开销，因此请尝试验证尽可能少的驱动程序。 有关详细信息，请参阅驱动程序验证程序。在过去，此停止代码的另一个可能原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引编制过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。", "0x25": "BUG代码 0x25：NPFS_FILE_SYSTEM\n项目 • 2023/06/20NPFS_FILE_SYSTEM Bug 检查 的值为 0x00000025。 这表示 NPFS 文件系统中出现了问题。参数 描述1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 保留3 保留4 保留此 Bug 检查的一个可能原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引编制过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要解决非分页池内存耗尽问题，请执行以下操作： 将新的物理内存添加到计算机。 这将增加内核可用的非分页池内存数量。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NPFS_FILE_SYSTEM参数原因解决方法", "0x26": "BUG代码 0x26：CDFS_FILE_SYSTEM\n项目 • 2023/06/20CDFS_FILE_SYSTEM Bug 检查 的值为 0x00000026。 这表示 CD 文件系统中出现了问题。参数 描述1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 如果 CdExceptionFilter 位于堆栈上，则此参数指定异常记录的地址。3 如果 CdExceptionFilter 位于堆栈上，则此参数指定上下文记录的地址。4 保留此 Bug 检查的一个可能原因是磁盘损坏。 文件系统损坏或磁盘上) 扇区 (坏块可能会导致此错误。 损坏的 SCSI 和 IDE 驱动程序也会对系统读取和写入磁盘的能力产生不利影响，从而导致错误。另一个可能的原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引编制过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要调试此问题，请执行以下操作： 将 .cxr (显示上下文记录) 命令与参数 3 配合使用，然后使用 kb (显示堆栈回溯) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CDFS_FILE_SYSTEM参数原因解决方法若要解决磁盘损坏问题，请执行以下操作：检查事件查看器是否有来自 SCSI 和 FASTFAT(系统日志) 或 Autochk (应用程序日志) 的错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。 尝试禁用任何持续监视系统的病毒扫描程序、备份程序或磁盘碎片整理程序工具。 还应运行系统制造商提供的硬件诊断。 有关这些过程的详细信息，请参阅计算机的用户手册。 运行 Chkdsk /f /r 以检测并解决任何文件系统结构损坏。 在系统分区上开始磁盘扫描之前，必须重启系统。若要解决非分页池内存耗尽问题，请执行以下操作： 将新的物理内存添加到计算机。 这将增加内核可用的非分页池内存数量。", "0x27": "BUG代码 0x27：RDR_FILE_SYSTEM\n项目 • 2023/06/20RDR_FILE_SYSTEM Bug 检查 的值为 0x00000027。 这表示 SMB 重定向程序文件系统中出现了问题。参数 描述1 高 16 位 (“0x”之后的前四个十六进制数字) 标识问题类型。 可能的值包括：0xCA550000 RDBSS_Bug_CHECK_CACHESUP0xC1EE0000 RDBSS_Bug_CHECK_CLEANUP0xC10E0000 RDBSS_Bug_CHECK_CLOSE0xBAAD0000 RDBSS_Bug_CHECK_NTEXCEPT2 如果 RxExceptionFilter 位于堆栈上，则此参数指定异常记录的地址。3 如果 RxExceptionFilter 位于堆栈上，则此参数指定上下文记录的地址。4 保留此 Bug 检查的一个可能原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引过程中，如果可用的非分页池内存量非常低，另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。RDR_FILE_SYSTEM参数原因解决方法若要调试此问题，请执行以下操作： 将 .cxr (显示上下文记录) 命令与参数 3 配合使用，然后使用 kb (显示堆栈回溯) 。若要解决非分页池内存耗尽问题，请执行以下操作： 向计算机添加新的物理内存。 这将增加内核可用的非分页池内存的数量。0x27:RDR_FILE_SYSTEM\n错误分析：这个错误产生的原因很难判断， 不过Windows内存管理出了问题很可能会导致这个停机码的出现。\n解决方案：如果是内存管理的缘故， 通常增加内存会解决问题。\n", "0x28": "BUG代码 0x28：CORRUPT_ACCESS_TOKEN\n项目 • 2023/06/20CORRUPT_ACCESS_TOKEN Bug 检查 值为 0x00000028。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x29": "BUG代码 0x29：SECURITY_SYSTEM\n项目 • 2023/06/20SECURITY_SYSTEM Bug 检查 的值为 0x00000029。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x2A": "BUG代码 0x2A：INCONSISTENT_IRP\n项目 • 2023/06/20INCONSISTENT_IRP Bug 检查 的值为 0x0000002A。 这表示发现 IRP 包含不一致的信息。参数 描述1 发现不一致的 IRP 的地址2 保留3 保留4 保留发现 IRP 处于不一致状态。 通常，这意味着 IRP 的某些字段与 IRP 的剩余状态不一致。例如，已完成但仍标记为已排队到驱动程序的设备队列的 IRP。此 Bug 检查代码当前未在系统中使用，但存在用于调试目的。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INCONSISTENT_IRP参数原因备注", "0x2B": "BUG代码 0x2B：PANIC_STACK_SWITCH\n项目 • 2023/06/20PANIC_STACK_SWITCH Bug 检查 的值为 0x0000002B。 这表示内核模式堆栈已溢出。参数 描述1 陷阱框架2 保留3 保留4 保留当内核模式驱动程序使用过多的堆栈空间时，通常会出现此错误。 当内核中发生严重数据损坏时，也可能出现此错误。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PANIC_STACK_SWITCH参数原因解决方法", "0x2C": "BUG代码 0x2C：PORT_DRIVER_INTERNAL\n项目 • 2023/06/20PORT_DRIVER_INTERNAL Bug 检查 的值为 0x0000002C。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x2D": "BUG代码 0x2D：SCSI_DISK_DRIVER_INTERNAL\n项目 • 2023/06/20SCSI_DISK_DRIVER_INTERNAL Bug 检查 的值为 0x0000002D。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x2E": "BUG代码 0x2E：DATA_BUS_ERROR\n项目 • 2023/06/20DATA_BUS_ERROR Bug 检查 的值为 0x0000002E。 这通常表示检测到系统内存中的奇偶校验错误。参数 描述1 导致故障的虚拟地址2 导致故障的物理地址3 PSR) (处理器状态寄存器4 错误指令寄存器 (FIR)此错误几乎总是由硬件问题（配置问题、有缺陷的硬件或不兼容的硬件）引起的。可能导致此错误的最常见硬件问题是 RAM 有缺陷、级别 2 (L2) RAM 缓存错误或视频RAM 错误。 硬盘损坏也可能导致此错误。当设备驱动程序尝试访问0x8xxxxxxx 范围中不存在 (没有物理地址映射) 的地址时，也可能导致此 Bug 检查。解决硬件问题： 如果硬件最近已添加到系统，请将其删除以查看错误是否再次发生。如果现有硬件出现故障，请卸下或更换故障部件。 应运行系统制造商提供的硬件诊断，以确定哪个硬件组件出现故障。 有关这些过程的详细信息，请参阅计算机的用户手册。检查计算机中的所有适配器卡是否已正确就位。 使用电子电源商店提供的墨迹橡皮擦或电触点处理，以确保适配器卡触点清洁。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DATA_BUS_ERROR参数原因解决方法如果新安装的系统上出现此问题，检查 BIOS、SCSI 控制器或网卡的更新可用性。 此类汇报通常可在硬件制造商的网站或公告板系统 (BBS) 上获得。如果在安装新的或更新的设备驱动程序后发生错误，则应删除或替换该驱动程序。 在这种情况下，如果启动期间发生错误，并且系统分区使用 NTFS 进行格式化，则可以使用安全模式重命名或删除有故障的驱动程序。如果在安全模式下将驱动程序用作系统启动过程的一部分，则需要使用恢复控制台启动计算机才能访问该文件。有关可能有助于查明导致错误的设备或驱动程序的其他错误消息，检查事件查看器中的系统日志。 在 BIOS 中禁用内存缓存或隐藏也可能解决此错误。 此外，检查系统上的病毒，使用任何最新的商业病毒扫描软件来检查硬盘的主启动记录。 所有 Windows 文件系统都可能受到病毒的感染。解决硬盘损坏问题： 在系统分区上运行 Chkdsk /f /r 。 必须在磁盘扫描开始之前重启系统。 如果由于错误而无法启动系统，请使用恢复控制台并运行 Chkdsk /r。警告 如果系统分区使用文件分配表 (FAT) 文件系统格式化，则如果使用 Scandisk 或其他基于 Microsoft MS-DOS 的硬盘工具从 MS-DOS 验证硬盘的完整性，则 Windows 使用的长文件名可能会损坏。 始终使用与 Windows 版本匹配的 Chkdsk 版本。", "0x2F": "BUG代码 0x2F：INSTRUCTION_BUS_ERROR\n项目 • 2023/06/20INSTRUCTION_BUS_ERROR Bug 检查 的值为 0x0000002F。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x30": "BUG代码 0x30：SET_OF_INVALID_CONTEXT\n项目 • 2023/06/20SET_OF_INVALID_CONTEXT Bug 检查 的值为 0x00000030。 这表示陷阱帧中的堆栈指针具有无效值。参数 描述1 新堆栈指针2 旧堆栈指针3 陷阱帧地址4 0当某些例程尝试将陷阱帧中的堆栈指针设置为低于当前堆栈指针值时，会发生此 Bug 检查。如果未捕获此错误，则会导致内核使用指向不再有效的堆栈的堆栈指针运行。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SET_OF_INVALID_CONTEXT参数原因", "0x31": "BUG代码 0x31：PHASE0_INITIALIZATION_FAILED\n项目 • 2023/06/20PHASE0_INITIALIZATION_FAILED Bug 检查 的值为 0x00000031。 这表示系统初始化失败。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PHASE0_INITIALIZATION_FAILED参数无原因系统初始化在很早的阶段失败。解决方法分析此数据需要调试器。", "0x32": "BUG代码 0x32：PHASE1_INITIALIZATION_FAILED\n项目 • 2023/06/20PHASE1_INITIALIZATION_FAILED Bug 检查 的值为 0x00000032。 这表示系统初始化失败。参数 描述1 描述系统初始化失败原因的 NT 状态代码2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PHASE1_INITIALIZATION_FAILED参数", "0x33": "BUG代码 0x33：UNEXPECTED_INITIALIZATION_CALL\n项目 • 2023/06/20UNEXPECTED_INITIALIZATION_CALL Bug 检查 的值为 0x00000033。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x34": "BUG代码 0x34：CACHE_MANAGER\n项目 • 2023/06/20CACHE_MANAGER Bug 检查 的值为 0x00000034。 这表示文件系统的缓存管理器中出现了问题。参数 说明1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 保留3 保留4 保留此 Bug 检查的一个可能原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引编制过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要解决非分页池内存耗尽问题，请执行以下操作： 将新的物理内存添加到计算机。 这将增加内核可用的非分页池内存数量。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CACHE_MANAGER参数原因解决方法", "0x35": "BUG代码 0x35：NO_MORE_IRP_STACK_LOCATIONS\n项目 • 2023/06/20NO_MORE_IRP_STACK_LOCATIONS Bug 检查 的值为 0x00000035。 当 IoCallDriver 数据包没有剩余的堆栈位置时，检查会发生此 Bug。参数 描述1 IRP 的地址2 保留3 保留4 保留较高级别的驱动程序尝试通过 IoCallDriver 接口调用较低级别的驱动程序，但数据包中没有其他堆栈位置。 这将阻止较低级别的驱动程序访问其参数。这是一个灾难性的情况，因为更高级别的驱动程序正在运行，就好像它已根据需要填充较低级别驱动程序 (的参数) 。 但是，由于后一个驱动程序没有堆栈位置，因此前者实际上已经注销了数据包的末尾。 这意味着其他一些内存也已损坏。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NO_MORE_IRP_STACK_LOCATIONS参数原因0x35:NO_MORE_IRP_STACK_LOCATIONS\n错误分析：从字面上理解， 应该时驱动程序或某些软件出现堆栈问题。 其实这个故障的真正原因应该时驱动程序本省存在问题， 或是内存有质量问题。\n解决方案：请使用前面介绍的常规解决方案中与驱动程序和内存相关的方案进行排除。\n", "0x36": "BUG代码 0x36：DEVICE_REFERENCE_COUNT_NOT_ZERO\n项目 • 2023/06/20DEVICE_REFERENCE_COUNT_NOT_ZERO Bug 检查 的值为 0x00000036。 这表示驱动程序尝试删除仍具有正引用计数的设备对象。参数 描述1 设备对象的地址2 保留3 保留4 保留设备驱动程序已尝试从系统中删除其设备对象之一，但该对象的引用计数为非零。这意味着仍有对设备的未完成引用。 (引用计数指示无法删除此设备对象的原因数。)这是调用设备驱动程序中的 Bug。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DEVICE_REFERENCE_COUNT_NOT_ZERO参数原因", "0x37": "BUG代码 0x37：FLOPPY_INTERNAL_ERROR\n项目 • 2023/06/20FLOPPY_INTERNAL_ERROR Bug 检查 的值为 0x00000037。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x38": "BUG代码 0x38：SERIAL_DRIVER_INTERNAL\n项目 • 2023/06/20SERIAL_DRIVER_INTERNAL Bug 检查 的值为 0x00000038。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x39": "BUG代码 0x39：SYSTEM_EXIT_OWNED_MUTEX\n项目 • 2023/06/20SYSTEM_EXIT_OWNED_MUTEX Bug 检查 的值为 0x00000039。 这表示工作器例程返回时未释放其拥有的互斥对象。参数 描述1 导致错误的辅助角色例程的地址。2 传递给辅助角色例程的参数。3 工作项的地址。4 保留。工作器例程返回，而它仍然拥有 mutex 对象。 当前工作线程将继续运行其他不相关的工作项，互斥体永远不会释放。分析此问题需要调试器。 若要查找导致错误的驱动程序，请使用 ln (List NearestSymbols) deBugger 命令：kd> ln 地址其中 address 是参数 1 中给出的工作器例程。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SYSTEM_EXIT_OWNED_MUTEX参数原因解决方法", "0x3A": "BUG代码 0x3A：SYSTEM_UNWIND_PREVIOUS_USER\n项目 • 2023/06/20检查SYSTEM_UNWIND_PREVIOUS_USER Bug 的值为 0x0000003A。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x3B": "BUG代码 0x3B：SYSTEM_SERVICE_EXCEPTION\n项目 • 2023/05/19SYSTEM_SERVICE_EXCEPTION Bug 检查具有 0x0000003B 值。 这表示在执行从非特权代码转换为特权代码的例程时发生了异常。参数 说明1 导致 Bug 检查的异常。2 导致 Bug 检查的指令的地址3 导致 Bug 检查的异常的上下文记录的地址4 0 (未使用)此停止代码指示正在执行的代码有异常，而其下方的线程是系统线程。发生这种情况的原因可能是取消引用 NULL 指针或访问了随机不正确的地址。 这反过来又可能是由于内存过早释放或数据结构损坏造成的。NTSTATUS 值中介绍了在参数 1 中返回的异常信息。 异常代码在 ntstatus.h（Windows驱动程序工具包提供的标头文件）中定义。 （有关详细信息，请参阅 Windows 驱动程序工具包中的标头文件）。常见的异常代码包括：0x80000003：STATUS_BREAKPOINT没有内核调试器连接到系统时，遇到断点或 ASSERT。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。SYSTEM_SERVICE_EXCEPTION参数原因0xC0000005：STATUS_ACCESS_VIOLATION出现内存访问冲突。若要确定特定原因并创建代码修复，需要具有编程经验和对故障模块源代码的访问权限。若要调试此问题，请使用参数 3 的 .cxr（显示上下文记录） 命令，然后使用 kb（显示堆栈回溯跟踪） 。 还可以在此停止代码之前的代码中设置断点，并尝试单步前进到故障代码中。 使用 u、ubuu (unassemble) 命令查看程序集程序代码 。!analyze 调试程序扩展显示有关 Bug 检查的信息，有助于确定根本原因。 下面的示例是!analyze 的输出。dbgcmd有关 WinDbg 和 !analyze 的详细信息，请参阅下列主题：使用 !analyze 扩展使用 WinDbg 分析内核模式转储文件有关 Windows 内存使用情况的详细信息，请参阅由 Pavel Yosifovich、Mark E.Russinovich、David A. Solomon 和 Alex Ionescu 撰写的 Windows Internals 7th Edition第 1 部分 。如果可以识别出导致错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中KiBugCheckDriver (PUNICODE_STRING) 位置。 可以使用一个调试器命令 dx（显示调试器对象模型表达式）来显示此内容：dx KiBugCheckDriver。dbgcmd解决方法SYSTEM_SERVICE_EXCEPTION (3b)An exception happened while executing a system service routine.Arguments:Arg1: 00000000c0000005, Exception code that caused the BugcheckArg2: fffff802328375b0, Address of the instruction which caused the BugcheckArg3: ffff9c0a746c2330, Address of the context record for the exception thatcaused the BugcheckArg4: 0000000000000000, zero....标识驱动程序kd> dx KiBugCheckDriverKiBugCheckDriver : 0xffffe10b9991e3e8 : \"nvlddmkm.sys\"[Type: _UNICODE_STRING *]使用 !error 扩展显示参数 1 中的异常代码的相关信息。 以下是 !error 的输出实例。dbgcmd2: kd> !error 00000000c0000005Error code: (NTSTATUS) 0xc0000005 (3221225477) - The instruction at 0x%preferenced memory at 0x%p. The memory could not be %s.请查看 WinDbg 的“堆栈文本”输出以获取故障发生时运行的内容的线索。 如果有多个转储文件可用，请比较信息以查找堆栈中的通用代码。 使用调试器命令，如使用 kb（显示堆栈回溯）来调查错误代码。使用以下命令列出在内存中加载的模块：lm t n使用 !memusage 检查系统内存的一般状态。 还可以使用命令 !pte 和 !pool 来检查内存的特定区域 。过去，此错误已链接到过度使用分页池，如果用户模式图形驱动程序交叉将错误数据传递到内核代码，则可能导致出现这种情况。 如果你怀疑就是这种情况，请使用驱动程序验证器中的池选项收集其他信息。驱动程序验证程序驱动程序验证程序是一个实时运行的工具，用于检查驱动程序的行为。 例如，驱动程序验证程序检查内存资源（如内存池）的使用。 如果在执行驱动程序代码时标识错误，它会主动创建一个异常，以允许进一步检查该部分驱动程序代码。 驱动程序验证程序管理器内置于 Windows 中，可在所有 Windows 电脑上使用。若要启动驱动程序验证程序管理器，请在命令提示下输入“验证程序”。 你可以配置要验证的驱动程序。 验证驱动程序的代码在运行时会增加开销，因此请尝试验证尽可能少的驱动程序。 有关详细信息，请参阅驱动程序验证程序。备注有关 Windows Bug 检查代码的一般故障排除，请按照以下建议操作：如果最近添加了新的设备驱动程序或系统服务，请尝试删除或更新它们。 尝试确定系统中导致新 Bug 检查代码出现的原因。查看设备管理器，了解是否有任何设备标记为惊叹号 (!)，这表示存在问题。 查看任何故障设备驱动程序的属性中显示的事件日志。 尝试更新相关驱动程序。检查事件查看器中的系统日志，以获取可能有助于查明导致错误的设备或驱动程序的其他错误消息。 在系统日志中查找与蓝屏同时出现的严重错误。如果最近向系统添加了硬件，请尝试删除或替换它。 或与制造商联系，查看是否有可用的修补程序。有关其他常规疑难解答信息，请参阅蓝屏数据。另请参阅使用 Windows 调试器 (WinDbg) 进行故障转储分析使用 WinDbg 分析内核模式转储文件Bug 检查代码参考0x3B:SYSTEM_SERVICE_EXCEPTION\n\n问题原因：\n\nWindows系统和第三方应用兼容性问题\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x3C": "BUG代码 0x3C：INTERRUPT_UNWIND_ATTEMPTED\n项目 • 2023/06/20INTERRUPT_UNWIND_ATTEMPTED Bug 检查 的值为 0x0000003C。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x3D": "BUG代码 0x3D：INTERRUPT_EXCEPTION_NOT_HANDLED\n项目 • 2023/06/20INTERRUPT_EXCEPTION_NOT_HANDLED Bug 检查的值为 0x0000003D。 这表示内核中断对象中断管理的异常处理程序无法处理生成的异常。参数 描述1 ) 可用时异常记录 (2 上下文记录 (（当) 可用时）3 04 0!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INTERRUPT_EXCEPTION_NOT_HANDLED 参数解决方法0x3D:INTERRUPT_EXCEPTION_NOT_HANDLED\n\n问题原因：\n\nWindows系统和第三方应用兼容性问题\n\n硬件故障\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x3E": "BUG代码 0x3E：MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED\n项目 • 2023/06/20MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED Bug 检查的值为 0x0000003E。 这表示系统有多个处理器，但它们彼此之间是非对称的。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED参数无原因若要对称，所有处理器的类型和级别必须相同。 此系统包含不同类型的处理器 (例如，一个Pentium处理器和一个 80486 处理器) 。", "0x3F": "BUG代码 0x3F：NO_MORE_SYSTEM_PTES\n项目 • 2023/06/20NO_MORE_SYSTEM_PTES Bug 检查 的值为 0x0000003F。 这是系统执行过多 I/O 操作的结果。 这导致 PTE) (系统页表条目碎片化。参数 描述1 0： 系统扩展 PTE 类型1： 非分页池扩展 PTE 类型2 内存请求的大小3 可用系统 PTE 总数4 系统 PTE 总数在几乎所有情况下，系统实际上并不脱离 PTE。 相反，驱动程序请求了一个大型内存块，但没有足够大小的连续块来满足此请求。通常，视频驱动程序会分配大量必须成功的内核内存。 某些备份程序也这样做。可能的解决方法： 修改注册表以增加系统 PTE 的总数。 如果这不起作用，请删除最近安装的任何软件，尤其是备份实用工具或磁盘密集型应用程序。调试问题：以下方法可用于调试0x3F:NO_MORE_SYSTEM_PTES\n错误分析：一个与系统内存管理相关的错误， 比如：由于执行了大量的输入/输出操作， 造成内存管理出现问题： 有缺陷的驱动程序不正确地使用内存资源; 某个应用程序（比如：备份软件）被分配了大量的内核内存等。\n解决方案：卸载所有最新安装的软件（特别是哪些增强磁盘性能的应用程序和杀毒软件）和驱动程序。\n", "0x40": "BUG代码 0x40：TARGET_MDL_TOO_SMALL\n项目 • 2023/06/20TARGET_MDL_TOO_SMALL Bug 检查 的值为 0x00000040。 这表示驱动程序未正确使用IoBuildPartialMdl。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TARGET_MDL_TOO_SMALL参数无原因这是驱动程序 Bug。 驱动程序已调用 IoBuildPartialMdl 函数，并向其传递 MDL 以映射源 MDL 的一部分，但目标 MDL 不够大，无法映射请求的整个地址范围。解决方法源和目标 MDL 以及要映射的地址范围长度是 IoBuildPartialMdl 函数的第一个、第二个和第四个参数。 因此，在此特定函数上执行堆栈跟踪在调试过程中可能会有所帮助。 确保代码正确计算要传递给此函数的地址范围长度的目标 MDL 所需的大小。", "0x41": "BUG代码 0x41：MUST_SUCCEED_POOL_EMPTY\n项目 • 2023/06/20MUST_SUCCEED_POOL_EMPTY Bug 检查 的值为 0x00000041。 这表示内核模式线程请求了过多的必须成功池。参数 描述1 无法满足的请求的大小2 从非分页池使用的页数3 来自非分页池的请求数大于 PAGE_SIZE4 可用页数不允许驱动程序请求必须成功池。如果无法填充必须成功的请求，则会发出此 Bug 检查。替换或重写发出请求的驱动程序。 驱动程序不应请求必须成功池。 相反，它应请求正常池，并正常处理池暂时为空的情况。kb (显示堆栈回溯) 命令将显示导致错误的驱动程序。此外，第二个组件可能耗尽了必须成功的池。 若要确定是否是这种情况，请先使用 kb 命令。 然后使用 ！vm 1 显示池总使用情况， 使用 ！poolused 2 显示按标记的非分页池使） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MUST_SUCCEED_POOL_EMPTY参数原因解决方法用情况， 使用 ！poolused 4 显示按标记分页的池使用情况。 与使用最多池的标记关联的组件可能是问题的根源。", "0x42": "BUG代码 0x42：ATDISK_DRIVER_INTERNAL\n项目 • 2023/06/20ATDISK_DRIVER_INTERNAL Bug 检查 的值为 0x00000042。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x43": "BUG代码 0x43：NO_SUCH_PARTITION\n项目 • 2023/06/20NO_SUCH_PARTITION Bug 检查 的值为 0x00000043。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x44": "BUG代码 0x44：MULTIPLE_IRP_COMPLETE_REQUESTS\n项目 • 2023/06/20MULTIPLE_IRP_COMPLETE_REQUESTS Bug 检查 的值为 0x00000044。 这表示驱动程序已尝试请求完成已完成的 IRP。参数 描述1 IRP 的地址2 保留3 保留4 保留驱动程序已调用 IoCompleteRequest ，要求完成 IRP，但数据包已完成。这是一个很难找到的 Bug，因为最简单的情况（尝试完成自己的数据包两次的驱动程序）通常不是问题的根源。 更有可能的是，两个单独的驱动程序各自相信自己拥有数据包，并且每个驱动程序都尝试完成数据包。 第一个请求成功，第二个请求失败，导致此Bug 检查。跟踪系统中导致错误的驱动程序很困难，因为第二个驱动程序已覆盖第一个驱动程序的痕迹。 但是，可以通过检查每个堆栈位置中的设备对象字段来查找当前请求的驱动程序堆栈。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MULTIPLE_IRP_COMPLETE_REQUESTS参数原因解决方法0x44:MULTIPLE_IRP_COMPLETE_REQUESTS\n\n问题原因：\n\nWinodws系统故障或第三方软件故障\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n0x44:MULTIPLE_IRP_COMPLIETE_REQUESTS\n错误分析：通常是由硬件驱动程序引起的。\n解决方案：卸载最近安装的驱动程序。 这个故障很少出现， 目前已经知道的是， 在使用http://www.in-system.com/这家公司的某些软件时会出现， 其中的罪魁就是Falstaff.sys文件。\n", "0x45": "BUG代码 0x45：INSUFFICIENT_SYSTEM_MAP_REGS\n项目 • 2023/06/20INSUFFICIENT_SYSTEM_MAP_REGS Bug 检查 的值为 0x00000045。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x46": "BUG代码 0x46：DEREF_UNKNOWN_LOGON_SESSION\n项目 • 2023/06/20DEREF_UNKNOWN_LOGON_SESSION Bug 检查 的值为 0x00000046。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x47": "BUG代码 0x47：REF_UNKNOWN_LOGON_SESSION\n项目 • 2023/06/20REF_UNKNOWN_LOGON_SESSION Bug 检查 的值为 0x00000047。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x48": "BUG代码 0x48：CANCEL_STATE_IN_COMPLETED_IRP\n项目 • 2023/06/20CANCEL_STATE_IN_COMPLETED_IRP Bug 检查 值为 0x00000048。 这表示 I/O 请求数据包 (IRP) 已完成，随后已取消。参数 描述1 指向 IRP 的指针2 驱动程序设置的取消例程3 保留4 保留具有 Cancel 例程集的 IRP 已正常完成，无需取消。 但完成后，一个司机称为 IRP 的 取消例程。这可能是由驱动程序完成 IRP 并尝试取消 IRP 引起的。也可能是由两个驱动程序各自尝试以不当方式访问同一 IRP 导致的。cancel 例程参数可用于确定哪个驱动程序或堆栈导致 Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CANCEL_STATE_IN_COMPLETED_IRP参数原因解决方法", "0x49": "BUG代码 0x49：PAGE_FAULT_WITH_INTERRUPTS_OFF\n项目 • 2023/06/20PAGE_FAULT_WITH_INTERRUPTS_OFF Bug 检查 的值为 0x00000049。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x4A": "BUG代码 0x4A：IRQL_GT_ZERO_AT_SYSTEM_SERVICE\n项目 • 2023/06/20IRQL_GT_ZERO_AT_SYSTEM_SERVICE Bug 检查 的值为 0x0000004A。 这表示当线程的IRQL 仍然高于PASSIVE_LEVEL时，正在从系统调用返回到用户模式。参数 描述1 系统函数 (系统调用例程的地址)2 当前 IRQL3 04 0!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。IRQL_GT_ZERO_AT_SYSTEM_SERVICE参数解决方法", "0x4B": "BUG代码 0x4B：STREAMS_INTERNAL_ERROR\n项目 • 2023/06/20STREAMS_INTERNAL_ERROR Bug 检查 的值为 0x0000004B。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x4C": "BUG代码 0x4C：FATAL_UNHANDLED_HARD_ERROR\n项目 • 2023/06/20FATAL_UNHANDLED_HARD_ERROR Bug 检查 的值为 0x0000004C。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x4D": "BUG代码 0x4D：NO_PAGES_AVAILABLE\n项目 • 2023/06/20NO_PAGES_AVAILABLE Bug 检查 的值为 0x0000004D。 这表示没有可用于继续操作的免费页面。参数 描述1 脏页总数2 发往页面文件的脏页数3 出现 Bug 检查时可用的非分页池的大小4 最近修改的写入错误状态。若要查看常规内存统计信息，请使用 ！vm 3 扩展。此 Bug 检查可能由于以下任一原因而发生：驱动程序已阻止、死锁修改或映射的页编写器。 例如，文件系统驱动程序或筛选器驱动程序中的互斥死锁或对分页内存的访问。 这表示驱动程序 Bug。如果参数 1 或参数 2 较大，则有可能这样做。 使用 ！vm 3。存储驱动程序未处理请求。 例如，搁浅的队列和无响应的驱动器。 这表示驱动程序Bug。如果参数 1 或参数 2 较大，则有可能这样做。 使用 ！vm 8，后跟 ！process 0 7。高优先级实时线程使平衡集管理器从工作集中剪裁页面，或者使修改后的页面编写器不能写出它们。这表示创建此线程的组件中存在 Bug。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NO_PAGES_AVAILABLE参数原因这种情况很难分析。 尝试使用 ！ready。 另请尝试 ！process 0 7 列出所有线程，并查看是否有线程累积了过多的内核时间，以及其当前优先级。 此类进程可能已阻止内存管理线程使页面可用。没有足够的池可供存储堆栈写出修改的页面。 这表示驱动程序 Bug。如果参数 3 较小，则有可能这样做。 使用 ！vm 和 ！poolused 2。如果找不到问题，请尝试使用从头开始附加的内核调试器启动，并监视情况。", "0x4E": "BUG代码 0x4E：PFN_LIST_CORRUPT\n项目 • 2023/06/20PFN_LIST_CORRUPT Bug 检查 的值为 0x0000004E。 这表示 PFN) 列表 (页帧编号已损坏。参数 1 指示冲突的类型。 其他参数的含义取决于 参数 1 的值。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x01 已损坏的ListHead 值可用页数 0 列表头已损坏。0x02 列表中要删除的条目最高物理页码 要移除的条目的引用计数列表条目已损坏。0x06 页框架编号 原型 PTE PTE 内容 硬件 PTE 和/或原型 PTE 数据结构已损坏。 原因可能是硬件单位错误、DMA 传输中断等。0x07 页框架编号 当前共享计数 0 驱动程序解锁某个页面的次数多于锁定页面的次数。0x8D 状态不一致的页码0 0 无页列表已损坏。 此错误代码很可能表示存在硬件问题。0x8F 新页码 旧页码 0 自由页列表头或归零页列表头已损坏。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PFN_LIST_CORRUPT参数参数 1 参数 2 参数 3 参数 4 错误消息的原因0x99 页框编号 当前页状态 0 PTE) 或 PFN (页表条目已损坏。0x9A 页框编号 当前页状态 要移除的条目的引用计数驱动程序尝试释放仍因 IO 而锁定的页面。此错误通常是由驱动程序传递错误的内存描述符列表引起的。 例如，驱动程序可能使用同一列表调用 了 MmUnlockPages 两次。如果内核调试器可用，请检查堆栈跟踪：！analyze 调试扩展显示有关 Bug 的信息检查并有助于确定根本原因，然后输入 k (显示堆栈回溯) 命令之一以查看调用堆栈。!analyzeBug 检查代码参考原因另请参阅", "0x4F": "BUG代码 0x4F：NDIS_INTERNAL_ERROR\n项目 • 2023/06/20NDIS_INTERNAL_ERROR Bug 检查 的值为 0x0000004F。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x50": "BUG代码 0x50：PAGE_FAULT_IN_NONPAGED_AREA\n项目 • 2023/06/15PAGE_FAULT_IN_NONPAGED_AREA Bug 检查的值为 0x00000050。 这表明引用了无效的系统内存。 通常，内存地址错误或内存地址指向已释放的内存。参数 说明1 引用的内存地址） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。PAGE_FAULT_IN_NONPAGED_AREA参数参数 说明2 Windows 1507 (TH1) 版本 - x64 后0:读取操作2:写入操作10:执行操作Windows 1507 (TH1) 版本 - x86 后0:读取操作2:写入操作10:执行操作Windows 1507 (TH1) 版本之后 - Arm0:读取操作1:写入操作8:执行操作Windows 1507 (TH1) 版本 x64 / x86 前0:读取操作1:写入操作3 引用内存的地址（如果已知）参数 说明4 页面错误类型0x0 - NONPAGED_BugCHECK_FREED_PTE - 引用的地址位于标记为空闲的页表条目上。0x2 - NONPAGED_BugCHECK_NOT_PRESENT_PAGE_TABLE引用的地址没有有效的活动页表条目。0x03-NONPAGED_BugCHECK_WRONG_SESSION - 尝试在没有会话的进程的上下文中引用会话空间地址。 通常，这意味着调用方在未首先正确获取对正确进程的对象引用并附加到该进程的情况下，不正确地尝试访问会话地址。 此Bug 检查和子类型最后用于 Windows 10 RS3 中。 在Windows 10 RS4 及更高版本中，此错误改为 0x02(NONPAGED_BugCHECK_NOT_PRESENT_PAGE_TABLE)。NONPAGED_BugCHECK_VA_NOT_CANONICAL 0x04 - 尝试引用非规范（非法）虚拟地址（参数 1）。 调用方不会尝试访问此地址。0xF -NONPAGED_BugCHECK_USER_VA_ACCESS_INCONSISTENT- 当不允许此类访问时，内核模式代码尝试访问用户模式虚拟地址。如果可以识别负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中kiBugCheckDriver (PUNICODE_STRING) 位置。 可以使用以下调试程序 dx 命令来显示它- dx KiBugCheckDriver。安装了错误的系统服务或错误的驱动程序代码都可能造成0x50:PAGE_FAULT_IN_NONPAGED_AREA\n\n问题原因：\n\nWinodws系统故障或第三方软件故障\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0x50:PAGE_FAULT_IN_NONPAGED+AREA\n错误分析：有问题的内存（包括屋里内存、二级缓存、显存）、不兼容的软件（主要是远程控制和杀毒软件）、损坏的NTFS卷以及有问题的硬件（比如：PCI插卡本身已损坏）等都会引发这个错误。\n解决方案：请使用前面介绍的常规解决方案中与内存、软件、硬件、硬盘等相关的方案进行排除。\n", "0x51": "BUG代码 0x51：REGISTRY_ERROR\n项目 • 2023/06/20REGISTRY_ERROR Bug 检查 值为 0x00000051。 这表示发生了严重的注册表错误。参数 描述1 保留2 保留3 指向配置单元 (的指针（如果可用）)4 如果配置单元已损坏， HvCheckHive 的返回代码 (（如果可用)注册表出现问题。 如果内核调试器可用，请获取堆栈跟踪：！analyze 调试扩展显示有关Bug 检查的信息，在确定根本原因方面非常有用，然后输入 k (显示堆栈回溯) 命令之一以查看调用堆栈。此错误可能表示注册表在尝试读取其中一个文件时遇到 I/O 错误。 这可能是由硬件问题或文件系统损坏引起的。也可能是由于刷新操作失败（仅由安全系统在 中使用），然后仅在遇到资源限制时才会发生此情况。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。REGISTRY_ERROR参数原因0x51:REGISTRY_ERROR\n\n问题原因：\n\nWinodws系统故障\n\n解决方案：\n\n请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0x51:REGISTRY_ERROR\n错误分析：这个停机码说明注册表或系统配置管理器出现错误， 由于硬盘本身有物理损坏或文件系统存在问题， 从而造成在读取注册文件时出现输入/输出错误。\n解决方案：使用“chkdsk /r”检查并修复磁盘错误。\n", "0x52": "BUG代码 0x52：MAILSLOT_FILE_SYSTEM\n项目 • 2023/06/20MAILSLOT_FILE_SYSTEM Bug 检查 的值为 0x00000052。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x53": "BUG代码 0x53：NO_BOOT_DEVICE\n项目 • 2023/06/20NO_BOOT_DEVICE Bug 检查 的值为 0x00000053。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x54": "BUG代码 0x54：LM_SERVER_INTERNAL_ERROR\n项目 • 2023/06/20LM_SERVER_INTERNAL_ERROR Bug 检查 的值为 0x00000054。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x55": "BUG代码 0x55：DATA_COHERENCY_EXCEPTION\n项目 • 2023/06/20DATA_COHERENCY_EXCEPTION Bug 检查 的值为 0x00000055。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x56": "BUG代码 0x56：INSTRUCTION_COHERENCY_EXCEPTION\n项目 • 2023/06/20INSTRUCTION_COHERENCY_EXCEPTION Bug 检查 的值为 0x00000056。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x57": "BUG代码 0x57：XNS_INTERNAL_ERROR\n项目 • 2023/06/20XNS_INTERNAL_ERROR Bug 检查 值为 0x00000057。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x58": "BUG代码 0x58：FTDISK_INTERNAL_ERROR\n项目 • 2023/06/20FTDISK_INTERNAL_ERROR Bug 检查 的值为 0x00000058。 如果系统从镜像分区的错误副本启动，则会发出此问题。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FTDISK_INTERNAL_ERROR参数无原因配置单元指示镜像有效，但无效。 配置单元实际上应指向影子分区。这几乎总是由主分区恢复引起的。解决方法从影子分区重新启动系统。0x58:FTDISK_INTERNAL_ERROR\n错误分析：说明在容错集的主驱动发生错误。\n解决方案：首先尝试重启电脑看是否能解决问题， 如果不行， 则尝试“最后一次正确配置”进行解决。\n", "0x59": "BUG代码 0x59：PINBALL_FILE_SYSTEM\n项目 • 2023/06/15PINBALL_FILE_SYSTEM Bug 检查 的值为 0x00000059。 这表示 Pinball 文件系统中出现了问题。参数 说明1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 预留3 保留4 预留此 Bug 检查的一个可能原因是非分页池内存耗尽。 如果非分页池内存完全耗尽，则此错误可能会停止系统。 但是，在索引编制过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要解决非分页池内存耗尽问题，请执行以下操作： 将新的物理内存添加到计算机。 这将增加内核可用的非分页池内存数量。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。PINBALL_FILE_SYSTEM参数原因解决方法", "0x5A": "BUG代码 0x5A：CRITICAL_SERVICE_FAILED\n项目 • 2023/06/20CRITICAL_SERVICE_FAILED Bug 检查 的值为 0x0000005A。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x5B": "BUG代码 0x5B：SET_ENV_VAR_FAILED\n项目 • 2023/06/20SET_ENV_VAR_FAILED Bug 检查 的值为 0x0000005B。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x5C": "BUG代码 0x5C：HAL_INITIALIZATION_FAILED\n项目 • 2023/06/20HAL_INITIALIZATION_FAILED Bug 检查 的值为 0x0000005C。这表示 HAL 初始化失败。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x5D": "BUG代码 0x5D：UNSUPPORTED_PROCESSOR\n项目 • 2023/06/20UNSUPPORTED_PROCESSOR Bug 检查 的值为 0x0000005D。 这表示计算机正在尝试在不支持的处理器上运行 Windows。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UNSUPPORTED_PROCESSOR参数无原因Windows 需要比你正在使用的处理器更高级别的处理器。", "0x5E": "BUG代码 0x5E：OBJECT_INITIALIZATION_FAILED\n项目 • 2023/06/20OBJECT_INITIALIZATION_FAILED Bug 检查 的值为 0x0000005E。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。0x5E:CRITICAL_SERVICE_FAILED\n错误分析：某个非常重要的系统服务启动识别造成的。\n解决方案：如果是在安装了某个新硬件后出新的， 可以先移除该硬件， 并通过网上列表检查它是否\n与Windows 2K/XP兼容， 接着启动电脑， 如果蓝屏还是出现， 请使用“最后一次正确配置”来启动Windows，如果这样还是失败， 建议进行修复安装或是重装。\n", "0x5F": "BUG代码 0x5F：SECURITY_INITIALIZATION_FAILED\n项目 • 2023/06/20SECURITY_INITIALIZATION_FAILED Bug 检查 的值为 0x0000005F。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x60": "BUG代码 0x60：PROCESS_INITIALIZATION_FAILED\n项目 • 2023/06/20PROCESS_INITIALIZATION_FAILED Bug 检查 的值为 0x00000060。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0x61": "BUG代码 0x61：HAL1_INITIALIZATION_FAILED\n项目 • 2023/06/20检查HAL1_INITIALIZATION_FAILED Bug 的值为 0x00000061。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x62": "BUG代码 0x62：OBJECT1_INITIALIZATION_FAILED\n项目 • 2023/06/20OBJECT1_INITIALIZATION_FAILED Bug 检查 的值为 0x00000062。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x63": "BUG代码 0x63：SECURITY1_INITIALIZATION_FAILED\n项目 • 2023/06/20SECURITY1_INITIALIZATION_FAILED Bug 检查 的值为 0x00000063。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x64": "BUG代码 0x64：SYMBOLIC_INITIALIZATION_FAILED\n项目 • 2023/06/20SYMBOLIC_INITIALIZATION_FAILED Bug 检查 的值为 0x00000064。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x65": "BUG代码 0x65：MEMORY1_INITIALIZATION_FAILED\n项目 • 2023/06/20MEMORY1_INITIALIZATION_FAILED Bug 检查 的值为 0x00000065。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x66": "BUG代码 0x66：CACHE_INITIALIZATION_FAILED\n项目 • 2023/06/20CACHE_INITIALIZATION_FAILED Bug 检查 的值为 0x00000066。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x67": "BUG代码 0x67：CONFIG_INITIALIZATION_FAILED\n项目 • 2023/06/20CONFIG_INITIALIZATION_FAILED Bug 检查 的值为 0x00000067。 此 Bug 检查指示注册表配置失败。参数 描述1 保留2 位置选择器3 NT 状态代码4 保留注册表无法分配包含注册表文件所需的池。 这种情况不应发生，因为寄存器在系统初始化中提前分配了此池，因此应该有足够的分页池可用。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CONFIG_INITIALIZATION_FAILED参数原因", "0x68": "BUG代码 0x68：FILE_INITIALIZATION_FAILED\n项目 • 2023/06/20FILE_INITIALIZATION_FAILED Bug 检查 的值为 0x00000068。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x69": "BUG代码 0x69：IO1_INITIALIZATION_FAILED\n项目 • 2023/06/20IO1_INITIALIZATION_FAILED Bug 检查 的值为 0x00000069。 此 Bug 检查指示 I/O 系统的初始化由于某种原因失败。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。IO1_INITIALIZATION_FAILED参数无原因几乎没有可用于分析此错误的信息。最有可能是安装例程未正确安装系统，或者用户已重新配置系统。", "0x6A": "BUG代码 0x6A：LPC_INITIALIZATION_FAILED\n项目 • 2023/06/20LPC_INITIALIZATION_FAILED Bug 检查 的值为 0x0000006A。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x6B": "BUG代码 0x6B：PROCESS1_INITIALIZATION_FAILED\n项目 • 2023/06/20PROCESS1_INITIALIZATION_FAILED Bug 检查 的值为 0x0000006B。 此 Bug 检查指示Microsoft Windows 操作系统的初始化失败。蓝屏上会显示以下参数。参数 描述1 导致失败的 NT 状态代码2 保留3 保留4 保留磁盘子系统的任何部分都可能导致PROCESS1_INITIALIZATION_FAILED Bug 检查，包括磁盘坏、电缆不正确、在同一链上混合不同的 ATA 类型设备，或因硬件重新生成而不可用的驱动器。此 Bug 检查也可能由启动分区中的文件缺失或用户意外禁用的驱动程序在“驱动程序”选项卡中引起。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PROCESS1_INITIALIZATION_FAILED参数原因解决方法", "0x6C": "BUG代码 0x6C：REFMON_INITIALIZATION_FAILED\n项目 • 2023/06/20REFMON_INITIALIZATION_FAILED Bug 检查 的值为 0x0000006C。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x6D": "BUG代码 0x6D：SESSION1_INITIALIZATION_FAILED\n项目 • 2023/06/20SESSION1_INITIALIZATION_FAILED Bug 检查 的值为 0x0000006D。 此 Bug 检查指示Microsoft Windows 操作系统的初始化失败。参数 描述1 导致初始化失败的 NT 状态代码2 03 04 0） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION1_INITIALIZATION_FAILED参数", "0x6E": "BUG代码 0x6E：SESSION2_INITIALIZATION_FAILED\n项目 • 2023/06/20SESSION2_INITIALIZATION_FAILED Bug 检查 的值为 0x0000006E。 此 Bug 检查指示Microsoft Windows 操作系统的初始化失败。参数 描述1 导致 Windows 操作系统得出结论初始化失败的NT 状态代码2 03 04 0） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION2_INITIALIZATION_FAILED参数", "0x6F": "BUG代码 0x6F：SESSION3_INITIALIZATION_FAILED\n项目 • 2023/06/20SESSION3_INITIALIZATION_FAILED Bug 检查 的值为 0x0000006F。 此 Bug 检查指示Microsoft Windows 操作系统的初始化失败。参数 描述1 导致 Windows 操作系统得出结论初始化失败的NT 状态代码2 03 04 0） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION3_INITIALIZATION_FAILED参数0x6F:SESSION3_INITIALIZATION-FAILED\n错误分析：这个错误通常出现在Windows启动时， 一般是由有问题的驱动程序或损坏的系统文件引起的。\n解决方案：建议使用Windows安装光盘对系统进行修复安装。\n", "0x70": "BUG代码 0x70：SESSION4_INITIALIZATION_FAILED\n项目 • 2023/06/20SESSION4_INITIALIZATION_FAILED Bug 检查的值为 0x00000070。 此 Bug 检查指示Microsoft Windows 操作系统的初始化失败。参数 描述1 导致 Windows 操作系统得出结论初始化失败的NT 状态代码2 03 04 0） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION4_INITIALIZATION_FAILED参数", "0x71": "BUG代码 0x71：SESSION5_INITIALIZATION_FAILED\n项目 • 2023/06/20SESSION5_INITIALIZATION_FAILED Bug 检查 的值为 0x00000071。 此 Bug 检查指示Microsoft Windows 操作系统的初始化失败。参数 描述1 导致 Windows 操作系统得出结论初始化失败的NT 状态代码2 03 04 0） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION5_INITIALIZATION_FAILED参数", "0x72": "BUG代码 0x72：ASSIGN_DRIVE_LETTERS_FAILED\n项目 • 2023/06/20ASSIGN_DRIVE_LETTERS_FAILED Bug 检查 的值为 0x00000072。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x73": "BUG代码 0x73：CONFIG_LIST_FAILED\n项目 • 2023/06/20CONFIG_LIST_FAILED Bug 检查 的值为 0x00000073。 此 Bug 检查指示无法在注册表树中链接顶级注册表项之一（也称为核心系统配置单元）。参数 描述1 12 导致 Windows 操作系统无法加载配置单元的NT 状态代码3 配置单元列表中的配置单元的索引4 指向包含配置单元文件名的UNICODE_STRING结构的指针无法链接的注册表配置单元可能是 SAM、SECURITY、SOFTWARE 或 DEFAULT。 配置单元有效，因为它已成功加载。检查参数 2，了解无法在注册表树中链接配置单元的原因。 此错误的一个常见原因是Windows 操作系统在系统驱动器上的磁盘空间不足。 (在这种情况下，此参数0xC000017D，STATUS_NO_LOG_SPACE.) 另一个常见问题是尝试分配池失败。 (在这种情况下，参数 2 是0xC000009A，STATUS_INSUFFICIENT_RESOURCES.) 必须调查其他状态代码。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CONFIG_LIST_FAILED参数原因", "0x74": "BUG代码 0x74：BAD_SYSTEM_CONFIG_INFO\n项目 • 2023/06/20BAD_SYSTEM_CONFIG_INFO Bug 检查 的值为 0x00000074。 此 Bug 检查指示注册表中存在错误。参数 描述1 保留2 保留3 保留4 NT 状态值/代码 (是否可用)如果 SYSTEM 配置单元已损坏，则会发生BAD_SYSTEM_CONFIG_INFO Bug 检查。 但是，这种损坏不太可能，因为启动加载程序在加载配置单元时会检查配置单元是否损坏。如果缺少一些关键注册表项和值，则也会发生此 Bug 检查。 如果用户手动编辑注册表，或者应用程序或服务损坏了注册表，则键和值可能缺失。在参数 4 中查找返回的 NT 状态值可以提供其他信息，请参阅 列表的 NTSTATUS 值 。检查 Windows 系统事件日志，查看是否存在任何与注册表相关的错误事件。 如果存在，请查看事件是否列出了发生错误的配置单元或特定键。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BAD_SYSTEM_CONFIG_INFO参数原因解决方法dbgcmdBAD_SYSTEM_CONFIG_INFO (74)Can indicate that the SYSTEM hive loaded by the osloader/NTLDRwas corrupt. This is unlikely, since the osloader will checka hive to make sure it isn't corrupt after loading it.It can also indicate that some critical registry keys and valuesare not present. (i.e. somebody used regedt32 to delete somethingthat they shouldn't have) Booting from LastKnownGood may fixthe problem, but if someone is persistent enough in mucking withthe registry they will need to reinstall or use the EmergencyRepair Disk.Arguments:Arg1: 0000000000000002, (reserved)Arg2: ffffd481054b49f0, (reserved)Arg3: 0000000000000004, (reserved)Arg4: ffffffffc000014c, usually the NT status code.查看 ！analyze 返回的所有信息，了解失败情况。使用 ！error 扩展在参数 4 中显示有关 NTSTATUS 值的信息。dbgcmd2: kd> !ERROR ffffffffc000014cError code: (NTSTATUS) 0xc000014c (3221225804) - {The Registry Is Corrupt} The structure of one of the files that contains Registry data is corrupt, orthe image of the file in memory is corrupt, or the file could not berecovered because the alternate copy or log was absent or corrupt.使用 ！reg 扩展来显示有关注册表的信息，例如注册表中存在的配置单元。dbgcmd!reg hivelist-------------------------------------------------------------------------------------------------------------------------------------------------------| HiveAddr |Stable Length| Stable Map |Volatile Length| Volatile Map |MappedViews|PinnedViews|U(Cnt)| BaseBlock |FileName -------------------------------------------------------------------------------------------------------------------------------------------------------| ffff95077ea24000 | 1000 | ffff95077ea24588 | 0 | 0000000000000000 | 0| ffff95077ea31000 | <NONAME>| ffff95077ea3e000 | 12d3000 | ffff95077ea49000 | 21000 | ffff95077ea3e800 | 0| ffff95077ea40000 | SYSTEM| ffff95077ea8f000 | 53000 | ffff95077ea8f588 | 9000 | ffff95077ea8f800 | 0| ffff95077ea91000 | <NONAME>| ffff9507821c8000 | 7000 | ffff9507821c8588 | 0 | 0000000000000000 | 0| ffff9507821cc000 |kVolume2\\EFI\\Microsoft\\Boot\\BCD| ffff95077f6ae000 | 685c000 | ffff95077f737000 | 6000 | ffff95077f6ae800 | 0| ffff95077f6b6000 |emRoot\\System32\\Config\\SOFTWARE-------------------------------------------------------------------------------------------------------------------------------------------------------使用 ！reg openkeys 命令查看哪些注册表项已打开。dbgcmd2: kd> !reg openkeysHive: \\REGISTRY\\MACHINE\\SYSTEM===========================================================================================Index 0: 00000000 kcb=ffffd805e303c728 cell=00000020 f=002c0100\\REGISTRY\\MACHINE\\SYSTEMIndex 1: db67f96d kcb=ffffd805e416ed18 cell=00bd0b40 f=00200080\\REGISTRY\\MACHINE\\SYSTEM\\WPA\\8DEC0AF1-0341-4B93-85CD-72606C2DF94C-7P-374Index 3: db67ee93 kcb=ffffd805e30c5ab8 cell=00bc1550 f=00200080\\REGISTRY\\MACHINE\\SYSTEM\\WPA\\8DEC0AF1-0341-4B93-85CD-72606C2DF94C-7P-161Index 4: f9909d96 kcb=ffffd805e44bd268 cell=00bf8f50 f=00200000\\REGISTRY\\MACHINE\\SYSTEM\\CONTROLSET001\\CONTROL\\POWER\\PROFILE\\EVENTS\\{54533251-82BE-4824-96C1-47B60B740D00}\\{8BC6262C-C026-411D-AE3B-7E2F70811A13}Index 5: e9dd6ce5 kcb=ffffd805e4180e48 cell=00812970 f=00200000\\REGISTRY\\MACHINE\\SYSTEM\\DRIVERDATABASE...备注有关确定蓝屏原因的一般信息，请参阅 蓝屏数据。最好是确认有足够的硬盘驱动器或 SSD 存储空间可用于使 OS 正常运行。系统文件检查器工具可以在 Windows 中查找损坏。 有关详细信息，请参阅 使用系统文件检查器工具修复丢失或损坏的系统文件 。尝试启动到安全模式，然后正常重启 OS。 如果重启无法解决问题，则注册表损坏过于广泛。 请尝试以下步骤。如果有系统还原点，请尝试还原到较早的还原点。重置电脑。使用安装介质还原或重置电脑。使用安装介质重新安装 Windows。有关详细信息，请参阅 Windows 10 中的恢复选项 。此支持文章讨论此 Bug 检查代码：错误0x74：Bad_system_config_info", "0x75": "BUG代码 0x75：CANNOT_WRITE_CONFIGURATION\n项目 • 2023/06/20CANNOT_WRITE_CONFIGURATION Bug 检查 的值为 0x00000075。 此 Bug 检查指示系统注册表配置单元文件无法转换为映射文件。参数 描述1 12 导致 Windows 操作系统无法转换配置单元的NT 状态代码3 保留4 保留如果系统在池外并且 Windows 操作系统无法重新打开配置单元，通常会发生CANNOT_WRITE_CONFIGURATION Bug 检查。此 Bug 检查几乎永远不会发生，因为配置单元文件的转换在系统初始化期间发生得足够早，因此应有足够的池可用。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CANNOT_WRITE_CONFIGURATION参数原因", "0x76": "BUG代码 0x76：PROCESS_HAS_LOCKED_PAGES\n项目 • 2023/06/15PROCESS_HAS_LOCKED_PAGES Bug 检查 的值为 0x00000076。 此 Bug 检查指示驱动程序在执行 I/O 操作后未能释放锁定的页面，或者它尝试解锁已解锁的页面。参数 1 参数 2 参数 3 参数 4 错误原因0x00 指向进程对象的指针锁定页数 如果驱动程序堆栈) 启用，则指向驱动程序堆栈的指针 (。 否则此参数为零。正在终止的进程已锁定内存页。在进程终止之前，驱动程序必须解锁它可能锁定在进程中的任何内存。0x01 驱动程序指定的MDL进程中当前锁定的内存页数指向该进程的驱动程序堆栈的指针 (（如果) 启用）。 否则此参数为零。驱动程序正在尝试解锁未锁定的进程内存页。驱动程序无法解锁其锁定的页面 (参数 1 值0x0) ，或者驱动程序尝试解锁尚未锁定或已解锁的页面， (参数 1 值0x1) 。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。如果参数 1 值为 0x0） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。PROCESS_HAS_LOCKED_PAGES参数原因解决方法首先，在所有物理内存中，对当前进程指针使用 ！search 扩展。 此扩展可能会在 MDL)(找到指向当前进程的至少一个内存描述符列表。 接下来，对找到的每个 MDL 使用 ！search 获取指向当前进程的 I/O 请求数据包 (IRP) 。 在此 IRP 中，可以识别哪个驱动程序正在泄漏页面。否则，可以通过编辑注册表来检测导致错误的驱动程序：1. 在 \\\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SessionManager\\Memory Management 注册表项中，创建或编辑 TrackLockedPages值，然后将其设置为 DWORD 1。2. 重新启动计算机。然后，系统会保存堆栈跟踪，以便你可以轻松地识别导致问题的驱动程序。 如果驱动程序再次导致同一错误，则会发出0x76:PROCESS_HAS_LOCKED_PAGES\n错误分析：通常是因为某个驱动程序在完成了一次输入/输出操作后， 没有正确释放所占有的内存\n解决方案：\n第一步：点击开始--》运行：regedt32， 找到［HKLMSYSTEMCurrentcontrol setcontrolsessionmanagermemory management］， 在右侧新建双字节值“TrackLockedPages”， 值为1. 这样Windows便会在错误再次出现时跟踪到是哪个驱动程序的问题。\n第二步：如果再次出现蓝屏， 那么错误信息会变成：STOP:0xCB（0xY，0xY，0xY，0xY）DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS，其中第四个“0xY”会显示为问题驱动程序的名字， 接着对其进行更新或删除。\n第三步：进入注册表， 删除添加的“TrackLockedPages”。\n", "0x77": "BUG代码 0x77：KERNEL_STACK_INPAGE_ERROR另请参阅Bug 检查0x7B：INACCESSIBLE_BOOT_DEVICE\n项目 • 2023/03/08INACCESSIBLE_BOOT_DEVICE Bug 检查的值为 0x0000007B。 此 Bug 检查指示 MicrosoftWindows 操作系统在启动期间无法访问系统分区。参数 说明1 UNICODE_STRING结构的地址，或无法装载的设备对象的地址2 03 04 0若要确定参数 1 的含义，请查看它指向的数据。 如果此地址 (USHORT) 的第一个单词是偶数，则参数 1 是 Unicode 字符串的开头。 如果此地址 (USHORT) 的第一个单词0x3，则参数 1 是设备对象的 Type) (第一个字段。如果此参数指向设备对象，则本应读取启动设备的文件系统无法初始化或无法将启动设备上的数据识别为文件系统结构。 在这种情况下，指定的设备对象是无法装载的对象。如果此参数指向 Unicode 字符串，则必须读取此地址的前 8 个字节。 这些字节构成UNICODE_STRING结构。 以下示例演示如何定义 结构：C++） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。parametersUSHORT Length;USHORT MaximumLength;PWSTR Buffer;“长度”字段提供字符串的实际长度。 “缓冲区”字段指向字符串的开头。 缓冲区 始终至少0x80000000。字符串包含高级 RISC 计算 (ARC) 要尝试启动的设备规范名称。 ARC 名称是标识ARC 环境中的设备的一种通用方法。原因INACCESSIBLE_BOOT_DEVICE Bug 检查通常由于启动设备故障而发生。 在 I/O 系统初始化期间，启动设备驱动程序可能无法初始化启动设备（通常是硬盘）。文件系统初始化可能失败，因为它无法识别启动设备上的数据。 重新分区系统分区、更改 BIOS 配置或安装磁盘控制器也可能导致此错误。出现此错误的原因可能是磁盘硬件不兼容。 如果错误发生在系统的初始设置中，则表示系统可能已安装在不支持的磁盘控制器上。 某些磁盘控制器要求在 Windows 启动时存在其他驱动程序。当存储硬件发生故障并且无法响应来自 Windows 的请求时，可能会发生此错误。解决方法在系统启动时，始终会发生此错误。 此错误经常在建立调试器连接之前发生，因此调试可能很困难。 OS 可能无法访问，错误日志可能为空，因为 OS 尚未启动足够远，无法启动这些子系统。 以下部分介绍了这两种情况（如果无法启动 Windows 和能够启动Windows）的解决方案。如果无法启动 Windows如果收到此停止代码，并且 Windows 无法向前启动到 OS，请尝试以下解决方法：还原任何最近的硬件更改。删除最近添加的任何硬件，尤其是硬盘驱动器或控制器，以查看错误是否已解决。如果有问题的硬件是硬盘驱动器，则磁盘固件版本可能与你的 Windows 操作系统版本不兼容。 请联系制造商获取更新。 如果删除了另一个硬件并解决了错误，则可能存在 IRQ 或 I/O 端口冲突。 根据制造商的说明重新配置新设备。如果最近对 UEFI (BIOS) 设置进行了更改，例如在 UEFI 中将控制器模式从旧版更改为 AHCI，请还原这些更改。 有关详细信息，请参阅 高级主机控制器接口 。检查存储设备兼容性。确认所有硬盘驱动程序、硬盘控制器和任何其他存储适配器都与已安装的 Windows版本兼容。 例如，可以在Windows 10规范 中获取有关兼容性的信息。更新 UEFI (BIOS) 和固件。检查系统 UEFI (BIOS) 和存储控制器固件的更新的可用性。使用 Windows 媒体创建工具创建可启动 U 盘或 DVD。使用另一台计算机上的媒体创建工具创建可启动的 U 盘或 DVD。 使用此工具通过选择安装文件或从 USB 启动来执行全新安装。有关详细信息，请参阅 获取 Windows 10 。可能需要禁用功能，或在 UEFI (BIOS) 菜单中更改启动顺序优先级，才能从 USB、FDD (FlashDiskDrive) 或 DVD 而不是 HDD 启动。常见启动菜单键启动菜单键因制造商而异。 通常使用这些键。 查看电脑文档以确定所使用的启动密钥。常用启动菜单键包括：F12ESCF9F10F8常见的 UEFI (BIOS) 安装密钥UEFI (BIOS) 设置密钥因制造商而异。 通常使用这些键。 查看电脑文档以确定所使用的设置密钥。常用的 UEFI (BIOS) 安装密钥包括：ESCDELF2如果收到此停止代码并且 Windows 已启动，请尝试以下解决方法：启动到安全模式，然后正常启动。如果能够启动 Windows启动到安全模式会加载一组核心存储驱动程序，这些驱动程序允许再次访问存储系统。 完成以下步骤以启动到安全模式：1. 在 “设置”中，选择“ 更新和安全”。2. 选择“ 恢复 > 高级启动 ”以启动到维护模式。3. 在生成的菜单中，选择“高级选项>疑难解答>”“启动设置>重启”。4. Windows 重启到 “启动设置” 屏幕后，选择选项 4、5 或 6 以启动到安全模式。在安全模式下加载 Windows 后，重启电脑以查看是否已加载正确的存储驱动程序以及是否识别了存储设备。也可以通过在启动时按功能键（例如 F8）来使用安全模式。 有关特定启动选项，请参阅系统制造商提供的信息。使用扫描磁盘实用工具确认没有文件系统错误。 选择并按住 (或右键单击要扫描的驱动器上的) ，然后选择“立即检查属性>工具>”。运行病毒检测程序。 病毒可能会感染为 Windows 格式化的所有类型的硬盘，由此产生的磁盘损坏可能会生成系统 Bug 检查代码。 确保病毒检测程序检查主启动记录是否存在感染。对于 IDE 设备，仅将载入 IDE 端口定义为主要端口。 此外，检查每个 IDE 设备是否采用正确的 主/从/独立 设置。 尝试删除除硬盘以外的所有 IDE 设备。 最后，检查系统登录事件查看器中是否有其他错误消息，这些错误消息可能有助于识别导致错误的设备或驱动程序。确认硬盘上有足够的可用空间。 操作系统和某些应用程序需要足够的可用空间来创建交换文件和执行其他功能。 根据系统配置，确切要求会有所不同，但最好有 10%到 15% 的可用空间。查看设备管理器，查看是否有任何设备标有感叹号 (！) 。 查看故障驱动程序的驱动程序属性中显示的事件日志。 请尝试更新相关驱动程序。检查系统登录事件查看器中是否有其他错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。 有关详细信息，请参阅打开事件查看器。 在系统日志中查找与蓝屏相同的时间范围内发生的严重错误。你可尝试运行系统制造商提供的硬件诊断。使用系统文件检查器工具修复丢失或损坏的系统文件。 系统文件检查器是 Windows中的一个实用工具，允许用户扫描 Windows 系统文件中的损坏并还原损坏的文件。使用以下命令运行系统文件检查器工具 (SFC.exe) 。控制台SFC /scannow有关详细信息，请参阅 使用系统文件检查器工具修复丢失或损坏的系统文件 。自动修复后，在“选择选项”屏幕上，选择“高级选项>系统还原疑难解答>”。 此选项将电脑恢复到以前的时间点，称为系统还原点。 在安装新应用、驱动程序、更新或手动创建还原点时，会生成还原点。 在遇到错误之前选择还原点。使用内核调试器附加到系统，并进一步分析故障，如备注中所述。备注调查存储系统配置。若要缩小原因范围，尽可能多地了解安装 Windows 的启动设备会很有帮助。 例如，可以调查以下\n项目：了解启动设备连接到的控制器类型，例如 SATA 或 IDE。 如果可以启动系统，则可以使用设备管理器检查控制器和磁盘驱动程序属性。 可以看到关联的驱动程序文件和错误事件。指示其他设备是否连接到启动设备所在的同一控制器，例如 SSD 或 DVD。请注意驱动器上使用的文件系统，通常为 NTFS。Windows 调试器若要使用内核调试器分析此错误，请在调试器 中运行 lm (列出加载的模块) 命令，以查看加载了哪些模块以尝试隔离特定的驱动程序。 验证是否已加载以下驱动程序。磁盘dbgcmd 0: kd> lm m diskBrowse full module liststart end module namefffff806`bd0b0000 fffff806`bd0cd000 disk (deferred)partmgrdbgcmd0: kd> lm m partmgrBrowse full module liststart end module namefffff806`bc5a0000 fffff806`bc5c1000 partmgr (deferred)NTFSdbgcmd0: kd> lm m ntfsBrowse full module liststart end module namefffff806`bd3f0000 fffff806`bd607000 NTFS (deferred)classpnpdbgcmd0: kd> lm m classpnpBrowse full module liststart end module namefffff806`bd0d0000 fffff806`bd131000 CLASSPNP (deferred)Pcidbgcmd0: kd> lm m pciBrowse full module liststart end module namefffff806`bc440000 fffff806`bc494000 pci (deferred) 确保已加载控制器驱动程序。 例如，对于 SATA RAID 控制器，驱动程序可能是iaStorA.Sys 驱动程序，也可能是 EhStorClass 驱动程序。dbgcmd0: kd> lm m EhStorClassBrowse full module liststart end module namefffff806`bcbb0000 fffff806`bcbcb000 EhStorClass (deferred) 可能包含包含“stor”的驱动程序，例如 storahci。dbgcmd0: kd> lm m stor*Browse full module liststart end module namefffff806`bcb00000 fffff806`bcb23000 storahci (deferred) fffff806`bcb30000 fffff806`bcbaa000 storport (deferred) fffff806`c0770000 fffff806`c0788000 storqosflt (deferred)在附加了调试器的情况下启动。如果可以在连接调试器的情况下启动目标系统，请在进行 Bug 检查时发出 ！devnode 01 。 可以看到哪个设备缺少驱动程序或未启动，未启动的原因可能很明显。一个原因可能是即插即用无法将资源分配给启动设备。 可以通过查找服务的条目来验证此限制。 如果状态标志包括DNF_INSUFFICIENT_RESOURCES或不包含DNF_STARTED或DNF_ENUMERATED，则可能已找到问题。 尝试 !devnode 0 1 storahci 节省一些时间，而不是转储整个设备树。dbgcmd0: kd> !devnode 0 1 storahciDumping IopRootDeviceNode (= 0xffffb9053d94d850)DevNode 0xffffb9053e8dea50 for PDO 0xffffb9053e8da060 InstancePath is\"PCI\\VEN_8086&DEV_3B22&SUBSYS_304A103C&REV_05\\3&21436425&0&FA\" ServiceName is \"storahci\" State = DeviceNodeStarted (0x308) Previous State = DeviceNodeEnumerateCompletion (0x30d) DevNode 0xffffb9053e88db30 for PDO 0xffffb9053e890060 InstancePath is \"SCSI\\Disk&Ven_&Prod_ST3500418AS\\4&23d99fa2&0&000000\" ServiceName is \"disk\" State = DeviceNodeStarted (0x308) Previous State = DeviceNodeEnumerateCompletion (0x30d) DevNode 0xffffb9053e88d850 for PDO 0xffffb9053e88e060 InstancePath is \"SCSI\\CdRom&Ven_hp&Prod_DVD￾RAM_GH60L\\4&23d99fa2&0&010000\" ServiceName is \"cdrom\" TargetDeviceNotify List - f 0xffffdf0ae9bbb0e0 b 0xffffdf0aea874710 State = DeviceNodeStarted (0x308) Previous State = DeviceNodeEnumerateCompletion (0x30d)0x77:KERNEL_STACK_INPAGE_ERROR\n错误分析：说明需要使用的内核数据没有在虚拟内存或物理内存中找到。 这个错误常常于是着磁盘有问题， 相应数据损坏或受到病毒侵蚀。\n解决方案：使用杀毒软件扫描系统; 使用“chkdsk /r”命令检查并修复磁盘错误， 如不行则使用磁盘厂商提供的工具检查修复。\n", "0x78": "BUG代码 0x78：PHASE0_EXCEPTION\n项目 • 2023/06/20PHASE0_EXCEPTION Bug 检查 的值为 0x00000078。此 Bug 检查在 HAL 初始化期间遇到意外中断时发生。 如果在启动设置中设置了 /break参数，但尚未启用内核调试，则可能会发生此中断。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x79": "BUG代码 0x79：MISMATCHED_HAL\n项目 • 2023/06/20MISMATCHED_HAL Bug 检查 值为 0x00000079。 此 Bug 检查指示硬件抽象层 (HAL) 修订级别或配置与内核或计算机的版本级别或配置不匹配。参数 1 指示不匹配的类型。参数 1 参数 2 参数 3 参数 4 原因。0x1 主处理器控制块(PRCB)Ntoskrnl.exe级别。Hal.dll的主要中国B级别。保留 PRCB 发布级别不匹配。 (某些内容已过期。)0x2 Ntoskrnl.exe的生成类型。Hal.dll的生成类型。保留 生成类型不匹配。0x3 加载程序参数扩展的大小。加载程序参数扩展的主版本。加载程序参数扩展的次要版本。加载程序 (ntldr)和 HAL 版本不匹配。当参数 1 等于0x2时，将使用以下生成类型代码：0：已启用多处理器的免费内部版本1：已启用多处理器的已检查生成2：单处理器免费版本3：单处理器检查版本当用户手动更新Ntoskrnl.exe或Hal.dll时，通常会发生MISMATCHED_HAL Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MISMATCHED_HAL参数原因错误也可能指示这两个文件之一已过期。 或者计算机可能错误地安装了多处理器 HAL 和单处理器内核，反之亦然。Ntoskrnl.exe内核文件适用于单处理器系统，Ntkrnlmp.exe适用于多处理器系统。 但是，这些文件名对应于安装介质上的文件。安装 Windows 操作系统后，无论使用的源文件如何，文件都会重命名为 Ntoskrnl.exe。 HAL 文件在安装后也使用Hal.dll名称，但在较旧版本的 Windows 上的安装媒体上有几个可能的 HAL 文件。解决方法使用产品 CD 或 Windows 安装程序磁盘重启计算机。 在“欢迎”屏幕上，按 F10 启动恢复控制台。 使用 Copy 命令将原始 CD 中正确的 HAL 或内核文件复制到硬盘上的相应文件夹中。 Copy 命令检测要复制的文件是否为 Microsoft 压缩文件格式。 如果是这样，它会自动展开目标驱动器上复制的文件。", "0x7A": "BUG代码 0x7A：KERNEL_DATA_INPAGE_ERROR\n项目 • 2023/06/20KERNEL_DATA_INPAGE_ERROR Bug 检查 的值为 0x0000007A。 此 Bug 检查指示无法将分页文件中请求的内核数据页读入内存。消息中列出的四个参数可能具有三种可能的含义。如果第一个参数为 1、2 或 3，而第三个参数为 0，则参数具有以下定义。参数 描述1 锁定 (1、2 或 3)2 错误状态 (通常是 I/O 状态代码)3 如果锁类型为 1：当前进程如果锁类型为 2 或 3：04 无法分页到内存中的虚拟地址如果第一个参数为 3 或 4 (并且第三个参数不是 0) ，则参数具有以下定义。参数 描述1 锁定 (3 或 4)2 错误状态 (通常是 I/O 状态代码)3 InPageSupport 结构的地址4 错误地址否则，参数具有以下定义。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。参数参数 描述 参数 描述1 页表条目的地址 (PTE)2 错误状态 (通常是 I/O 状态代码)3 PTE 内容4 错误地址通常，可以从错误状态 (参数 2) 确定检查KERNEL_DATA_INPAGE_ERROR Bug 的原因。 这些是 NTSTATUS 值。一些常见的状态代码包括：0xC000009A或STATUS_INSUFFICIENT_RESOURCES表示缺少非分页池资源。0xC000009C（或STATUS_DEVICE_DATA_ERROR）通常表示硬盘上) 扇区 (坏块。0xC000009D或STATUS_DEVICE_NOT_CONNECTED表示有缺陷或松散的布线、终止或控制器看不到硬盘。0xC000016A（或STATUS_DISK_OPERATION_FAILED）指示硬盘上) 扇区 (坏块。0xC0000185（或STATUS_IO_DEVICE_ERROR）表示 SCSI 设备上的错误终止或电缆有缺陷，或者两个设备正在尝试使用同一 IRQ。0xC000000E或STATUS_NO_SUCH_DEVICE表示硬件故障或驱动器配置不正确。 检查电缆，并使用驱动器制造商提供的诊断实用工具检查驱动器。 如果使用较旧的PATA (IDE) 驱动器，则此状态代码可能指示主/从驱动器配置不正确。这些状态代码是具有特定原因的最常见状态代码。 有关可为特定版本的 Windows 返回的其他可能状态代码的详细信息，请参阅 Ntstatus.h Microsoft Windows 驱动程序工具包(WDK) 中的 文件。 OSR 作为第三方，提供了一个 PDF 文档，用于将 NTSTATUS 映射到Win32 错误代码 NTSTATUS 到 Win32 错误代码映射出现此错误消息的另一个常见原因是存储硬件有缺陷或 RAM 内存失败。病毒感染也可能导致此 Bug 检查。原因解决方法解决错误的块问题： 0xC000009C或0xC000016A的 I/O 状态代码通常指示由于扇区) (块错误而无法从磁盘读取数据。 如果在出现错误后可以重启计算机，Autochk 会自动运行并尝试映射坏扇区，以防止它再次被使用。如果 Autochk 未扫描硬盘中的错误，则可以手动启动磁盘扫描程序。 Chkdsk /f /r在系统分区上运行。 在磁盘扫描开始之前，必须重新启动计算机。 如果由于错误而无法启动计算机，请使用恢复控制台并运行 Chkdsk /r。解决 RAM 故障问题：运行系统制造商提供的硬件诊断，尤其是内存扫描程序。 有关这些过程的详细信息，请参阅计算机所有者手册。解决有缺陷的硬件问题：如果 I/O 状态为 C0000185，并且分页文件位于较旧的 SCSI 磁盘上，检查磁盘布线和 SCSI 终止问题。解决病毒感染： 使用检查硬盘主启动记录的任何最新的商业病毒扫描软件来检查计算机中的病毒。 Windows 文件系统可能感染病毒。在系统事件查看器中查看可能有助于识别导致错误的设备的错误消息。 具体而言，应检查在 Bug 检查之前发生的错误。确保已安装最新的 Windows 更新。找到并运行电脑的任何可用诊断测试软件。 主板上的裂缝、划痕或有缺陷的组件可能会导致此 Bug 检查。对于具有卡插槽的电脑，检查计算机中的所有适配器卡都正确就位。 使用电子电源商店提供的墨迹橡皮擦或电接触处理，以确保适配器卡触点清洁。0x7A:KERNEL_DATA_INPAGE_ERRO\n\n问题原因：\n\nWinodws系统故障或第三方软件故障\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0x7A:KERNEL_DATA_INPAGE_ERROR\n错误分析：这个错误往往是虚拟内存中的内核数据无法读入内存造成的。 原因可能是虚拟内存页面文件中存在坏簇、病毒、磁盘控制器出错、内存有问题。 ［！--empirenews.page--］分页标题［/！--empirenews.page--］\n解决方案：首先用升级为最新病毒库杀毒软件查杀病毒， 如果促无信息中还有0xC9C或0xC16A代码， 那么表示是坏簇造成的， 并且系统的磁盘检测工具无法自动修复， 这时要进入“故障恢复控制台”， 用“chkdsk /r”命令进行手动修复。\n", "0x7C": "BUG代码 0x7C：BugCODE_NDIS_DRIVER\n项目 • 2023/06/15BugCODE_NDIS_DRIVER Bug 检查 的值为 0x0000007C。 此 Bug 检查指示操作系统在网络驱动程序中检测到错误。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。 如果参数的值为“0”，则表示不使用此参数。参数1参数 1 值和错误原因 参数 2 参0x01 NDIS_BugCHECK_ALLOCATE_SHARED_MEM_HIGH_IRQL引发的 IRQL 处名为 NdisMAllocateSharedMemory 的驱动程序。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。请0x02 NDIS_BugCHECK_SHARED_MEM_CORRUPTION在调用 NdisMAllocateSharedMemory 期间，NDIS 检测到以前分配的共享内存页已损坏。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。0x03 NDIS_BugCHECK_FREE_INVALID_SHARED_MEM名为 NdisMFreeSharedMemory 的微型端口驱动程序 (具有已释放的共享内存地址的 异步) 。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。从0x04 NDIS_BugCHECK_UNLOAD_DRIVER_INVALID_PARAMETERAddDevice 是使用不在 NDIS 中注册的驱动程序列表中的驱动程序调用的。仅在特殊检测的 NDIS 上启用。NDIS_M_DRIVER_BLOCK的地址0x05 NDIS_BugCHECK_RECVD_PACKET_IN_USE_BAD_STACK_LOCATION以太网驱动程序指示它使用协议堆栈当前正在使用的数据包描述符接收数据包。通过检查堆栈数据包位置捕获。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。驱址运0x06 NDIS_BugCHECK_RECVD_PACKET_IN_USE_BAD_REF_COUNT以太网驱动程序指示它使用协议堆栈当前正在使用的数据包描述符接收数据包。通过检查数据包引用计数捕获。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。驱址运0x07 FDDI 驱动程序指示它使用协议堆栈当前正在使用的数据包描述符接收了数据包。通过检查引用计数捕获。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。驱址运0x08 NDIS_BugCHECK_HALT_WITHOUT_INTERRUPT_DEREGISTER微型端口驱动程序未在停止过程中取消注册其中断。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。0x09 NDIS_BugCHECK_HALT_WITHOUT_CANCEL_TIMER微型端口驱动程序停止，但未成功取消其所有计时器。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。微址0x0A NDIS_BugCHECK_DRIVER_UNLOAD_UNEXPECTED微型端口驱动程序过早卸载。NDIS_M_DRIVER_BLOCK的地址0x0B NDIS_BugCHECK_INIT_FAILED_WITHOUT_INTERRUPT_DEREGISTER微型端口驱动程序初始化失败，但未取消注册其中断。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。0x0C NDIS_BugCHECK_INIT_FAILED_WITHOUT_CANCEL_TIMER微型端口驱动程序初始化失败，但未成功取消其所有计时器。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。微址） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。BugCODE_NDIS_DRIVER参数参数1参数 1 值和错误原因 参数 2 参0x0D NDIS_BugCHECK_HALT_INIT_WITHOUT_INTERRUPT_DEREGISTER微型端口驱动程序未在停止过程中取消注册其中断。在微型端口驱动程序从其初始化处理程序返回成功后，从初始化例程调用了 halt。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。0x0E NDIS_BugCHECK_HALT_INIT_WITHOUT_CANCEL_TIMER微型端口驱动程序停止，但未成功取消其所有计时器。在微型端口驱动程序从其初始化处理程序返回成功后，从初始化例程调用了 halt。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。微址0x0F NDIS_BugCHECK_RESET_COMPLETE_UNEXPECTED名为 NdisMResetComplete 的 微型端口驱动程序，没有任何挂起的重置请求。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。重0x10 NDIS_BugCHECK_PM_INIT_FAILED_NO_INT_DEREGISTER从低功耗状态恢复后，微型端口驱动程序初始化失败，但未取消注册中断。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。0x11 NDIS_BugCHECK_PM_INIT_FAILED_NO_CANCEL_TIMER从低功耗状态恢复后，微型端口驱动程序初始化失败，但未成功取消其所有计时器。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。微址0x12 NDIS_BugCHECK_NFILTER_RECVD_PACKET_BAD_REF_COUNT微型端口驱动程序指示它收到了使用协议堆栈当前正在使用的数据包描述符的数据包。通过检查数据包引用计数捕获。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。驱址运0x13 NDIS_BugCHECK_TFILTER_RECVD_PACKET_BAD_REF_COUNTToken-Ring微型端口驱动程序指示它使用协议堆栈当前正在使用的数据包描述符接收数据包。通过检查数据包引用计数捕获。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。驱址运0x14 NDIS_BugCHECK_WAIT_EVENT_HIGH_IRQL非法 IRQL 中名为 NdisWaitEvent 的 NDIS 驱动程序实际 IRQL 00x15 NDIS_BugCHECK_INVALID_NDIS5_CALL名为 API 的微型端口驱动程序，该 API 是为较旧的驱动程序保留的。 驱动程序应仅调用 NDIS 6.x API。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。00x16 NDIS_BugCHECK_INVALID_OPEN_IN_BIND_CONTEXT协议驱动程序在绑定期间未正确打开适配器。特定协议的地址。 有关详细信息，请使用此地址运行 ！ndiskd.protocol 。 协址投0x17 NDIS_BugCHECK_IFPROVIDER_DEREGISTER_UNEXPECTED名为 NdisIfDeregisterProvider 的 接口提供程序，无需先删除其所有接口。接口提供程序句柄的地址。 使用此地址运行 ！ndiskd.ifprovider 以获取详细信息。 00x1B NDIS_BugCHECK_IF_STACK_TABLE_LOOP驱动程序尝试将接口添加到 ifStackTable，但这样做会导致循环。ifStackTable 不得有周期。 运行 ！ndiskd.ifstacktable 以查看当前表 (，然后再调用 NdisIfAddIfStackEntry) 。要添加到表中的 HigherLayerIfIndex 要0x1C NDIS_BugCHECK_MINIPORT_FAILED_OID_WHICH_MUST_SUCCEED微型端口驱动程序失败了不得失败的 OID 请求。 这样做会泄漏内存或其他资源。特定微型端口适配器块的地址。 使用此地址运行 ！ndiskd.netadapter 以获取详细信息。失找0x1D NDIS_BugCHECK_OID_REQUEST_INVALID_BUFFER微型端口驱动程序或筛选器驱动程序已非法完成 OID 请求。 检查BytesWritten 是否不大于缓冲区的整个长度。特定微型端口适配器或筛选器模块块的地址。 使用此地址运行 ！ndiskd.netadapter 或 ！ndiskd.filter 以获取详细信息。非址参数1参数 1 值和错误原因 参数 2 参0x1E NDIS_BugCHECK_REFCOUNT_IMBALANCENDIS 在内部 refcount 中检测到错误。 这可以由引用下溢 (比引用)更多的取消引用或标记不匹配导致的。0或0x1F NDIS_BugCHECK_ILLEGAL_MINIPORT_STATE_TRANSITION微型端口驱动程序非法完成了状态转换。失败的内容。 可能的值：1. NDIS_BugCHECK_ILLEGAL_MINIPORT_STATE_TRANSITION_PAUSE_COMPLETE名为 NdisMPauseComplete 的 微型端口，但没有挂起的暂停操作。2. NDIS_BugCHECK_ILLEGAL_MINIPORT_STATE_TRANSITION_RESTART_COMPLETE名为 NdisMRestartComplete 的 微型端口，但没有挂起的重启操作。特用以0x20 NDIS_BugCHECK_STATUS_INDICATION_INVALID_BUFFER微型端口驱动程序或筛选器驱动程序指示NDIS_STATUS_INDICATION非法。状态指示的类型。 请对此代码运行 ！ndiskd.help 以获取详细信息。 指的以0x21 NDIS_BugCHECK_INVALID_OBJECT_HEADER驱动程序创建了无效 NDIS_OBJECT_HEADER。指示非法状态指示的驱动程序的句柄。 使用此句柄运行 ！ndiskd.minidriver 或 ！ndiskd.filterdriver 以获取详细信息。具释动将0x22 NDIS_BugCHECK_ILLEGAL_NET_PNP_EVENT微型端口驱动程序或筛选器驱动程序指示NET_PNP_EVENT_NOTIFICATION非法。指示非法状态指示的驱动程序的句柄。 使用此句柄运行 ！ndiskd.minidriver 或 ！ndiskd.filterdriver 以获取详细信息。强0x23 NDIS_BugCHECK_PD_ERROR在数据包直通数据路径中检测到错误。Bug 检查的子类型。 可能的值：1. NDIS_BugCHECK_PD_ERROR_EC_THREAD_MISMATCH在错误的线程上调用了 API。2. NDIS_BugCHECK_PD_ERROR_ILLEGAL_ARM_BY_CLIENTPD 客户端试图在处于非法状态时武装提供程序。3. NDIS_BugCHECK_PD_ERROR_ILLEGAL_ARM_NOTIFICATION一家 PD 提供商在未携带武器时非法触发了排水通知。4. NDIS_BugCHECK_PD_ERROR_ILLEGAL_ARM_NOTIFICATION_VIA_ISRPD 提供商在未携带武器时非法触发了 ISR 排出通知。5. NDIS_BugCHECK_PD_ERROR_ILLEGAL_THUNK_BY_LWF筛选器驱动程序试图干扰数据包直通数据路径。6. NDIS_BugCHECK_PD_ERROR_ILLEGAL_BM_GROUP_REQUESTPD 提供程序非法尝试从缓冲区管理器组中删除自身。7. NDIS_BugCHECK_PD_ERROR_ILLEGAL_PD_BUFFER_SETUPPD 缓冲区设置请求格式不正确。参列相0x24 NDIS_BugCHECK_UNEXPECTED_FAILURE内部操作意外失败。 这很可能是NDIS.SYS本身的 Bug。失败的操作。 可能的值：0x01：NDIS_BugCHECK_UNEXPECTED_FAILURE_KEWAITFORSINGLEOBJECT对 KeWaitForSingleObject 的调用失败。失参数1参数 1 值和错误原因 参数 2 参0x25 NDIS_BugCHECK_WATCHDOG尝试管理网络堆栈花费的时间太长。 当 NDIS 调用到其他驱动程序时，NDIS 会启动一个监视器计时器，以确保调用及时完成。 如果调用时间过长，NDIS 将注入 Bug 检查。这可能是由简单的死锁引起的。 使用“！stacks 2 ndis”或类似内容查看是否有任何线程看起来可疑。 请特别注意NDIS_WATCHDOG_TRIAGE_BLOCK中的 PrimaryThread。这可能是由丢失 NBL 引起的，在这种情况下 ！ndiskd.pendingnbls可能会有所帮助。 检查使用 ！ndiskd.oid 卡住的 OID。耗时过长的操作。 可能的值：0x01 ： NDIS_BugCHECK_WATCHDOG_PROTOCOL_PAUSE暂停协议驱动程序时超时。0x02：NDIS_BugCHECK_WATCHDOG_PROTOCOL_NETPNPEVENT将NET_PNP_EVENT_NOTIFICATION传送到协议驱动程序时超时。0x03：NDIS_BugCHECK_WATCHDOG_PROTOCOL_STATUS_INDICATION向协议驱动程序提供状态指示时超时。0x04：NDIS_BugCHECK_WATCHDOG_PROTOCOL_UNBIND取消绑定协议驱动程序时出现超时。0x11：NDIS_BugCHECK_WATCHDOG_FILTER_PAUSE暂停筛选器驱动程序时超时。0x12： NDIS_BugCHECK_WATCHDOG_FILTER_NETPNPEVENT向筛选器驱动程序传送NET_PNP_EVENT_NOTIFICATION时超时。0x13：NDIS_BugCHECK_WATCHDOG_FILTER_STATUS_INDICATION向筛选器驱动程序提供状态指示时超时。0x14：NDIS_BugCHECK_WATCHDOG_FILTER_DETACH分离筛选器驱动程序时超时。0x21：NDIS_BugCHECK_WATCHDOG_MINIPORT_PAUSE暂停微型端口适配器时超时。0x22：NDIS_BugCHECK_WATCHDOG_MINIPORT_HALT停止微型端口适配器时超时。0x23：NDIS_BugCHECK_WATCHDOG_MINIPORT_OID向微型端口适配器传递 OID 请求时超时。0x24：NDIS_BugCHECK_WATCHDOG_FILTER_OID向筛选器驱动程序传递 OID 请求时超时。0x25：NDIS_BugCHECK_WATCHDOG_MINIPORT_IDLE在将微型端口适配器闲移时超时。0x26： NDIS_BugCHECK_WATCHDOG_CANCEL_IDLE取消微型端口适配器上的空闲请求时超时。投有0x26 NDIS_BugCHECK_INVALID_OID_COMPLETION微型端口驱动程序尝试完成当前未在该微型端口驱动程序上挂起的OID 请求。 这可能是由驱动程序多次尝试完成同一请求导致的。导致 Bug 检查的微型端口驱动程序句柄。 使用此句柄运行 ！ndiskd.minidriver 以获取详细信息。微O行无0x27 NDIS_BugCHECK_LEAKED_NBL驱动程序泄漏了 NET_BUFFER_LIST 结构。 请与 ！ndiskd.pendingnbls 一 起查看此驱动程序上仍处于挂起状态的任何NBL。检测到泄漏的位置。 可能的值：0x01：NBL 跟踪器检测到泄漏。 当前正在取消注册或取消绑定的驱动程序是最有可能的原因。 查看 Bug 检查线程的调用堆栈。 驱动程序在仍保留活动 NBL时不得取消绑定或取消注册。0参数 1 指示BugCODE_NDIS_DRIVER Bug 检查的具体原因。BugCODE_NDIS_DRIVER Bug 检查会修正网络驱动程序中的问题。 通常，此问题是由 NDIS 微型端口驱动程序引起的。 可以使用 ！ndiskd.netadapter 获取 NDIS 微型端口驱动程序的完整列表。 可以使用 ！ndiskd.netreport 获取网络堆栈的更全面概述。此 Bug 检查代码仅在 Microsoft Windows Server 2003 及更高版本的 Windows 上出现。 在 Windows 2000 和 Windows XP 中，相应的代码是", "0x7D": "BUG代码 0x7D：INSTALL_MORE_MEMORY\n项目 • 2023/06/20INSTALL_MORE_MEMORY Bug 检查 的值为 0x0000007D。 此 Bug 检查表示没有足够的内存来启动 Microsoft Windows 操作系统。参数 描述1 找到的物理页数2 最低物理页3 最高物理页4 0Windows 操作系统没有足够的内存来完成启动过程。安装更多内存。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INSTALL_MORE_MEMORY参数原因解决方法", "0x7E": "BUG代码 0x7E：SYSTEM_THREAD_EXCEPTION_NOT_HANDLED\n项目 • 2023/06/20SYSTEM_THREAD_EXCEPTION_NOT_HANDLED Bug 检查 的值为 0x0000007E。 此 Bug检查 指示系统线程生成了错误处理程序未捕获的异常。参数 描述1 未处理的异常代码。2 发生异常的地址。3 异常记录的地址。4 上下文记录的地址。此 Bug 检查 指示系统线程生成了错误处理程序未捕获的异常。 若要对其进行解释，必须确定生成的具体异常。常见的异常代码包括以下内容：0x80000002：STATUS_DATATYPE_MISALIGNMENT表示遇到未对齐的数据引用。0x80000003：STATUS_BREAKPOINT指示未将内核调试器附加到系统时遇到断点或ASSERT。0xC0000005：STATUS_ACCESS_VIOLATION表示发生了内存访问冲突。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SYSTEM_THREAD_EXCEPTION_NOT_HANDLED参数原因有关异常代码的完整列表，请参阅 NTSTATUS 值。 异常代码在 ntstatus.h（Windows 驱动程序工具包提供的标头文件）中定义。 有关详细信息，请参阅 Windows 驱动程序工具包中的头文件。如果计划调试此问题，则异常地址 (参数 2) 应标识导致此问题的驱动程序或函数。如果在 Bug 检查消息中按名称列出了驱动程序，请禁用或删除该驱动程序。 如果问题缩小到单个驱动程序，请在代码中设置断点和单步前进，以查找故障并深入了解导致崩溃的事件。!analyze 调试程序扩展显示有关 Bug 检查的信息，有助于确定根本原因。可以使用 ！thread 扩展完成更多分析， dds、dps 和 dqs () 命令显示单词和符号 。 当WinDbg 报告“可能是由 ntkrnlmp.exe 引起的”时，此方法是合理的。如果发生异常代码0x80000003，则命中硬编码断点或断言，但系统已使用 /NODEBug开关启动。 此问题不应经常发生。 如果重复发生，请确保已连接内核调试器，并且系统已使用 /DEBug 开关启动。如果发生异常代码0x80000002，陷阱帧将提供其他信息。有关 WinDbg 和 ！analyze 的详细信息，请参阅：使用 WinDbg 分析故障转储文件使用 WinDbg 分析内核模式转储文件使用 ！analyze 扩展 和 ！analyze如果你没有能力使用 Windows 调试器来解决此问题，则应使用一些基本的故障排除技术：在系统登录事件查看器中查看更多错误消息，这些错误消息可能有助于识别导致0x7E:SYSTEM_THREAD_EXCEPTION_NOT_HANDLED\n\n问题原因：\n\n第三方软件冲突\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n0x7E:SYSTEM_THREAD_EXCEPTION_NOT_HANDLED\n错误分析：系统进程产生错误， 但Windows错误处理器无法捕获。 其产生原因很多， 包括：硬件兼容性、有问题的驱动程序或系统服务、 或者是某些软件。", "0x80": "BUG代码 0x80：NMI_HARDWARE_FAILURE\n项目 • 2023/06/20NMI_HARDWARE_FAILURE Bug 检查 的值为 0x00000080。 此 Bug 检查表示发生了硬件故障。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NMI_HARDWARE_FAILURE参数无原因各种硬件故障可能会导致检查NMI_HARDWARE_FAILURE Bug。 确切原因难以确定。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 删除最近安装的任何硬件或驱动程序。 确保所有内存模块的类型相同。", "0x81": "BUG代码 0x81：SPIN_LOCK_INIT_FAILURE\n项目 • 2023/06/20SPIN_LOCK_INIT_FAILURE Bug 检查 的值为 0x00000081。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x82": "BUG代码 0x82：DFS_FILE_SYSTEM\n项目 • 2023/06/20DFS_FILE_SYSTEM Bug 检查 的值为 0x00000082。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x85": "BUG代码 0x85：SETUP_FAILURE\n项目 • 2023/06/20SETUP_FAILURE Bug 检查 的值为 0x00000085。 此 Bug 检查指示在安装过程中发生了严重错误。参数 1 指示冲突的类型。 不使用参数 4。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 原因0x0 0 0 OEM HAL 字体不是有效的 .fon 格式文件，因此安装程序无法显示文本。此原因表示启动软盘或 CD 上的 Vgaxxx.fon 已损坏。0x1 精确视频初始化失败：0：NtCreateFile of \\device\\video01：IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES2： IOCTL_VIDEO_QUERY_AVAIL_MODES3： 不支持所需的视频模式。 此值指示内部安装错误。4： IOCTL_VIDEO_SET_CURRENT_MODE(无法设置视频模式)5： IOCTL_VIDEO_MAP_VIDEO_MEMORY6： IOCTL_VIDEO_LOAD_AND_SET_FONTNT API 调用的状态代码（如果适用）视频初始化失败。此故障可能表示包含Vga.sys (的磁盘或其他适合计算机) 的视频驱动程序已损坏，或者计算机具有MicrosoftWindows 操作系统无法与之通信的视频硬件。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SETUP_FAILURE参数参数 1 参数 2 参数 3 原因0x2 0 0 内存不足。0x3 精确键盘初始化失败：0：NtCreateFile 的\\device\\KeyboardClass0 失败。 (安装程序找不到连接到计算机的键盘。)1： 无法加载键盘布局 DLL。 (安装程序无法加载键盘布局文件。此故障表示 CD 或软盘缺少文件，例如适用于美国版本的Kbdus.dll 或本地化 releases 的其他布局DLL。)0 键盘初始化失败。此故障可能表示包含键盘驱动程序(I8042prt.sys 或Kbdclass.sys) 的磁盘已损坏，或者计算机具有Windows 无法与之通信的键盘硬件。 此故障可能还意味着无法加载键盘布局 DLL。0x4 0 0 安装程序无法解析从其启动安装程序的设备的 ARC 设备路径名称。此错误是内部安装错误。0x5 预留 预留 分区健全性检查失败。此错误表示磁盘驱动程序中存在Bug。", "0x8B": "BUG代码 0x8B：MBR_CHECKSUM_MISMATCH\n项目 • 2023/06/20MBR_CHECKSUM_MISMATCH Bug 检查的值为 0x0000008B。 此 Bug 检查指示 MBR 校验和中发生了不匹配。参数 描述1 MBR 中的磁盘签名2 OS 加载程序计算的 MBR 校验和3 系统计算的 MBR 校验和4 保留当 Microsoft Windows 操作系统计算的 MBR 校验和与加载程序传入的校验和不匹配时，启动过程中会出现MBR_CHECKSUM_MISMATCH Bug 检查。此错误通常表示病毒。病毒有多种形式，并非所有病毒都可以检测到。 通常，较新的病毒通常只能由最近升级的病毒扫描程序检测到。 应使用包含病毒扫描程序的写保护磁盘启动，并尝试清除感染。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MBR_CHECKSUM_MISMATCH参数原因解决方法", "0x8E": "BUG代码 0x8E：KERNEL_MODE_EXCEPTION_NOT_HANDLED\n项目 • 2023/06/20KERNEL_MODE_EXCEPTION_NOT_HANDLED Bug 检查 的值为 0x0000008E。 此 Bug 检查指示内核模式应用程序生成了错误处理程序未捕获的异常。参数 描述1 未处理的异常代码2 发生异常的地址3 陷阱框架4 保留KERNEL_MODE_EXCEPTION_NOT_HANDLED Bug 检查是一个非常常见的 Bug 检查。 若要对其进行解释，必须确定生成的具体异常。常见的异常代码包括以下内容：0x80000002：STATUS_DATATYPE_MISALIGNMENT指示遇到未对齐的数据引用。0x80000003：STATUS_BREAKPOINT 指示在未将内核调试器附加到系统时遇到断点或 ASSERT。0xC0000005：STATUS_ACCESS_VIOLATION指示发生了内存访问冲突。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_MODE_EXCEPTION_NOT_HANDLED参数原因有关异常代码的完整列表，请参阅位于 Microsoft Windows 驱动程序工具包的 inc 目录中的 Ntstatus.h 文件 (WDK) 。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 如果没有能力调试此问题，则应使用一些基本的故障排除技术：确保你有足够的磁盘空间。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。尝试更改视频适配器。咨询任何 BIOS 更新的硬件供应商。禁用 BIOS 内存选项，例如缓存或隐藏。如果计划调试此问题，可能会发现很难获取堆栈跟踪。 参数 2 (异常地址) 应标识导致此问题的驱动程序或函数。如果发生异常代码0x80000003，则命中了硬编码断点或断言，但计算机是使用/NODEBug 开关启动的。 此问题应很少发生。 如果重复出现，请确保已连接内核调试器，并且计算机已使用 /DEBug 开关启动。如果发生异常代码0x80000002，陷阱帧将提供其他信息。如果不知道异常的具体原因，请考虑以下各项：硬件不兼容。 确保安装的任何新硬件都与已安装的 Windows 版本兼容。设备驱动程序或系统服务有故障。 错误的设备驱动程序或系统服务可能导致此错误。 硬件问题（例如 BIOS 不兼容、内存冲突和 IRQ 冲突）也可能会生成此错误。如果 Bug 检查消息按名称列出驱动程序，请禁用或删除该驱动程序。 此外，禁用或删除最近添加的任何驱动程序或服务。 如果在启动序列期间发生错误，并且系统分区使用NTFS 文件系统进行格式化，则可能能够使用安全模式重命名或删除错误的驱动程序。 如果在安全模式下将驱动程序用作系统启动过程的一部分，则必须使用恢复控制台启动计算机才能访问该文件。如果问题与 Win32k.sys 相关联，则错误的来源可能是第三方远程控制程序。 如果安装了此类软件，则可以通过使用恢复控制台启动系统，然后删除有问题的系统服务文件来删除该服务。在系统登录事件查看器中查看其他错误消息，这些错误消息可能有助于识别导致 Bug 检查 0x8E的设备或驱动程序。 可以禁用 BIOS 的内存缓存以尝试解决此错误。 还应运行系统制造商提供的硬件诊断，尤其是内存扫描程序。 有关这些过程的详细信息，请参阅计算机所有者手册。生成此消息的错误可能发生在 Windows 安装程序期间第一次重启之后或安装程序完成后。 此错误的一个可能原因是缺少用于安装和系统 BIOS 不兼容的磁盘空间。 对于Windows 安装期间与磁盘空间不足相关的问题，请减少目标硬盘驱动器上的文件数。 检查并删除任何不需要的临时文件、Internet 缓存文件、应用程序备份文件和包含磁盘扫描中保存的文件片段的 .chk 文件。 还可以使用具有更多可用空间的另一个硬盘驱动器进行安装。", "0x8F": "BUG代码 0x8F：PP0_INITIALIZATION_FAILED\n项目 • 2023/06/20PP0_INITIALIZATION_FAILED Bug 检查 的值为 0x0000008F。 此 Bug 检查指示无法初始化即插即用 (PnP) 管理器。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PP0_INITIALIZATION_FAILED参数无原因内核模式 PnP 管理器的阶段 0 初始化期间出错。", "0x90": "BUG代码 0x90：PP1_INITIALIZATION_FAILED\n项目 • 2023/06/20PP1_INITIALIZATION_FAILED Bug 检查 的值为 0x00000090。 此 Bug 检查 指示无法初始化 即插即用 (PnP) 管理器。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PP1_INITIALIZATION_FAILED参数无原因在初始化内核模式 PnP 管理器的第 1 阶段时出错。阶段 1 是完成大部分初始化的地方，包括设置注册表文件和其他环境设置，供驱动程序在后续 I/O 初始化期间调用。", "0x92": "BUG代码 0x92：UP_DRIVER_ON_MP_SYSTEM\n项目 • 2023/06/20UP_DRIVER_ON_MP_SYSTEM Bug 检查 的值为 0x00000092。 此 Bug 检查指示多处理器系统上加载了仅限单处理器的驱动程序。参数 描述1 驱动程序的基址2 保留3 保留4 保留已加载编译为仅在单处理器计算机上工作的驱动程序，但 Microsoft Windows 操作系统在具有多个活动处理器的多处理器系统上运行。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UP_DRIVER_ON_MP_SYSTEM参数原因解决方法", "0x93": "BUG代码 0x93：INVALID_KERNEL_HANDLE\n项目 • 2023/06/20INVALID_KERNEL_HANDLE Bug 检查 的值为 0x00000093。 此 Bug 检查指示无效或受保护的句柄已传递到 NtClose。参数 1 参数2参数3参数4错误消息的原因使用 NtClose 调用的句柄0 0 0 受保护的句柄已关闭。使用 NtClose 调用的句柄1 0 0 已关闭或引用无效句柄。引用的句柄 句柄表0 1 引用无效的内核句柄并启用错误的句柄检测时发生错误。INVALID_KERNEL_HANDLE Bug 检查指示某些内核代码 (，例如服务器、重定向程序或其他驱动程序) 尝试关闭无效句柄或受保护的句柄。如果参数 4 的值为 1，则表示引用无效的内核句柄时发生了错误，并且启用了错误的句柄检测。如果内核代码尝试关闭或引用不是有效句柄的句柄，则会出现此消息。 除非启用了错误句柄检测，否则只有传递给 NtClose 的无效或受保护的句柄才会造成此 Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_KERNEL_HANDLE参数原因", "0x94": "BUG代码 0x94：KERNEL_STACK_LOCKED_AT_EXIT\n项目 • 2023/06/20KERNEL_STACK_LOCKED_AT_EXIT Bug 检查的值为 0x00000094。 此 Bug 检查指示线程在内核堆栈标记为不可交换时退出） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_STACK_LOCKED_AT_EXIT参数无", "0x96": "BUG代码 0x96：INVALID_WORK_QUEUE_ITEM\n项目 • 2023/06/20INVALID_WORK_QUEUE_ITEM Bug 检查 的值为 0x00000096。 此 Bug 检查指示已删除包含 NULL 指针的队列条目。参数 描述1 其 闪烁 或 闪烁 字段为 NULL 的队列条目的地址。2 正在引用的队列的地址。 通常，此队列是ExWorkerQueue。3 ExWorkerQueue 数组的基址。 (此地址可帮助你确定有问题的队列是否确实是ExWorkerQueue。如果队列是ExWorkerQueue，则此参数的偏移量将隔离queue.)4 假设队列是 ExWorkerQueue，则此值是工作项有效时将调用的工作例程的地址。 (可以使用此地址隔离误用工作队列的驱动程序。)当 KeRemoveQueue 删除其闪烁或闪烁字段为 NULL 的队列条目时，会发生INVALID_WORK_QUEUE_ITEM Bug 检查。任何队列误用都可能导致此错误。 但此错误的发生通常是因为工作线程工作项被滥用。队列上的条目只能插入列表一次。 从队列中删除项时，其 flink 字段设置为 NULL。 然后，当第二次删除此项时，此 Bug 检查发生。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_WORK_QUEUE_ITEM参数原因在大多数情况下，引用的队列是 ExWorkerQueue (执行辅助角色队列) 。 为了帮助识别导致错误的驱动程序，参数 4 显示工作器例程的地址，如果此工作项有效，则会调用该例程。 但是，如果引用的队列不是 ExWorkerQueue，则此参数没有用。", "0x97": "BUG代码 0x97：BOUND_IMAGE_UNSUPPORTED\n项目 • 2023/06/20BOUND_IMAGE_UNSUPPORTED Bug 检查 的值为 0x00000097。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x98": "BUG代码 0x98：END_OF_NT_EVALUATION_PERIOD\n项目 • 2023/06/20END_OF_NT_EVALUATION_PERIOD Bug 检查 的值为 0x00000098。 此 Bug 检查指示Microsoft Windows 操作系统的试用期已结束。参数 描述1 产品到期日期的低序 32 位2 产品到期日期的高阶 32 位3 保留4 保留Windows 操作系统的安装是具有到期日期的评估单元。 试用期已结束。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。END_OF_NT_EVALUATION_PERIOD参数原因", "0x99": "BUG代码 0x99：INVALID_REGION_OR_SEGMENT\n项目 • 2023/06/20INVALID_REGION_OR_SEGMENT Bug 检查 的值为 0x00000099。 此 Bug 检查指示ExInitializeRegion 或 ExInterlockedExtendRegion 是使用一组无效的参数调用的。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_REGION_OR_SEGMENT参数无", "0x9A": "BUG代码 0x9A：SYSTEM_LICENSE_VIOLATION\n项目 • 2023/06/15SYSTEM_LICENSE_VIOLATION Bug 检查 的值为 0x0000009A。 此 Bug 检查指示已违反软件许可协议。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数 4 原因0x00 0： 产品应为WinNT1： 产品应为LanmanNT 或ServerNT部分序列号 产品选项中产品类型的前两个字符已尝试进行脱机产品类型更改。0x01 从源 1 注册的评估时间部分序列号 从备用源注册的评估时间已尝试对MicrosoftWindows 评估单元时间段进行脱机更改。0x02 与打开失败关联的状态代码0 0 无法打开安装密钥。0x03 与密钥查找失败关联的状态代码0 0 安装键中的SetupType 或SetupInProgress值缺失，因此无法检测到安装模式。0x04 与密钥查找失败关联的状态代码0 0 缺少安装密钥中的 SystemPrefix值。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。SYSTEM_LICENSE_VIOLATION参数参数 1 参数 2 参数 3 参数 4 原因0x05 (请参阅安装代码) 在许可的处理器中发现无效值正式许可的处理器数已尝试对许可处理器数进行脱机更改。0x06 与打开失败关联的状态代码0 0 无法打开ProductOptions密钥。0x07 与读取失败关联的状态代码0 0 无法读取ProductType值。0x08 与更改通知失败关联的状态代码0 0 更改ProductOptions上的通知失败。0x09 与更改通知失败关联的状态代码0 0 更改SystemPrefix 上的通知失败。0x0A 0 0 0 NTW 系统已转换为 NTS 系统。0x0B 与更改失败关联的状态代码0 0 安装密钥的引用失败。0x0C 与更改失败关联的状态代码0 0 产品选项密钥的引用失败。0x0D 与失败关联的状态代码0 0 尝试在工作线程中打开ProductOptions失败。0x0F 与失败关联的状态代码0 0 尝试打开安装密钥失败。0x10 与失败关联的状态代码0： 设置值失败1： 更改通知失败0 安装密钥工作线程中发生故障。0x11 与失败关联的状态代码0： 设置值失败1： 更改通知失败0 产品选项密钥工作线程中发生故障。0x12 与失败关联的状态代码0 0 无法打开套件的LicenseInfoSuites密钥。参数 1 参数 2 参数 3 参数 4 原因0x13 与失败关联的状态代码0 0 无法查询套件的LicenseInfoSuites密钥。0x14 内存分配的大小 0 0 无法分配内存。0x15 与失败关联的状态代码保留 0 无法重置套件密钥的ConcurrentLimit值。0x16 与失败关联的状态代码0 0 无法打开套件产品的许可证密钥。0x17 与失败关联的状态代码0 0 无法重置套件产品的ConcurrentLimit值。0x18 与打开失败关联的状态代码保留 0 无法启动LicenseInfoSuites的更改通知。0x19 0 0 0 套件在必须是PDC 的系统上运行。0x1A 与失败关联的状态代码0 0 枚举套件时发生故障。0x1B 0 0 0 已尝试更改策略缓存。Microsoft Windows 操作系统检测到违反软件许可协议。用户可能已尝试更改脱机系统的产品类型或更改 Windows 评估单元的试用期。 有关特定冲突的详细信息，请参阅参数列表。原因", "0x9B": "BUG代码 0x9B：UDFS_FILE_SYSTEM\n项目 • 2023/06/20UDFS_FILE_SYSTEM Bug 检查 的值为 0x0000009B。 此 Bug 检查指示 UDF 文件系统中出现了问题。参数 描述1 源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低16 位标识文件中发生 Bug 检查的源行。2 如果 UdfExceptionFilter 位于堆栈上，则此参数指定异常记录的地址。3 如果 UdfExceptionFilter 位于堆栈中，则此参数指定上下文记录的地址。4 保留。UDFS_FILE_SYSTEM Bug 检查可能会导致磁盘损坏。 文件系统损坏或磁盘上) 扇区 (坏块可能会引发此错误。 损坏的 SCSI 和 IDE 驱动程序也可能对系统读取和写入磁盘的能力产生负面影响，并导致错误。如果非分页池内存已满，则检查也可能发生此 Bug。 如果非分页池内存已满，则此错误可能会停止系统。 但是，在索引过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要调试此问题，请执行以下操作： 将 .cxr (显示上下文记录) 命令与参数 3 配合使用，然后使用 kb (显示堆栈回溯) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UDFS_FILE_SYSTEM参数原因解决方法若要解决磁盘损坏问题，请执行以下操作：检查事件查看器是否有来自 SCSI 和 FASTFAT(系统日志) 或 Autochk (应用程序日志) 的错误消息，这些错误消息可能有助于识别导致错误的设备或驱动程序。 禁用持续监视系统的任何病毒扫描程序、备份应用程序或磁盘碎片整理程序工具。 还应运行系统制造商提供的硬件诊断。 有关这些过程的详细信息，请参阅计算机所有者手册。 运行 Chkdsk /f /r 以检测和解决任何文件系统结构损坏。 在系统分区上开始磁盘扫描之前，必须重启系统。若要解决非分页池内存耗尽问题，请执行以下操作： 向计算机添加新的物理内存。 此内存会增加内核可用的非分页池内存的数量。", "0x9C": "BUG代码 0x9C：MACHINE_CHECK_EXCEPTION\n项目 • 2023/06/20MACHINE_CHECK_EXCEPTION Bug 检查 的值为 0x0000009C。 此 Bug 检查指示发生了致命计算机检查异常。消息中列出的四个参数具有不同的含义，具体取决于处理器类型。如果处理器基于较旧的基于 x86 的体系结构，并且具有计算机检查异常 (MCE) 功能，但没有计算机检查体系结构 (MCA) 功能 (例如 Intel Pentium 处理器) ，则参数具有以下含义。参数 描述1 低 32 位P5_MC_TYPE计算机服务报告 (MSR)2 MCA_EXCEPTION 结构的地址3 P5_MC_ADDR MSR 的高 32 位4 P5_MC_ADDR MSR 的低 32 位如果处理器基于较新的基于 x86 的体系结构，并且具有 MCA 功能和 MCE 功能 (，例如，任何系列 6 或更高版本的 Intel 处理器（如 Pentium Pro、Pentium IV 或 Xeon) ），或者如果处理器是基于 x64 的处理器，则参数具有以下含义。参数 描述1 银行编号2 MCA_EXCEPTION 结构的地址3 具有错误的 MCA 库的高 32 位MCi_STATUSMSR） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MACHINE_CHECK_EXCEPTION参数参数 描述4 出现错误的 MCA 库的低 32 位MCi_STATUSMSR此 Bug 检查仅在以下情况下发生。WHEA 未完全初始化。会合的所有处理器在其寄存器中没有错误。在其他情况下，此 Bug 检查已替换为 Bug 检查0x124：Windows Vista 及更高版本的操作系统中的WHEA_UNCORRECTABLE_ERROR。有关计算机检查体系结构 (MCA) 的详细信息，请参阅 Intel 或 AMD 网站。备注", "0x9E": "BUG代码 0x9E：USER_MODE_HEALTH_MONITOR\n项目 • 2023/03/08USER_MODE_HEALTH_MONITOR Bug 检查的值为 0x0000009E。 此 Bug 检查指示一个或多个关键用户模式组件无法满足运行状况检查。参数说明1 在配置的超时中未能满足运行状况检查的进程2 运行状况监视超时（以秒为单位）3 监视程序源。 与进程地址结合使用有助于确定创建此监视程序子组件的内容。 其值如下所列。4 保留0 : WatchdogSourceDefault Source was not specified1 : WatchdogSourceRhsCleanup Monitors that RHS (Resource Hosting Subsystem) process goes away when terminating on graceful exit2 : WatchdogSourceRhsResourceDeadlockBugcheckNow RHS was asked to immediately Bugcheck machine on resource deadlock3 : WatchdogSourceRhsExceptionFromResource Resource has leaked unhandled exception from an entry point, RHS is terminating and this watchdog monitors that process will go away4 : WatchdogSourceRhsUnhandledException Unhandled exception in RHS. RHS is terminating and this watchdog monitors that） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。USER_MODE_HEALTH_MONITOR 参数VALUES process will go away5 : WatchdogSourceRhsResourceDeadlock Monitors that RHS process goes away when terminating on resource deadlock6 : WatchdogSourceRhsResourceTypeDeadlock Monitors that RHS process goes away when terminating on resource type deadlock7 : WatchdogSourceClussvcUnhandledException Unhandled exception in clussvc. clussvc is terminating and this watchdog monitors that process will go away8 : WatchdogSourceClussvcBugcheckMessageRecieved Another cluster node has sent message asking to Bugcheck this node.9 : WatchdogSourceClussvcWatchdogBugcheck User mode watchdog has expired and created netft watchdog to Bugchecked the node. 0xA : WatchdogSourceClussvcIsAlive Cluster service sends heartbeat to netft every 500 millseconds. By default, netft expects at least 1 heartbeat per second. If this watchdog was triggered that means clussvc is not getting CPU to send heartbeats. 0x65 : WatchdogSourceRhsResourceDeadlockPhysicalDisk A subclass of WatchdogSourceRhsResourceDeadlock. 0x66 : WatchdogSourceRhsResourceDeadlockStoragePool A subclass of WatchdogSourceRhsResourceDeadlock. 0x67 : WatchdogSourceRhsResourceDeadlockFileServer A subclass of WatchdogSourceRhsResourceDeadlock. 0x68 : WatchdogSourceRhsResourceDeadlockSODAFileServer A subclass of WatchdogSourceRhsResourceDeadlock. 0x69 : WatchdogSourceRhsResourceDeadlockStorageReplica A subclass of WatchdogSourceRhsResourceDeadlock. 0x6A : WatchdogSourceRhsResourceDeadlockStorageQOS A subclass of WatchdogSourceRhsResourceDeadlock. 0x6B : WatchdogSourceRhsResourceDeadlockStorageNFSV2 A subclass of WatchdogSourceRhsResourceDeadlock. 0xC9 : WatchdogSourceRhsResourceTypeDeadlockPhysicalDisk A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCA : WatchdogSourceRhsResourceTypeDeadlockStoragePool A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCB : WatchdogSourceRhsResourceTypeDeadlockFileServer A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCC : WatchdogSourceRhsResourceTypeDeadlockSODAFileServer A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCD : WatchdogSourceRhsResourceTypeDeadlockStorageReplica A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCE : WatchdogSourceRhsResourceTypeDeadlockStorageQOS A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCF : WatchdogSourceRhsResourceTypeDeadlockStorageNFSV2 A subclass of WatchdogSourceRhsResourceTypeDeadlock.原因硬件机制（如监视程序计时器）可以检测基本内核服务未执行。 但是，资源饥饿问题 (包括内存泄漏、锁争用和计划优先级配置错误，) 可以阻止关键用户模式组件，而无需阻止延迟过程调用 (DPC) 或清空非分页池。内核组件可以通过定期监视关键应用程序，将监视程序计时器功能扩展到用户模式。 此Bug 检查指示用户模式运行状况检查以阻止正常关闭的方式失败。 此 Bug 通过重启或启用应用程序故障转移到其他服务器来检查还原关键服务。与所有 Bug 检查一样，使用系统事件日志查找在停止代码之前及时发生的事件。 应检查日志中立即执行 Bug 检查的事件，以获取有关可能原因的信息。另请参阅使用 Windows 错误报告排查故障转移群集问题故障转移群集系统日志事件Bug 检查0x1C9 USER_MODE_HEALTH_MONITOR_LIVEDUMPBug 检查代码参考", "0x9F": "BUG代码 0x9F：DRIVER_POWER_STATE_FAILURE\n项目 • 2023/06/20DRIVER_POWER_STATE_FAILURE Bug 检查 的值为 0x0000009F。 此 Bug 检查指示驱动程序处于不一致或无效的电源状态。参数 1 指示冲突的类型。参数1参数 2 参数 3 参数 4 原因0x1 设备对象 预留 预留 正在释放的设备对象仍具有尚未完成的未完成的电源请求。0x2 目标设备的设备对象（如果可用）设备对象 驱动程序对象（如果可用）设备对象完成了系统电源状态请求的 I/O 请求数据包 (IRP) ，但它未调用PoStartNextPowerIrp。0x3 物理设备对象(堆栈的 PDO)nt！_TRIAGE_9F_POWER.被阻止的 IRP 设备对象阻止 IRP 的时间过长。0x4 超时值（以秒为单位）。当前持有即插即用(PnP) 锁的线程。Nt！TRIAGE_9F_PNP。电源状态转换超时，等待与 PnP 子系统同步。0x5 堆栈的物理设备对象POP_FX_DEVICE 对象已保留 - 0 设备未能在所需时间内完成定向电源转换。0x6 POP_FX_DEVICE对象指示这是定向关闭电源 (1) 还是 (0) 完成。已保留 - 0 设备未成功完成其定向电源转换回调。0x500 保留 目标设备的设备对象（如果可用）设备对象 设备对象已完成系统电源状态请求的 IRP，但它未调用 PoStartNextPowerIrp。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_POWER_STATE_FAILURE参数原因有关可能原因的说明，请参阅参数部分中每个代码的说明。 常见原因包括：设备对象释放，但未完成的电源请求未完成电源状态转换超时阻止 IRP 的设备对象已完成 IRP，但未调用 PoStartNextPowerIrp解决方法若要确定特定原因并创建代码修补程序，需要具有编程经验和对故障模块源代码的访问权限。当参数 1 等于 0x3 时调试0x9F:DRIVER_POWER_STATE_FAILURE\n\n问题原因：\n\n第三方软件冲突\n\n显卡驱动\n\n解决方案：\n\n显卡驱动造成的蓝屏概率比较低，可以尝试更新windows补丁和显卡驱动\n\n卸载第三方杀毒软件和电脑管家软件。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xA0": "BUG代码 0xA0：INTERNAL_POWER_ERROR\n项目 • 2023/06/20INTERNAL_POWER_ERROR Bug 检查 的值为 0x000000A0。 此 Bug 检查指示电源策略管理器遇到严重错误。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数 4 原因0x1 1： 设备已超出其最大引用计数数。2、3 或 4： 太多浪涌电源 IRP 已排队。5： 电源 IRP 已发送到被动级别设备对象。6： 系统未能分配必要的电源 IRP。如果参数 2 的值为 1，则允许的最大引用数。如果参数 2 的值为 2、3 或 4，则允许的最大挂起 IRP 数。如果参数 2 的值为 6，则为目标设备对象。如果参数 2 的值为 6，则指示这是系统 (0x0) 还是设备 (0x1)电源 IRP。在处理电源 I/O 请求数据包 (IRP) 期间出错。0x2 预留 预留 预留 尝试处理电源事件时发生内部故障。 有关详细信息，请参阅在参数 1等于 0x2 时调试 Bug 检查 0xA0。0x3 预期的校验和 实际校验和 失败的行号 休眠上下文页的校验和与其预期的校验和不匹配。0x4 预期的校验和 实际校验和 失败的行号 即将写入休眠文件的页的校验和与其预期的校验和不匹配。0x5 预留 预留 预留 未知的关闭代码已发送到系统关闭处理程序。0x7 预留 预留 预留 发生了未经处理的异常。 有关详细信息，请参阅在参数 1 等于 0x7时调试0xA0:INTERNAL_POWER_ERROR\n\n问题原因：\n\nWindows系统故障或第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xA1": "BUG代码 0xA1：PCI_BUS_DRIVER_INTERNAL\n项目 • 2023/06/20PCI_BUS_DRIVER_INTERNAL Bug 检查 的值为 0x000000A1。 此 Bug 检查指示 PCI 总线驱动程序在其内部结构中检测到不一致问题，并且无法继续。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PCI_BUS_DRIVER_INTERNAL参数无另请参阅Bug 检查代码参考", "0xA2": "BUG代码 0xA2：MEMORY_IMAGE_CORRUPT\n项目 • 2023/06/20MEMORY_IMAGE_CORRUPT Bug 检查 的值为 0x000000A2。 此 Bug 检查指示已在内存中可执行文件的映像中检测到损坏。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数 4 原因0x02 如果参数 3 为零： 表页中失败的页码如果参数 3 为非零： 包含失败页运行索引的页码零，或无法与运行匹配的索引0 表页检查失败。0x03 范围的起始物理页码范围) 页 (长度 包含此运行的表页的页码列出的内存范围的校验和不正确。内存范围的循环冗余检查 (CRC) 检查失败。在系统唤醒操作中，可能会检查内存的各个区域以防止内存故障。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MEMORY_IMAGE_CORRUPT参数原因另请参阅", "0xA3": "BUG代码 0xA3：ACPI_DRIVER_INTERNAL\n项目 • 2023/06/20ACPI_DRIVER_INTERNAL Bug 检查 的值为 0x000000A3。 此 Bug 检查指示 ACPI 驱动程序检测到内部不一致。参数 描述1 保留2 保留3 保留4 保留ACPI 驱动程序中的不一致非常严重，因此继续运行会导致严重问题。此问题的一个可能根源是 BIOS 错误。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ACPI_DRIVER_INTERNAL参数原因另请参阅", "0xA4": "BUG代码 0xA4：CNSS_FILE_SYSTEM_FILTER\n项目 • 2023/06/20CNSS_FILE_SYSTEM_FILTER Bug 检查 值为 0x000000A4。 此 Bug 检查表示 CNSS 文件系统筛选器中出现了问题。参数 描述1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四个十六进制数字，) 按标识符号标识源文件。 低 16 位标识文件中发生 Bug 检查的源行。2 保留3 保留4 保留CNSS_FILE_SYSTEM_FILTER Bug 检查可能发生，因为非分页池内存已满。 如果非分页池内存已完全满，则此错误可能会停止系统。 但是，在索引过程中，如果可用的非分页池内存量非常低，则另一个需要非分页池内存的内核模式驱动程序也可能触发此错误。若要解决非分页池内存耗尽问题，请执行以下操作： 向计算机添加新的物理内存。 此内存会递增内核可用的非分页池内存的数量。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CNSS_FILE_SYSTEM_FILTER参数原因解决方法另请参阅Bug 检查代码参考", "0xA5": "BUG代码 0xA5：ACPI_BIOS_ERROR\n项目 • 2023/06/20检查ACPI_BIOS_ERROR Bug 的值为 0x000000A5。 此 Bug 检查表示计算机) BIOS (ACPI(高级配置和电源接口不完全符合 ACPI 规范。参数 1 指示不兼容的类型。 其他参数的含义取决于参数 1 的值。如果 BIOS 不兼容与即插即用 (PnP) 或电源管理相关，则使用以下参数。参数 1 参数 2 参数 3 参数 4 原因0x01 ACPI 的deviceExtensionACPI 的ResourceList0： 找不到资源列表1： 列表中未找到IRQ 资源ACPI 在 ACPI 启动时交给它的资源中找不到系统控制中断 (SCI) 向量。0x02 (请参阅本页后面的表)0x03 运行的 ACPI 对象 解释器的返回值 控件方法的名称(ULONG 格式)ACPI 在创建设备扩展以表示 ACPI命名空间时尝试运行控制方法，但此控制方法失败。0x04 _PRW属于的ACPI 扩展指向 方法的指针 返回的 DataType(请参阅 Amli.h)ACPI 评估了_PRW，并期望找到一个整数作为包元素。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ACPI_BIOS_ERROR参数参数 1 参数 2 参数 3 参数 4 原因0x05 _PRW属于的ACPI 扩展Aointer to the_PRW_PRW中的元素数 ACPI 评估了_PRW，但返回的包未能包含至少两个元素。 ACPI规范要求_PRW中始终存在两个元素。0x06 _PRx属于的 ACPI扩展指向_PRx的指针 指向要查找的对象名称的指针ACPI 尝试查找命名对象，但找不到该对象。0x07 方法所属的 ACPI扩展指向 方法的指针 返回的 DataType(请参阅 Amli.h)ACPI 评估了一个方法，并预期会收到一个缓冲区作为回报。 但是， 方法返回了一些其他数据类型。0x08 方法所属的 ACPI扩展指向 方法的指针 返回的 DataType(请参阅 Amli.h)ACPI 计算了一个方法，并预期会收到一个整数作为回报。 但是，方法返回了一些其他数据类型。0x09 方法所属的 ACPI扩展指向 方法的指针 返回的 DataType(请参阅 Amli.h)ACPI 评估了一个方法，并预期会收到一个包作为回报。 但是， 方法返回了一些其他数据类型。0x0A 方法所属的 ACPI扩展指向 方法的指针 返回的 DataType(请参阅 Amli.h)ACPI 评估了一个方法，并预期会收到一个字符串作为回报。 但是， 方法返回了一些其他数据类型。0x0B _EJD属于的 ACPI扩展解释器返回的状态ACPI 尝试查找的对象的名称ACPI 找不到_EJD字符串引用的对象。参数 1 参数 2 参数 3 参数 4 原因0x0C ACPI 找到的扩展坞设备的 ACPI 扩展指向 _EJD 方法的指针0： BIOS 未声明系统已停靠1： 扩展坞设备的重复设备扩展ACPI 为扩展坞支持提供错误或信息不足。0x0D ACPI 需要对象的ACPI 扩展(ULONG) ACPI 查找的方法的名称0： 基本案例1： 冲突ACPI 在命名空间中找不到所需的方法或对象 如果不存在_HID或_ADR，则使用Bug 检查代码。0x0E ACPI 需要对象的NSPowerResource(ULONG) ACPI 查找的方法的名称0：基本案例 ACPI 在“device”)以外的电源资源(或实体的命名空间中找不到所需的方法或对象。如果电源资源没有_ON、_OFF或_STA，则使用此Bug 检查代码。0x0F ACPI 正在分析的当前缓冲区缓冲区的 标记 缓冲区的指定长度ACPI 无法分析资源描述符。0x10 (请参阅本页后面的表)0x11 (请参阅本页后面的表)0x14 ACPI 正在分析的当前缓冲区缓冲区的 标记 指向包含缓冲区ULONGLONG 长度的变量的指针ACPI 无法分析资源描述符。 长度超过MAXULONG。0x15 ACPI 计算机语言(AML) 上下文1： 无法加载表2： 找不到参数路径字符串对象3： 未能将参数数据插入ParameterPathString 对象4： 系统内存不足NT 状态代码 ACPI 在尝试加载表时出现严重错误。参数 1 参数 2 参数 3 参数 4 原因0x16 指向父 NSOBJ 的指针指向非法子 ACPI命名空间对象的指针保留 ACPI 在处理xSDT 时出现致命错误。 对象被声明为父级（不能有子级）的子级。如果发生中断路由失败或不兼容性，则使用以下参数。参数 1 参数 2 参数 3 参数 4 原因0x2001 InterruptModel(整数)解释器的返回值 指向 PIC 控件方法的指针ACPI 尝试评估PIC 控制方法，但失败。0x10001 指向设备对象的指针指向设备对象的父级的指针指向_PRT 对象的指针(请参阅以下注释部分)ACPI 尝试执行中断路由，但失败。0x10002 指向设备对象的指针指向 ACPI 正在查找但找不到的字符串名称的指针指向_PRT 对象的指针(请参阅以下注释部分)ACPI 找不到_PRT中引用的链接节点。0x10003 指向设备对象的指针设备 ID 或函数编号。此 DWORD 编码如下：位 5：0 是PCI 设备编号，位8：6 是 PCI 函数编号指向_PRT 对象的指针(请参阅以下注释部分)ACPI 在设备的_PRT包中找不到映射。0x10005 指向_PRT 对象的指针(请参阅以下注释部分)指向当前_PRT元素的指针。(此指针是_PRT.)设备 ID 或函数编号。此 DWORD 编码如下：位 15：0是 PCI 函数编号，位 31：16 是PCI 设备编号ACPI 在_PRT中发现了一个条目，该条目的函数 ID并非全部为 F。(_PRT条目的泛型格式是指定了设备编号，但函数编号不是。)参数 1 参数 2 参数 3 参数 4 原因0x10006 指向链接节点的指针。(此设备缺少 _DIS方法。)0 0 ACPI 找到了链接节点，但它无法禁用该节点。必须禁用 (链接节点才能允许重新编程.)0x10007 找不到的向量 0 0 _PRT包含对 I/OAPIC 条目的MAPIC 表中未描述的向量的引用。0x10008 无效的中断级别。0 0 ACPI SCI 中断级别无效。0x10009 0 0 0 无法找到固定的ACPI 说明表(FADT) 。0x1000A 0 0 0 无法找到 (RSDP)或扩展系统说明表 (XSDT) 的根系统说明指针0x1000B ACPI 表签名 指向 ACPI 表的指针0 ACPI 表的长度与表修订不一致。0x1000C 修订版 ID 功能索引 0 中断_DSM方法返回格式不正确的数据。0x1000D 设备的 ACPI 扩展 值 0 ：_PRW指定时没有支持唤醒的中断，并且至少有一个 GPIO 中断值1：由于存在支持唤醒的中断，_PRW应将GpeInfo 值指定为0xffffffff0 设备同时使用GPE 和 GPIO 中断，这不受支持。0x1000E 验证函数返回的Status。指向 ACPI 命名空间路径UNICODE_STRING的指针。指向与 SDEV 比较的资源列表的指针。安全设备的 SDEV资源与其对应的_CRS或_PRS项不匹配。如果发生了其他故障或不兼容性，则使用以下参数。参数 1 参数 2 参数 3 参数 4 原因0x20000 固定表中的 I/O端口0 0 固定 ACPI 说明表中的PM_TMR_BLK条目不指向正常工作的 ACPI 计时器块。此表描述了使用以下参数的内存使用问题。参数 1 参数 2 参数 3 参数 4 原因0x1000 内存区域物理地址的高部分。内存区域物理地址的低部分。正在映射的内存的长度。处理内存操作区域时，ACPI 出现致命错误。 内存操作区域尝试映射已为 OS 使用情况分配的内存。如果参数 1 等于 0x02，则 ACPI BIOS 无法处理 PCI 根总线的资源列表。 在这种情况下，参数 3 指定确切的问题，其余参数具有以下定义。参数 2 参数 3 参数 4 原因PCI 总线的 ACPI扩展0x0 指向QUERY_RESOURCES IRP 的指针 ACPI 无法将 BIOS的资源列表转换为正确的格式。 这可能表示 BIOS 的列表编码过程中出错。PCI 总线的 ACPI扩展0x1 指向QUERY_RESOURCE_REQUIREMENTSIRP 的指针ACPI 无法将 BIOS的资源列表转换为正确的格式。 这可能表示 BIOS 的列表编码过程中出错。PCI 总线的 ACPI扩展0x2 0 ACPI 发现一个空的资源列表。PCI 总线的 ACPI扩展0x3 指向 PNP CRS 描述符的指针 ACPI 在 CRS 中找不到当前总线编号。参数 2 参数 3 参数 4 原因PCI 总线的 ACPI扩展指向 PCI 资源列表的指针指向 E820 内存表的指针 PCI 声明要解码的资源列表与 E820BIOS 接口报告的内存区域列表重叠。 (绝不允许这种冲突。)如果参数 1 等于 0x10，则 ACPI BIOS 无法正确确定系统到设备状态映射。 在这种情况下，参数 3 指定确切的问题，其余参数具有以下定义。参数 2 参数 3 参数 4 原因需要其映射的 ACPI 扩展0x0 此DEVICE_POWER_STATE(为“x+1”)_PRx已映射回不支持的 S 状态。需要其映射的 ACPI 扩展0x1 无法映射的SYSTEM_POWER_STATEACPI 找不到要与 S 状态关联的 D 状态。需要其映射的 ACPI 扩展0x2 无法映射的SYSTEM_POWER_STATE当系统处于此 S 状态时，设备声称能够唤醒系统，但系统实际上不支持此 S 状态。如果参数 1 等于 0x11，则系统无法进入 ACPI 模式。 在这种情况下，参数 2 指定确切的问题，其余参数具有以下定义。参数 2 参数 3 参数 4 原因0x0 0 0 系统无法初始化 AML解释器。0x1 0 0 系统找不到 RSDT。0x2 0 0 系统无法分配关键驱动程序结构。0x3 0 0 系统无法加载 RSDT。0x4 0 0 系统无法加载 DB。0x5 0 0 系统无法连接中断向量。0x6 0 0 SCI_EN永远不会在PM1 控制寄存器中设置。参数 2 参数 3 参数 4 原因0x7 指向校验和错误的表的指针Creator 修订版 表校验和不正确。0x8 指向 ACPI 加载失败的表的指针Creator 修订版 ACPI 无法加载 DDB。0x9 FADT 版本 0 不支持的固件版本。0xA 0 0 系统找不到 MADT。0xB 0 0 系统在 MADT 中找不到任何有效的本地SAPIC 结构。参数 1 的值指示错误。如果要调试此错误，请使用 ！analyze -v 扩展。 此扩展显示所有相关数据 (设备扩展、nsobject 或适用于特定错误) 的任何数据。如果不执行调试，则此错误表示必须获取新的 BIOS。 请联系供应商或访问 Internet 以获取新的 BIOS。如果无法获取更新的 BIOS，或者最新的 BIOS 仍然不符合 ACPI，则可以在文本模式设置期间关闭 ACPI 模式。 若要关闭 ACPI 模式，请在系统提示安装存储驱动程序时按 F7键。 系统不会通知你已按下 F7 键，但它以无提示方式禁用 ACPI，并使你能够继续安装。PCI 路由表 (_PRT) 是 ACPI BIOS 对象，用于指定如何将所有 PCI 设备连接到中断控制器。具有多个 PCI 总线的计算机可能有多个_PRTs。可以使用 ！acpikd.nsobj 扩展以及 _PRT 对象的地址作为其参数，在调试器中显示_PRT。Bug 检查代码参考原因解决方法备注另请参阅", "0xA7": "BUG代码 0xA7：BAD_EXHANDLE\n项目 • 2023/06/20BAD_EXHANDLE Bug 检查的值为 0x000000A7。 此 Bug 检查指示内核模式句柄表检测到不一致的句柄表条目状态。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BAD_EXHANDLE参数无另请参阅Bug 检查代码参考", "0xAC": "BUG代码 0xAC：HAL_MEMORY_ALLOCATION\n项目 • 2023/06/20HAL_MEMORY_ALLOCATION Bug 检查 的值为 0x000000AC。 此 Bug 检查指示硬件抽象层 (HAL) 无法获得足够的内存。参数 描述1 分配大小2 03 指向包含文件名的字符串的指针4 保留HAL 无法获取系统关键要求的非分页内存池。这些关键内存分配是在系统初始化的早期完成的，HAL_MEMORY_ALLOCATION Bug 检查是预期的。 此 Bug 检查可能指示其他一些严重错误，例如池损坏或大量消耗。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HAL_MEMORY_ALLOCATION参数原因另请参阅", "0xAD": "BUG代码 0xAD：VIDEO_DRIVER_DEBug_REPORT_REQUEST\n项目 • 2023/06/20VIDEO_DRIVER_DEBug_REPORT_REQUEST Bug 检查 的值为 0x000000AD。 此 Bug 检查指示视频端口在运行时代表视频驱动程序创建了非致命的小型转储。参数 描述1 特定于驱动程序2 特定于驱动程序3 特定于驱动程序4 自启动时间以来请求的所有报告数视频端口在运行时代表视频驱动程序创建了非致命的小型转储，因为视频驱动程序请求了调试报告。VIDEO_DRIVER_DEBug_REPORT_REQUEST Bug 检查只能由小型转储创建引起，而不能由创建完整转储或内核转储引起。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_DRIVER_DEBug_REPORT_REQUEST参数备注另请参阅", "0xB1": "BUG代码 0xB1：BGI_DETECTED_VIOLATION\n项目 • 2023/06/20BGI_DETECTED_VIOLATION Bug 检查 的值为 0x000000B1。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BGI_DETECTED_VIOLATION参数无另请参阅Bug 检查代码参考", "0xB4": "BUG代码 0xB4：VIDEO_DRIVER_INIT_FAILURE\n项目 • 2023/06/20VIDEO_DRIVER_INIT_FAILURE Bug 检查 的值为 0x000000B4。 这表明 Windows 无法进入图形模式。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_DRIVER_INIT_FAILURE参数无原因系统无法进入图形模式，因为没有显示驱动程序能够启动。当没有视频微型端口驱动程序能够成功加载时，通常会发生这种情况。另请参阅Bug 检查代码参考", "0xB8": "BUG代码 0xB8：ATTEMPTED_SWITCH_FROM_DPC\n项目 • 2023/06/20ATTEMPTED_SWITCH_FROM_DPC Bug 检查 的值为 0x000000B8。 这表示延迟的过程调用 (DPC) 例程尝试了非法操作。参数 描述1 导致故障的原始线程2 新线程3 原始线程的堆栈地址4 保留从 DPC 例程尝试了等待操作、附加进程或 yield。 这是一项非法操作。堆栈跟踪将导致导致错误的原始 DPC 例程中的代码。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ATTEMPTED_SWITCH_FROM_DPC参数原因解决方法另请参阅", "0xB9": "BUG代码 0xB9：CHIPSET_DETECTED_ERROR\n项目 • 2023/06/20CHIPSET_DETECTED_ERROR Bug 检查 的值为 0x000000B9。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法！analyze 调试扩展显示有关 Bug 检查的信息，在确定根本原因方面非常有用。另请参阅Bug 检查代码参考", "0xBA": "BUG代码 0xBA：SESSION_HAS_VALID_VIEWS_ON_EXIT\n项目 • 2023/06/20SESSION_HAS_VALID_VIEWS_ON_EXIT Bug 检查 的值为 0x000000BA。 这表示会话驱动程序在卸载会话时仍具有映射视图。参数 描述1 会话 ID2 正在泄漏的映射视图数3 此会话的映射视图表的地址4 此会话的映射视图表的大小此错误是由会话驱动程序在卸载会话之前未取消映射其映射视图导致的。 这表示win32k.sys、atmfd.dll、rdpdd.dll或视频驱动程序存在 Bug。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION_HAS_VALID_VIEWS_ON_EXIT参数原因另请参阅", "0xBB": "BUG代码 0xBB：NETWORK_BOOT_INITIALIZATION_FAILED\n项目 • 2023/06/20NETWORK_BOOT_INITIALIZATION_FAILED Bug 检查 的值为 0x000000BB。 这表示Windows 无法成功从网络启动。参数 描述1 网络初始化失败的部分。 可能的值包括：1： 更新注册表时失败。2： 启动网络堆栈时失败。 Windows 将 IOCTL发送到重定向程序和数据报接收器，然后等待重定向程序准备就绪。 如果某个时间段内未准备就绪，则会发出此错误。3： 将 DHCP IOCTL 发送到 TCP 时失败。 这是Windows 通知传输其 IP 地址的方式。2 失败状态3 保留4 保留此错误是在 Windows 从网络启动并且关键函数在 I/O 初始化期间失败时造成的。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NETWORK_BOOT_INITIALIZATION_FAILED参数原因另请参阅Bug 检查代码参考", "0xBC": "BUG代码 0xBC：NETWORK_BOOT_DUPLICATE_ADDRESS\n项目 • 2023/06/20NETWORK_BOOT_DUPLICATE_ADDRESS Bug 检查 的值为 0x000000BC。 这表示在从网络启动时向此计算机分配了重复的 IP 地址。参数 描述1 IP 地址，显示为 DWORD。 aa.bb.cc.dd 格式的地址将显示为0xDDCCBBAA。2 另一台计算机的硬件地址。 (有关以太网连接，请参阅以下说明。)3 另一台计算机的硬件地址。 (有关以太网连接，请参阅以下说明。)4 另一台计算机的硬件地址。 (对于以太网连接，将为零。)注意 当参数 4 等于零时，这表示以太网连接。 在这种情况下，MAC 地址将存储在参数 2和参数 3 中。 aa-bb-cc-dd-ee-ff 形式的以太网 MAC 地址将导致参数 2 等于0xAABBCCDD，参数 3 等于 0xEEFF0000。此错误表示当 TCP/IP 为其 IP 地址发送 ARP 时，它收到了来自另一台计算机的响应，指示重复的 IP 地址。当 Windows 从网络启动时，这是一个致命错误。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NETWORK_BOOT_DUPLICATE_ADDRESS参数原因另请参阅Bug 检查代码参考", "0xBD": "BUG代码 0xBD：INVALID_HIBERNATED_STATE\n项目 • 2023/06/20INVALID_HIBERNATED_STATE Bug 检查 的值为 0x000000BD。 这表示休眠的内存映像与当前硬件配置不匹配。 当系统从休眠状态恢复并发现硬件在系统休眠期间已更改时，会发生此 Bug 检查。参数 描述1 无效的硬件。1：已安装的处理器数小于休眠前的数目参数 2 中的值：休眠前的处理器数参数 3 中的值：休眠后的处理器数2 每个参数 13 每个参数 14 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_HIBERNATED_STATE参数", "0xBE": "BUG代码 0xBE：ATTEMPTED_WRITE_TO_READONLY_MEMORY\n项目 • 2023/06/20ATTEMPTED_WRITE_TO_READONLY_MEMORY Bug 检查 的值为 0x000000BE。 如果驱动程序尝试写入只读内存段，则会发出此错误。参数 说明1 尝试写入的虚拟地址2 PTE 内容3 保留4 保留如果可以识别负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中kiBugCheckDriver (PUNICODE_STRING) 位置。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ATTEMPTED_WRITE_TO_READONLY_MEMORY参数备注0xBE:ATTEMPTED_WRITE_TO_READONLY_MEMORY\n\n问题原因：\n\n第三方软件缺陷\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xBF": "BUG代码 0xBF：MUTEX_ALREADY_OWNED\n项目 • 2023/06/20MUTEX_ALREADY_OWNED Bug 检查 的值为 0x000000BF。 这表示线程尝试获取其已拥有的互斥体的所有权。参数 描述1 互斥体的地址2 导致错误的线程3 04 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MUTEX_ALREADY_OWNED参数", "0xC1": "BUG代码 0xC1：SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION\n项目 • 2023/06/20SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION Bug 检查 的值为 0x000000C1。 这表示驱动程序写入了特殊池的无效部分。参数 4 指示冲突的类型。参数 1 参数 2 参数 3 参数 4 错误消息的原因驱动程序尝试释放的地址保留 0 0x20 驱动程序尝试释放未分配的池。驱动程序尝试释放的地址请求的字节数 实际提供给调用方 (计算的字节数)0x21，0x22驱动程序试图释放错误地址。驱动程序尝试释放的地址位损坏的地址 保留 0x23 驱动程序释放了地址，但同一页中的附近字节已损坏。驱动程序尝试释放的地址位损坏的地址 保留 0x24 驱动程序释放了一个地址，但分配结束后发生的字节已被覆盖。当前 IRQL 池类型 字节数 0x30 驱动程序尝试在错误的 IRQL 下分配池。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION参数参数 1 参数 2 参数 3 参数 4 错误消息的原因当前 IRQL 池类型 驱动程序尝试释放的地址0x31 驱动程序尝试在错误的 IRQL 中释放池。驱动程序尝试释放的地址一位损坏的地址 保留 0x32 驱动程序释放了一个地址，但同一页中的附近字节有一个单位错误。_POOL_TYPE代码在 ntddk.h 中枚举。 具体而言，0 表示非分页池，1 表示分页池。驱动程序已写入特殊池的无效部分。获取当前线程的回溯。 此回溯通常会显示错误的来源。有关特殊池的信息，请参阅 Windows 驱动程序工具包的驱动程序验证程序部分。原因解决方法", "0xC2": "BUG代码 0xC2：BAD_POOL_CALLER\n项目 • 2023/06/20BAD_POOL_CALLER Bug 检查 的值为 0x000000C2。 这表示当前线程发出错误的池请求。参数 1 指示冲突的类型。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00 0 池类型 池标记 当前线程请求了零字节池分配。0x01，0x02，0x04指向池标头的指针池标头内容的第一部分0 池标头已损坏。0x06 保留 指向池标头的指针池标头内容 当前线程尝试释放已释放的池。0x07 保留 池标头内容 正在释放的池块的地址当前线程尝试释放已释放的池。0x08 当前 IRQL 池类型 分配大小（以字节为单位）当前线程尝试在无效 IRQL 中分配池。0x09 当前 IRQL 池类型 池的地址 当前线程尝试在无效 IRQL 中释放池。0x0A 池的地址 分配器的 标记 在尝试的 free中使用的标记当前线程尝试使用错误的标记来释放池内存。(内存可能属于另一个组件。)） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BAD_POOL_CALLER参数参数 1 参数 2 参数 3 参数 4 错误消息的原因0x0B，0x0C，或 0x0D池的地址 池分配的标记 配额进程指针错误当前线程尝试释放已损坏的池分配的配额。0x40 开始地址 启动系统地址空间0 当前线程尝试在用户模式地址释放内核池。0x41 开始地址 物理页框架 最高物理页框 当前线程尝试释放未分配的非分页池地址。0x42或 0x43正在释放的地址0 0 当前线程尝试释放从未在任何池中的虚拟地址。0x44 开始地址 保留 0 当前线程尝试释放未分配的非分页池地址。0x46 开始地址 0 0 当前线程尝试释放无效的池地址。0x47 开始地址 物理页框架 最高物理页框 当前线程尝试释放未分配的非分页池地址。0x48 开始地址 预留 预留 当前线程尝试释放未分配的分页池地址。0x50 开始地址 从分页池的开头开始偏移量（以页为单位）分页池的大小（以字节为单位）当前线程尝试释放未分配的分页池地址。0x60 开始地址 0 0 当前线程尝试释放无效的连续内存地址。(MmFreeContiguousMemory的调用方传递了错误的指针。)0x99 正在释放的地址0 0 当前线程尝试释放地址无效的池。(此代码也可能指示池标头中的损坏)0x9A 池类型 请求的字节数 池标记 当前线程将分配请求标记为MUST_SUCCEED。(不再支持此池类型。)参数 1 参数 2 参数 3 参数 4 错误消息的原因0x9B 池类型 请求的字节数 呼叫者的地址 当前线程尝试分配标记为 0 的池(这是不可跟踪的，并可能损坏现有标记表。)0x9C 池类型 请求的字节数 呼叫者的地址 当前线程尝试分配标记为“BIG”的池。(这是不可跟踪的，并可能损坏现有的标记表。)0x9D 使用的池标记不正确池类型 呼叫者的地址 当前线程尝试分配包含不包含任何字母或数字的标记的池。使用此类标记会使跟踪池问题变得困难。0x41286 预留 预留 从分页池的开头开始偏移量（以页为单位）当前线程尝试在分配中释放分页池地址。_POOL_TYPE代码在 Ntddk.h 中枚举。 具体而言，0 表示非分页池，1 表示分页池。当前线程发出了无效的池请求。 通常，这在错误的 IRQL 级别或双重释放相同的内存分配，等等。在启用内存池选项的情况下激活驱动程序验证程序，以获取有关这些错误的详细信息并找到出错的驱动程序。驱动程序验证程序驱动程序验证程序是一个实时运行的工具，用于检查驱动程序的行为。 如果发现驱动程序代码执行错误，它会主动创建一个异常，以允许进一步审查驱动程序代码的这一部分。驱动程序验证程序管理器内置于 Windows 中，可在所有 Windows PC 上使用。 若要启动驱动程序验证程序管理器，请在命令提示下键入“验证程序” 。 你可以配置要验证的驱动程序。 验证驱动程序的代码在运行时会增加开销，因此请尝试验证尽可能少的驱动程序。 有关详细信息，请参阅驱动程序验证程序。Windows 内存诊断原因解决方法特别是，对于内存池损坏的情况，请运行 Windows 内存诊断工具，尝试隔离物理内存作为原因。 在控制面板搜索框中，键入“内存”，然后选择“ 诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 查找“内存诊断结果”条目以查看结果。0xC2:BAD_POOL_CALLER\n\n问题原因：\n\n第三方软件缺陷\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xC4": "BUG代码 0xC4：DRIVER_VERIFIER_DETECTED_VIOLATION\n项目 • 2023/06/15DRIVER_VERIFIER_DETECTED_VIOLATION Bug 检查 的值为 0x000000C4。 这是驱动程序验证程序发现的严重错误的常规 Bug检查代码。 有关详细信息，请参阅 启用驱动程序验证程序时处理 Bug 检查。参数 1 标识冲突的类型。 其余参数的含义因参数 1 的值而异。 下表描述了参数值。注意 如果在查看此表中的所有 5 列时遇到问题，请尝试以下操作：将浏览器窗口扩展到完整大小。将光标置于表格中，并使用箭头键向左和向右滚动。参数1参数 2 参数 3 参数 4 错误消息的原因0x00 当前IRQL池类型 字节数 驱动程序请求了零字节池分配。0x01 当前IRQL池类型 分配大小（以字节为单位）驱动程序尝试使用 IRQL > APC_LEVEL分配分页内存。0x02 当前IRQL池类型 分配大小（以字节为单位）驱动程序尝试使用 IRQL > DISPATCH_LEVEL分配非分页内存。0x03 调用方正在尝试分配多个必须成功池的页面，但一个页面是此 API 允许的最大页数。0x10 错误地址0 0 驱动程序尝试释放未从分配调用返回的地址。0x11 当前IRQL池类型 池的地址 驱动程序尝试使用 IRQL > APC_LEVEL释放分页池。0x12 当前IRQL池类型 池的地址 驱动程序尝试使用 IRQL > DISPATCH_LEVEL释放非分页池。0x13或0x14预留 指向池标头的指针 池标头内容 驱动程序尝试释放已释放的内存池。0x15 计时器条目池类型 正在释放的池地址调用方尝试释放的池包含活动计时器。0x16 预留 池地址 0 驱动程序尝试释放错误地址处的池，或驱动程序将无效参数传递给内存例程。0X17 资源条目池类型 正在释放的池地址调用方尝试释放的池包含活动的 ERESOURCE。0x30 当前IRQL请求的 IRQL 0 驱动程序将无效参数传递给 KeRaiseIrql。 (参数是低于当前 IRQL 的值，或高于HIGH_LEVEL 的值。这可能是使用未初始化的 parameter.)） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。DRIVER_VERIFIER_DETECTED_VIOLATION参数0x00 0x70参数1参数 2 参数 3 参数 4 错误消息的原因0x31 当前IRQL请求的 IRQL 0：新 IRQL 错误1：新 IRQL 在DPC 例程中无效驱动程序将无效参数传递给 KeLowerIrql。 (参数的值高于当前 IRQL 或高于HIGH_LEVEL。这可能是使用未初始化的 parameter.)0x32 当前IRQL旋转锁地址 0 驱动程序在除 DISPATCH_LEVEL 以外的 IRQL 中调用 KeReleaseSpinLock 。 (这可能是由于旋转锁的双重释放。)0x33 当前IRQL快速互斥地址 0 驱动程序尝试使用 IRQL > APC_LEVEL获取快速互斥。0x34 当前IRQL线程 APC 禁用计数快速互斥地址 驱动程序尝试在除 APC_LEVEL 之外的 IRQL 处释放快速互斥。0x35 当前IRQL旋转锁地址 旧 IRQL 内核释放了 IRQL 不等于 DISPATCH_LEVEL 的旋转锁。0x36 当前IRQL旋转锁号 旧 IRQL 内核释放了 IRQL 不等于DISPATCH_LEVEL的排队旋转锁。0x37 当前IRQL线程 APC 禁用计数资源 驱动程序尝试获取资源，但未禁用 APC。0x38 当前IRQL线程 APC 禁用计数资源 驱动程序尝试释放资源，但未禁用 APC。0x39 当前IRQL线程 APC 禁用计数Mutex 驱动程序尝试获取一个互斥体“不安全”，IRQL 不等于输入时APC_LEVEL。0x3A 当前IRQL线程 APC 禁用计数Mutex 驱动程序尝试释放互斥体“不安全”，IRQL 不等于输入时APC_LEVEL。0x3B 当前IRQL要等待的对象 超时参数 KeWaitXxx 例程在 DISPATCH_LEVEL 或更高版本调用。0x3C 传递给例程的句柄对象类型 0 驱动程序使用错误的句柄调用 ObReferenceObjectByHandle 。0x3D 0 0 错误资源的地址 驱动程序将错误的 (未对齐) 资源传递给 ExAcquireResourceExclusive。0x3E 0 0 0 驱动程序为当前不在关键区域中的线程调用 KeLeaveCriticalRegion 。0x3F 对象地址新的对象引用计数。 -1：取消引用案例 1：引用案例0 驱动程序将 ObReferenceObject 应用于引用计数为零的对象，或驱动程序将ObDereferenceObject 应用于引用计数为零的对象。0x40 当前IRQL旋转锁地址 0 驱动程序使用 IRQL < DISPATCH_LEVEL调用 KeAcquireSpinLockAtDpcLevel。0x41 当前IRQL旋转锁地址 0 驱动程序使用 IRQL < DISPATCH_LEVEL调用 KeReleaseSpinLockFromDpcLevel。0x42 当前IRQL旋转锁地址 0 驱动程序使用 IRQL > DISPATCH_LEVEL调用 KeAcquireSpinLock。0x51 分配的基址超出分配的引用的地址收费字节数 驱动程序在写入到分配结束之后尝试释放内存。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。0x52 分配的基址哈希条目 收费字节数 驱动程序在写入到分配结束之后尝试释放内存。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。0x53 分配的基址标头 预留 驱动程序在写入到分配结束之后尝试释放内存。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。0x54 分配的基址预留 池哈希大小 驱动程序在写入到分配结束之后尝试释放内存。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。参数1参数 2 参数 3 参数 4 错误消息的原因0x59 分配的基址Listindex 预留 驱动程序在写入完分配后尝试释放内存。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。0x60 从分页池分配的字节数从非分页池分配的字节数未释放的分配总数驱动程序正在卸载，但未首先释放其池分配。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。0x61 从分页池分配的字节数从非分页池分配的字节数未释放的分配总数驱动程序正在卸载时，驱动程序线程正在尝试分配池内存。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。0x62 驱动程序的名称预留 未释放的分配总数，包括分页池和非分页池驱动程序正在卸载，但未首先释放其池分配。 仅当驱动程序验证程序的“池跟踪”选项处于活动状态时，才会使用此参数检查 Bug。 键入 ！verifier 3drivername.sys，获取有关导致错误检查的已泄露的分配的信息。0x6F MDL地址正在锁定的物理页面系统中的最高物理页在不在 PFN 数据库中的页面上调用 MmProbeAndLockPages。 这通常是调用此例程以锁定其自己的专用双端口 RAM 的驱动程序。 这不仅是不需要的，而且还会损坏具有不连续物理 RAM 的计算机的内存。参数1参数 2 参数 3 参数 4 错误消息的原因0x70 当前 IRQL MDL 地址 访问模式 驱动程序使用 IRQL > DISPATCH_LEVEL调用MmProbeAndLockPages。0x71 当前 IRQL MDL 地址 进程地址 驱动程序使用 IRQL > DISPATCH_LEVEL调用MmProbeAndLockProcessPages。0x72 当前 IRQL MDL 地址 进程地址 驱动程序使用 IRQL > DISPATCH_LEVEL调用MmProbeAndLockSelectedPages。0x73 当前 IRQL 在 32 位 Windows 中：物理地址的低32 位在 64 位 Windows 中：64 位物理地址字节数 名为 MmMapIoSpace 的驱动程序与 IRQL > DISPATCH_LEVEL。0x74 当前 IRQL MDL 地址 访问模式 驱动程序在内核模式下使用 IRQL > DISPATCH_LEVEL调用MmMapLockedPages。0x75 当前 IRQL MDL 地址 访问模式 驱动程序在用户模式下使用 IRQL > APC_LEVEL调用MmMapLockedPages。0x76 当前 IRQL MDL 地址 访问模式 驱动程序在内核模式下使用 IRQL > DISPATCH_LEVEL调用MmMapLockedPagesSpecifyCache。0x77 当前 IRQL MDL 地址 访问模式 驱动程序在用户模式下使用 IRQL > APC_LEVEL调用MmMapLockedPagesSpecifyCache。0x78 当前 IRQL MDL 地址 0 驱动程序使用 IRQL > DISPATCH_LEVEL调用 MmUnlockPages。0x79 当前 IRQL 正在取消映射的虚拟地址 MDL 地址驱动程序在内核模式下使用 IRQL > DISPATCH_LEVEL调用MmUnmapLockedPages。0x7A 当前 IRQL 正在取消映射的虚拟地址 MDL 地址驱动程序在用户模式下使用 IRQL > APC_LEVEL调用MmUnmapLockedPages。0x7B 当前 IRQL 正在取消映射的虚拟地址 字节数 名为 MmUnmapIoSpace 的驱动程序与 IRQL > APC_LEVEL。0x7C MDL 地址 MDL 标志 0 驱动程序调用 了 MmUnlockPages，并传递了一个 MDL，该MDL 的页从未成功锁定。0x70 0x91参数1参数 2 参数 3 参数 4 错误消息的原因0x7D MDL 地址 MDL 标志 0 驱动程序调用 了 MmUnlockPages，并传递了一个 MDL，该MDL 的页面来自非分页池。 (永远不应解锁这些内容。)0x7E 当前 IRQL DISPATCH_LEVEL 0 名为 MmAllocatePagesForMdl、 MmAllocatePagesForMdlEx 或MmFreePagesFromMdl 的驱动程序与 IRQL >DISPATCH_LEVEL。0x7F 当前 IRQL MDL 地址 MDL 标志驱动程序调用 BuildMdlForNonPagedPool 并传递了一个 MDL，该 MDL 的页来自分页池。0x80 当前 IRQL 事件地址 0 驱动程序使用 IRQL > DISPATCH_LEVEL调用 KeSetEvent。0x81 MDL 地址 MDL 标志 0 名为 MmMapLockedPages 的驱动程序。 (应改用MmMapLockedPagesSpecifyCache ，并将 BugCheckOnFailure参数设置为 FALSE.)0x82 MDL 地址 MDL 标志 0 名为 MmMapLockedPagesSpecifyCache 的驱动程序，其BugCheckOnFailure 参数等于 TRUE。 (此参数应设置为 FALSE.)0x83 要映射的物理地址范围的开始要映射的字节数 未锁定的第一页帧编号驱动程序调用 MmMapIoSpace ，但未锁定 MDL 页。 在进行此调用之前，由映射的物理地址范围表示的物理页必须已锁定。0x85 MDL 地址 要映射的页数 未锁定的第一页帧编号驱动程序调用 了 MmMapLockedPages ，但未锁定 MDL 页。0x89 MDL 地址 指向 MDL 中非内存页的指针 MDL 中的非内存页码MDL 未标记为“I/O”，但它包含非内存页地址。0x91 预留 预留 预留 驱动程序使用操作系统不支持的方法切换堆栈。 扩展内核模式堆栈的唯一受支持的方法是使用KeExpandKernelStackAndCallout。参数1参数 2 参数 3 参数 4 错误消息的原因0xA0 指向发出读取或写入请求的 IRP 的指针较低设备的设备对象 检测到错误的扇区数 在硬盘上检测到循环冗余检查 (CRC) 错误。 仅当驱动程序验证程序的“磁盘完整性检查”选项处于活动状态时，才会使用此参数检查 Bug。0xA1 发出读取或写入请求的 IRP 的副本。(实际 IRP 已完成。)较低设备的设备对象 检测到错误的扇区数 在扇区上检测到 CRC 错误， (异步) 。 仅当驱动程序验证程序的“磁盘完整性检查”选项处于活动状态时，才会使用此参数检查 Bug。0xA2 发出读取或写入请求的 IRP，或此IRP 的副本较低设备的设备对象 检测到错误的扇区数 CRCDISK 校验和副本不匹配。 这可能是分页错误。 仅当驱动程序验证程序的“磁盘完整性检查”选项处于活动状态时，才会使用此参数检查 Bug。0xB0 MDL 地址 MDL 标志 MDL 标志不正确 驱动程序为具有错误标志的 MDL 调用 了MmProbeAndLockPages 。 例如，驱动程序将MmBuildMdlForNonPagedPool 创建的 MDL 传递给MmProbeAndLockPages。0xB1 MDL 地址 MDL 标志 MDL 标志不正确 驱动程序为具有错误标志的 MDL 调用了MmProbeAndLockProcessPages。 例如，驱动程序将MmBuildMdlForNonPagedPool 创建的 MDL 传递给MmProbeAndLockProcessPages。0xA0 0x140参数1参数 2 参数 3 参数 4 错误消息的原因0xB2 MDL 地址 MDL 标志 MDL 标志不正确 对于具有错误标志的 MDL，驱动程序名为MmMapLockedPages 。 例如，驱动程序传递了已映射到系统地址或未锁定到 MmMapLockedPages 的 MDL。0xB3 MDL 地址 MDL 标志 缺少 MDL 标志 (预计至少有一个)对于具有错误标志的 MDL，驱动程序名为MmMapLockedPages 。 例如，驱动程序传递的 MDL 未锁定到 MmMapLockedPages。0xB4 MDL 地址 MDL 标志 意外的部分 MDL 标志 对于部分 MDL，驱动程序名为 MmUnlockPages 。 部分MDL 是由 IoBuildPartialMdl 创建的。0xB5 MDL 地址 MDL 标志 意外的部分 MDL 标志 使用 IoBuildPartialMdl) 创建的部分 MDL (调用MmUnmapLockedPages。0xB6 MDL 地址 MDL 标志 缺少 MDL 标志 在未映射到系统地址的 MDL 上调用的MmUnmapLockedPages。0xB7 损坏的物理页数。 第一个损坏的物理页。上次损坏的物理页。 系统 BIOS 在睡眠转换期间损坏了低物理内存。0xB8 MDL 地址 MDL 标志 预留 仍会映射由 MDL 描述的页面。 在调用 IoFreeMdl 之前，驱动程序必须取消映射页面。0xB9 未映射的地址。 MDL 地址。 预留 调用的 MmUnmapLockedPages 的用户空间地址不正确。0xC0 IRP 的地址 0 保留 名为 IoCallDriver 的 驱动程序，其中禁用了中断。0xC1 驱动程序调度例程的地址预留 预留 返回驱动程序调度例程时禁用了中断。0xC2 0 0 0 禁用中断后，驱动程序调用了快速 I/O 调度例程。0xC3 驱动程序快速 I/O调度例程的地址预留 预留 已返回驱动程序快速 I/O 调度例程，但中断已禁用。0xC5 驱动程序调度例程的地址当前线程的 APC 禁用计数线程的 APC 在调用驱动程序调度例程之前禁用计数驱动程序调度例程已更改线程的 APC 禁用计数。 每次驱动程序调用 KeEnterCriticalRegion、 FsRtlEnterFileSystem 或获取互斥体时，APC 禁用计数都会递减。 每次驱动程序调用KeLeaveCriticalRegion、 KeReleaseMutex 或FsRtlExitFileSystem 时，APC 禁用计数都会递增。 由于这些调用应始终成对，因此每当线程退出时，APC 禁用计数应为零。 负值表示驱动程序已禁用 APC 调用而不重新启用它们。正值表示反之，则为 true。0xC6 驱动程序快速 I/O调度例程的地址当前线程的 APC 禁用计数线程的 APC 在调用快速 I/O 驱动程序调度例程之前禁用计数驱动程序快速 I/O 调度例程已更改线程的 APC 禁用计数。 每次驱动程序调用 KeEnterCriticalRegion、FsRtlEnterFileSystem 或获取互斥体时，APC 禁用计数都会递减。 每次驱动程序调用 KeLeaveCriticalRegion、KeReleaseMutex 或 FsRtlExitFileSystem 时，APC 禁用计数都会递增。 由于这些调用应始终成对，因此每当线程退出时，APC 禁用计数应为零。 负值表示驱动程序已禁用 APC 调用而不重新启用它们。 正值表示反之，则为 true。0xCA 旁观列表的地址 预留 预留 驱动程序已尝试重新初始化查看列表。0xCB 旁观列表的地址 预留 预留 驱动程序尝试删除未初始化的 lookaside 列表。0xCC 旁观列表的地址 池分配的起始地址 池分配的大小 驱动程序已尝试释放包含活动查看列表的池分配。0xCD 旁观列表的地址 调用方指定的块大小 支持的最小块大小 驱动程序尝试创建分配块大小过小的旁观列表。0xD0 ERESOURCE 结构的地址预留 预留 驱动程序已尝试重新初始化 ERESOURCE 结构。0xD1 ERESOURCE 结构的地址预留 预留 驱动程序尝试删除未初始化的 ERESOURCE 结构。参数1参数 2 参数 3 参数 4 错误消息的原因0xD2 ERESOURCE 结构的地址池分配的起始地址 池分配的大小 驱动程序尝试释放包含活动 ERESOURCE 结构的池分配。0xD5 由已检查的驱动程序内部版本创建的IO_REMOVE_LOCK结构的地址当前IoReleaseRemoveLock标记预留 当前的 IoReleaseRemoveLock 标记与以前的IoAcquireRemoveLock 标记不匹配。 如果调用IoReleaseRemoveLock 的驱动程序不在选中的内部版本中，则参数 2 是驱动程序验证程序代表驱动程序创建的影子IO_REMOVE_LOCK结构的地址。 在这种情况下，根本不使用驱动程序使用的IO_REMOVE_LOCK结构的地址，因为驱动程序验证程序将替换所有删除锁 API 的锁地址。 仅当驱动程序验证程序的 I/O 验证选项处于活动状态时，才会使用此参数检查 Bug。0xD6 由已检查的驱动程序内部版本创建的IO_REMOVE_LOCK结构的地址与以前的IoAcquireRemoveLock标记不匹配的标记以前的IoAcquireRemoveLock标记当前的 IoReleaseRemoveLockAndWait 标记与以前的IoAcquireRemoveLock 标记不匹配。 如果调用IoReleaseRemoveLock 的驱动程序不是选中的版本，则参数 2是驱动程序验证程序代表驱动程序创建的影子IO_REMOVE_LOCK结构的地址。 在这种情况下，根本不使用驱动程序使用的IO_REMOVE_LOCK结构的地址，因为驱动程序验证程序将替换所有删除锁 API 的锁地址。 仅当驱动程序验证程序的 I/O 验证选项处于活动状态时，才会使用此参数检查 Bug。0xD7 已检查的生成地址，删除驱动程序验证程序在内部使用的锁定结构驱动程序指定的Remove Lock 结构的地址预留 即使删除锁调用 IoReleaseRemoveLockAndWait，也无法重新初始化，因为其他线程可能仍在通过调用IoAcquireRemoveLock) 来使用该锁 (。 驱动程序应在其设备扩展内分配 Remove Lock，并对其进行一次初始化。 锁将与设备扩展一起删除。0xDA 驱动程序的起始地址驱动程序内的 WMI 回调地址预留 尝试卸载尚未取消注册其 WMI 回调函数的驱动程序。0xDB 设备对象的地址 预留 预留 尝试删除未从 WMI 取消注册的设备对象。0xDC 预留 预留 预留 将无效的 RegHandle 值指定为函数 EtwUnregister 的参数。0xDD 调用 EtwRegister的地址卸载驱动程序的起始地址对于Windows 8及更高版本，此参数是ETW RegHandle 值。尝试在不调用 EtwUnregister 的情况下卸载驱动程序。0xDF 同步对象地址 0 0 同步对象位于会话地址空间中。 不允许在会话地址空间中使用同步对象，因为它们可以从另一个会话或从没有会话虚拟地址空间的系统线程进行操作。0xE0 用作参数的用户模式地址用作参数的地址范围的大小（以字节为单位）预留 调用了将用户模式地址指定为参数的操作系统内核函数。0xE1 同步对象的地址 预留 预留 发现同步对象的地址无效或可分页。0xE2 IRP 的地址 IRP 中存在的用户模式地址预留 发现 Irp-RequestorMode> 设置为 KernelMode 的 IRP 具有用户模式地址作为其成员之一。0xE3 调用 API 的地址 在 API 中用作参数的用户模式地址预留 驱动程序已调用内核模式 ZwXxx 例程，并使用用户模式地址作为参数。0xE4 调用 API 的地址 格式不正确的UNICODE_STRING结构的地址预留 驱动程序已调用内核模式 ZwXxx 例程，其中格式错误的UNICODE_STRING结构作为参数。0xE5 当前 IRQL 预留 预留 在错误的 IRQL 中调用了内核 API。0xE6 进行 Zw API 调用的驱动程序内的地址当前 IRQL 特殊内核 APC。 在 IRQL = PASSIVE_LEVEL 且启用了特殊内核 APC 的情况下，未调用内核 Zw API。0xEA 当前 IRQL 线程的 APC 禁用计数 推送锁的地址 驱动程序尝试在启用 APC 时获取推送锁。参数1参数 2 参数 3 参数 4 错误消息的原因0xEB 当前 IRQL 线程的 APC 禁用计数 推送锁的地址 驱动程序尝试在启用 APC 时释放一个推送锁。0xF0 目标缓冲区的地址 源缓冲区的地址 要复制的字节数 一个调用 memcpy 函数的驱动程序，其中包含重叠的源缓冲区和目标缓冲区。0xF5 NULL 句柄的地址 对象类型 预留 驱动程序将 NULL 句柄传递给ObReferenceObjectByHandle。0xF6 处理被引用的值 当前进程的地址 执行错误引用的驱动程序内的地址驱动程序将用户模式句柄引用为内核模式。0xF7 由调用方指定的句柄值调用方指定的对象类型调用方指定的AccessMode驱动程序正在尝试在系统进程的上下文中对内核句柄进行用户模式引用。0xFA 完成例程地址。 调用完成例程之前的IRQL 值调用完成例程后的当前 IRQL 值IRP 完成例程返回的 IRQL 不同于调用该例程的 IRQL。0xFB 完成例程地址 当前线程的 APC 禁用计数线程的 APC 在调用IRP 完成例程之前禁用计数线程的 APC 禁用计数已由驱动程序的 IRP 完成例程更改。 每次驱动程序调用 KeEnterCriticalRegion、FsRtlEnterFileSystem 或获取互斥体时，APC 禁用计数都会递减。 每次驱动程序调用 KeLeaveCriticalRegion、KeReleaseMutex 或 FsRtlExitFileSystem 时，APC 禁用计数都会递增。 由于这些调用应始终成对，因此每当线程退出时，APC 禁用计数应为零。 负值表示驱动程序已禁用 APC 调用而不重新启用它们。 正值表示反之，则为 true。0xFC 进行错误 API 调用的驱动程序内的地址。提供了 ApcContext值。预留 使用不支持的 ApcContext 值从内核模式) 调用ZwNotifyChangeKey (。参数1参数 2 参数 3 参数 4 错误消息的原因0x105 IRP 的地址 0 0 驱动程序使用 ExFreePool 而不是 IoFreeIrp 来释放 IRP。0x10A 0 0 0 驱动程序尝试向空闲进程收取池配额费用。0x10B 0 0 0 驱动程序尝试从 DPC 例程收取池配额费用。 这是不正确的，因为当前进程上下文未定义。0x110 中断服务例程的地址在执行 ISR 之前保存的扩展上下文的地址扩展上下文的地址在执行 ISR 后已保存驱动程序 (ISR) 中断服务例程损坏了扩展线程上下文。0x111 中断服务例程的地址执行 ISR 前的IRQL执行 ISR 后的 IRQL中断服务例程返回了更改的 IRQL。0x115 负责关闭的线程的地址，该地址可能是死锁的。0 0 驱动程序验证程序检测到系统花费的时间超过 20 分钟，并且关闭未完成。0x11A 当前 IRQL 0 0 驱动程序在 IRQL > APC_LEVEL调用 KeEnterCriticalRegion。0x11B 当前 IRQL 0 0 驱动程序在 IRQL > APC_LEVEL调用 KeLeaveCriticalRegion。0x120 IRQL 值的地址要等待的对象地址超时值的地址线程在 IRQL > DISPATCH_LEVEL等待。 KeWaitForSingleObject 或KeWaitForMultipleObjects 的调用方必须在 IRQL <= DISPATCH_LEVEL 运行。0x105 0x140参数1参数 2 参数 3 参数 4 错误消息的原因0x121 IRQL 值的地址要等待的对象地址超时值的地址线程在 IRQL 处等待等于 DISPATCH_LEVEL，超时为 NULL。KeWaitForSingleObject 或 KeWaitForMultipleObjects 的调用方可以在 IRQL <=DISPATCH_LEVEL 运行。 如果为 Timeout 提供了 NULL 指针，则调用线程将保持等待状态，直到发出对象信号。0x122 IRQL 值的地址要等待的对象地址超时值的地址线程在DISPATCH_LEVEL等待，超时值不等于零 (0) 。 如果 Timeout ！= 0，则KeWaitForSingleObject 或 KeWaitForMultipleObjects 的调用方必须在 IRQL <=APC_LEVEL运行。0x123 要等待的对象地址0 0 KeWaitForSingleObject 或 KeWaitForMultipleObjects 的调用方将等待指定为UserMode，但对象位于内核堆栈上。0x130 工作项的地址 0 0 工作项位于会话地址空间中。 不允许在会话地址空间中使用工作项，因为它们可以从另一个会话或从没有会话虚拟地址空间的系统线程进行操作。0x131 工作项的地址 0 0 工作项位于可分页内存中。 工作项必须位于不可分页的内存中，因为内核在DISPATCH_LEVEL使用它们。0x135 IRP 地址 IoCancelIrp 调用与完成此IRP 之间允许的毫秒数0 取消的 IRP 未在预期时间内完成，驱动程序完成取消的 IRP 所需的时间比预期长。0x13A 正在释放的池块的地址值不正确 错误值的地址驱动程序已调用 ExFreePool ，驱动程序验证程序在用于跟踪池使用情况的内部值之一中检测到错误。0x13B 正在释放的池块的地址错误值的地址 指向错误内存页的指针的地址驱动程序已调用 ExFreePool ，驱动程序验证程序在用于跟踪池使用情况的内部值之一中检测到错误。0x13C 正在释放的池块的地址值不正确 错误值的地址驱动程序已调用 ExFreePool ，驱动程序验证程序在用于跟踪池使用情况的内部值之一中检测到错误。0x13D 正在释放的池块的地址错误值的地址 预期的正确值驱动程序已调用 ExFreePool ，驱动程序验证程序在用于跟踪池使用情况的内部值之一中检测到错误。0x13E 调用方指定的池块地址驱动程序验证程序跟踪的池块地址指向驱动程序验证程序跟踪的池块地址的指针ExFreePool 调用方指定的池块地址不同于驱动程序验证程序跟踪的地址。0x13F 正在释放的池块的地址正在释放的字节数指向驱动程序验证程序跟踪的字节数的指针调用 ExFreePool 时释放的内存字节数不同于驱动程序验证程序跟踪的字节数。0x140 当前 IRQL MDL 地址 与此 MDL 关联的虚拟地址非锁定 MDL 是从可分页内存或可交易内存构造的。0x141 请求分配的驱动程序的最高物理地址要分配的字节数0 驱动程序正在显式请求 4GB 以下的物理内存。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x1000 资源的地址 预留 预留 自死锁：当前线程尝试以递归方式以独占方式获取它仅拥有共享的资源。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。0x1001 死锁最终原因的资源的地址预留 预留 死锁：已发现锁层次结构冲突。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。 (使用 ！死锁 扩展了解详细信息。)0x1000到0x100B - 死锁参数 1 参数 2 参数 3 参数 4 错误消息的原因0x1002 资源的地址 预留 预留 未初始化的资源：已获取资源，但尚未先初始化。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。0x1003 正在释放死锁的资源的地址应先释放的资源的地址预留 意外发布：资源已按不正确的顺序释放。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。0x1004 资源的地址 获取资源的线程的地址当前线程的地址 意外线程：错误的线程释放资源。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。0x1005 资源的地址 预留 预留 多次初始化：一个资源多次初始化。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。0x1007 资源的地址 预留 预留 未获取的资源：在获取资源之前释放资源。 仅当驱动程序验证程序的死锁检测选项处于活动状态时，才会使用此参数检查 Bug。0x1008 锁地址 预留 预留 驱动程序尝试通过使用此锁类型不匹配的 API 来获取锁。0x1009 锁地址 预留 预留 驱动程序尝试使用此锁类型不匹配的 API 释放锁。0x100A 所有者线程地址预留 终止的线程拥有锁。0x100B 锁地址 所有者线程地址 预留 已删除的锁仍归线程所有。0x1010 向其发出写入 IRP 的设备对象。IRP 的地址。 System-Space MDL描述的缓冲区的虚拟地址。修改了写入 Irp 的固定 MDL 缓冲区内容。0x1011 向其发出写入 IRP 的设备对象。IRP 的地址。 System-Space MDL描述的缓冲区的虚拟地址。读取 Irp 的固定 MDL 缓冲区内容是在调度期间修改的，或由虚拟页面支持的缓冲区。0x1012 指向描述冲突的字符串的指针。如果未) 使用，则涉及此损坏的数据 (0。如果未) 使用，则涉及此损坏的数据(0。验证程序扩展状态存储检测到损坏。0x1013 指向驱动程序对象的指针。指向捕获的原始I/O 回调的指针。保留 (未使用的) 。 验证程序在捕获的原始 I/O 回调中检测到内部损坏。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x2000 驱动程序代码中检测到错误的地址。池类型。 池标记 (（如果)提供）。代码完整性问题：调用方指定了可执行池类型。(预期：NonPagedPoolNx)0x2001 驱动程序代码中检测到错误的地址。页面保护(WIN32_PROTECTION_MASK) 。0 代码完整性问题：调用方指定了可执行页保护。预期 (：清除PAGE_EXECUTE* 位)0x2002 驱动程序代码中检测到错误的地址。页面优先级 (MM_PAGE_PRIORITYMdlMapping*) 在逻辑上 OR'd。0 代码完整性问题：调用方指定了可执行的 MDL 映射。 预期 (：MdlMappingNoExecute)0x2003 图像文件名(Unicode 字符串)。节标头的地址。 节名称 (UTF-8编码字符串) 。代码完整性问题：映像包含可执行和可写部分。0x2004 图像文件名(Unicode 字符串)。节标头的地址。 节名称 (UTF-8编码字符串) 。代码完整性问题：图像包含一个未对齐页面的部分。0x2005 图像文件名(Unicode 字符串)。IAT 目录。 节名称 (UTF-8编码字符串) 。代码完整性问题：映像包含位于可执行文件部分中的 IAT。0x2000到0x2005 - 代码完整性问题参数 1 参数 2 参数 3 参数4错误消息的原因0xA001 指向NetBufferList对象的指针如果非 NULL) ，则指向虚拟交换机对象的指针 ( 保留(未使用的)VM 交换机：必须设置调用方提供的 NetBufferList 的SourceHandle。 请参阅AllocateNetBufferListForwardingContext 例程。0xA002 指向NetBufferList对象的指针如果非 NULL) ，则指向虚拟交换机对象的指针(。保留(未使用的)VM 交换机：调用方提供的 NetBufferList 的转发详细信息不为零。 请参阅 AllocateNetBufferListForwardingContext 例程。0xA003 指向NetBufferList对象的指针如果非 NULL) ，则指向虚拟交换机对象的指针(。保留(未使用的)VM 交换机：调用方提供了一个 NetBufferList，其数据包标头或路由上下文为 NULL。 请参阅 可扩展交换机数据路径的数据包管理指南。0xA004 无效端口的IDNIC 索引 如果非NULL)，则指向虚拟交换机对象的指针(。VM 交换机：调用方指定的端口和 NIC 索引组合无效。 请参阅 Hyper-V 可扩展交换机端口和网络适配器状态。0xA005 指向NetBufferList对象的指针指向“目标”列表的指针。 如果非NULL)，则指向虚拟交换机对象的指针(。VM 交换机：调用方提供的目标无效。 请参阅AddNetBufferListDestination 和UpdateNetBufferListDestinations。0xA006 指向NetBufferList对象的指针如果非 NULL) ，则指向虚拟交换机对象的指针(。保留(未使用的)VM 交换机：调用方提供了无效的源 NIC 或 Port 对象。 请参阅 Hyper-V 可扩展交换机端口和网络适配器状态。0xA007 指向NetBufferList对象的指针如果非 NULL) ，则指向虚拟交换机对象的指针(。保留(未使用的)VM 交换机：调用方提供的目标列表无效。 请参阅AddNetBufferListDestination 和UpdateNetBufferListDestinations。0xA008 父 NIC 对象 NIC 索引 如果非NULL)，则指向虚拟交换机对象的指针(。VM 交换机：在不允许时尝试引用 NIC。 请参阅 Hyper-V 可扩展交换机端口和网络适配器状态。0xA009 正在引用的端口如果非 NULL) ，则指向虚拟交换机对象的指针 ( 保留(未使用的)VM 交换机：在不允许时尝试引用端口。 请参阅 Hyper-V 可扩展交换机端口和网络适配器状态。0xA00A 指向NetBufferList对象的指针ContextTypeInfo 对象 保留(未使用的)VM 交换机：已设置失败上下文。 请参阅SetNetBufferListSwitchContext。0xA001到0xA00D - VM 交换机问题参数 1 参数 2 参数 3 参数4错误消息的原因0xA00B 指向NetBufferList对象的指针NDIS_SWITCH_REPORT_FILTERED_NBL_FLAGS_* 如果非NULL)，则指向虚拟交换机对象的指针 (VM 交换机：为已删除的 NetBufferList 提供的方向无效。 请参阅 ReportFilteredNetBufferLists。0xA00C 指向NetBufferList对象的指针Send Flags 值 如果非NULL)，则指向虚拟交换机对象的指针 (VM 交换机：设置NDIS_SEND_FLAGS_SWITCH_SINGLE_SOURCE 标志时，NetBufferList 链具有多个源端口。 请参阅 Hyper-V 可扩展交换机发送和接收标志。0xA00D 指向NetBufferList对象的指针指向虚拟交换机上下文的指针 如果非NULL)，则指向虚拟交换机对象的指针 (VM 交换机：设置NDIS_RECEIVE_FLAGS_SWITCH_DESTINATION_GROUP标志时，链中的一个或多个 NetBufferList 的目标无效。 请参阅Hyper-V 可扩展交换机发送和接收标志。0xA00E 指向NetBufferLists对象的指针。指向虚拟交换机上下文的指针。 如果非NULL)，则指向虚拟交换机对象的指针(。VM 交换机：设置VMS_NBL_ROUTING_CONTEXT_FLAG_NO_WNV_PROCESSING标志时，尝试通过 WNV 完成 NetBufferList。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00020002 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlApcLte。 规则指定驱动程序必须仅在IRQL <= APC_LEVEL 时才调用 ObGetObjectSecurity 和ObReleaseObjectSecurity。0x00020003 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlDispatch。 IrqlDispatch 规则指定驱动程序必须仅在 IRQL = DISPATCH_LEVEL0x00020004 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlExAllocatePool。 IrqlExAllocatePool规则指定驱动程序仅在 IRQL<=DISPATCH_LEVEL 时调用ExAllocatePoolWithTag 和 ExAllocatePoolWithTagPriority。0x00020002 0x00020022 - DDI 合规性规则冲突参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00020005 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlExApcLte1。 IrqlExApcLte1 规则指定驱动程序仅在 IRQL <= APC_LEVEL 时才调用 ExAcquireFastMutex 和ExTryToAcquireFastMutex。0x00020006 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlExApcLte2。 IrqlExApcLte2 规则指定驱动程序仅在 IRQL <= APC_LEVEL时才调用某些例程。0x00020007 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlExApcLte3。 IrqlExApcLte3 规则指定驱动程序必须仅在 IRQL <= APC_LEVEL时才调用某些执行支持例程。0x00020008 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlExPassive。 IrqlExPassive 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些执行支持例程。0x00020009 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlIoApcLte。 IrqlIoApcLte 规则指定驱动程序必须仅在 IRQL <= APC_LEVEL时才调用某些 I/O 管理器例程。0x0002000A 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlIoPassive1。 IrqlIoPassive1 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些 I/O 管理器例程。0x0002000B 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlIoPassive2。 IrqlIoPassive2 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些 I/O 管理器例程。0x0002000C 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlIoPassive3。 IrqlIoPassive3 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些 I/O 管理器例程。0x0002000D 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlIoPassive4。 IrqlIoPassive4 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些 I/O 管理器例程。0x0002000E 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlIoPassive5。 IrqlIoPassive5 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些 I/O 管理器例程。0x0002000F 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlKeApcLte1。 IrqlKeApcLte1 规则指定驱动程序必须仅在 IRQL <= APC_LEVEL时才调用某些内核例程。0x00020010 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlKeApcLte2。 IrqlKeApcLte2 规则指定驱动程序必须仅在 IRQL <= APC_LEVEL时才调用某些内核例程。0x00020011 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlKeDispatchLte。 IrqlKeDispatchLte 规则指定驱动程序必须仅在 IRQL <= DISPATCH_LEVEL时才调用某些内核例程。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00020015 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlKeReleaseSpinLock。IrqlKeReleaseSpinLock 规则指定驱动程序必须仅在 IRQL =DISPATCH_LEVEL时才调用 KeReleaseSpinLock。0x00020016 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlKeSetEvent。 IrqlKeSetEvent 规则指定仅在 Wait 设置为 FALSE 时在 IRQL <= DISPATCH_LEVEL 调用KeSetEvent 例程，在将 Wait 设置为 TRUE 时，在 IRQL <= APC_LEVEL 调用。0x00020019 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlMmApcLte。 IrqlMmApcLte 规则指定驱动程序必须仅在 IRQL <= APC_LEVEL时才调用某些内存管理器例程。0x0002001A 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlMmDispatch。 IrqlMmDispatch 规则指定驱动程序必须仅在 IRQL = DISPATCH_LEVEL时才调用MmFreeContiguousMemory 。0x0002001B 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlObPassive。 IrqlObPassive 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用ObReferenceObjectByHandle 。0x0002001C 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlPsPassive。 IrqlPsPassive 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用某些进程和线程管理器例程。0x0002001D 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则 IrqlReturn。0x0002001E 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlRtlPassive。 IrqlRtlPassive 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用 RtlDeleteRegistryValue 。0x0002001F 指向描述违反规则条件的字符串的指针。指向规则状态变量的可选指针 () 。预留 驱动程序违反了 DDI 符合性规则 IrqlZwPassive。 IrqlZwPassive 规则指定驱动程序必须仅在 IRQL = PASSIVE_LEVEL时才调用 ZwClose 。0x00020022 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的)驱动程序违反了 DDI 符合性规则 IrqlIoDispatch。0x00020023 指向描述违反规则条件的字符串的指针。保留 (未使用的)。保留 (未使用的) 。驱动程序违反了 DDI 符合性规则 IrqlIoRtlZwPassive。 IrqlIoRtlZwPassive规则指定驱动程序仅在 IRQL = PASSIVE_LEVEL 执行时调用规则中列出的DDI。0x00020024 指向描述违反规则条件的字符串的指针。保留 (未使用的)。保留 (未使用的) 。驱动程序违反了 DDI 符合性规则 IrqlNtifsApcPassive。 IrqlNtifsApcPassive规则指定驱动程序仅在 IRQL = PASSIVE_LEVEL 或 IRQL = APC_LEVEL执行时调用规则中列出的 DDI <。0x00020025 指向描述违反规则条件的字符串的指针。保留 (未使用的)。保留 (未使用的) 。驱动程序违反了 Microsoft 内部 DDI 合规性规则 IrqlKeMore。0x00040003到0x00043006 - DDI 合规性规则冲突参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00040003 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合 性规则CriticalRegions。0x00040006 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则QueuedSpinLock。0x00040007 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则QueuedSpinLockRelease。0x00040009 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则SpinLock。0x0004000A 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则SpinlockRelease。0x0004000E 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则GuardedRegions。0x0004100B 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的) 驱动程序违反了 DDI 符合性规则RequestedPowerIrp。0x0004100F 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则IoSetCompletionExCompleteIrp。0x00043006 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的) 驱动程序违反了 DDI 符合性规则PnpRemove。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00081001 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsDeviceMutex。0x00081002 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsStreamPointerClone。0x00081003 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的) 驱动程序违反了 DDI 符合性规则KsStreamPointerLock。0x00081004 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsStreamPointerUnlock。0x00081005 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的) 驱动程序违反了 DDI 符合性规则KsCallbackReturn。0x00081006 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsIrqlDeviceCallbacks。0x00081007 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsIrqlFilterCallbacks。0x00081008 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsIrqlPinCallbacks。0x00081009 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的) 驱动程序违反了 DDI 符合性规则KsIrqlDDI。0x0008100A 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsFilterMutex。0x0008100B 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsProcessingMutex。0x0008100C 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsInvalidStreamPointer。0x00081001 0x00082005 - AVStream 驱动程序合规性规则冲突参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00082001 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsTimedPinSetDeviceState。0x00082002 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsTimedDeviceCallbacks。0x00082003 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数 (内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsTimedFilterCallbacks。0x00082004 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsTimedPinCallbacks。0x00082005 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则KsTimedProcessingMutex。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x00091001 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则NdisOidComplete。0x00091002 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则NdisOidDoubleComplete。0x0009100E 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 DDI 符合性规则NdisOidDoubleRequest。0x00092003 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则NdisTimedOidComplete。0x0009200D 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则NdisTimedDataSend。0x0009200F 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则NdisTimedDataHang。0x00092010 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则NdisFilterTimedPauseComplete。0x00092011 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则NdisFilterTimedDataSend。0x00092012 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则NdisFilterTimedDataReceive。0x00093004 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanAssociation。0x00093005 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanConnectionRoaming。0x00093006 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanDisassociation。0x00093101 指向描述违反规则条件的字符串的指针。保留 (未使用的) 保留 (未使用的) 驱动程序违反了 NDIS/WIFI 验证规则WlanAssert。0x00094007 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanTimedAssociation。0x00094008 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanTimedConnectionRoaming。0x00094009 指向描述违反规则条件的字符串的指针。内部规则状态的地址 (！ruleinfo) 的第二个参数。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanTimedConnectRequest。0x00091001到0x0009400C - NDIS DDI 合规性规则冲突参数 1 参数 2 参数 3 参数 4 错误消息的原因0x0009400B 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数(内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanTimedLinkQuality。0x0009400C 指向描述违反规则条件的字符串的指针。！ruleinfo) 的第二个参数(内部规则状态的地址。补充状态的地址 (！ruleinfo) 的第三个参数。驱动程序违反了 NDIS/WIFI 验证规则WlanTimedScan。有关原因的说明，请参阅参数部分中每个代码的说明。 可以使用 ！analyze -v 扩展获取更多信息。仅当驱动程序验证程序已指示监视一个或多个驱动程序时，才会发生此 Bug 检查。 如果不打算使用驱动程序验证程序，则应停用它。 还可以考虑删除导致此问题的驱动程序。如果你是驱动程序编写者，请使用通过此 Bug 检查获取的信息来修复代码中的 Bug。有关驱动程序验证程序的完整详细信息，请参阅 驱动程序验证程序。_POOL_TYPE代码在 Ntddk.h 中枚举。 具体而言， 0 (零) 表示非分页池， 1 (1) 表示分页池。(Windows 8 及更高版本的 Windows) 如果 DDI 符合性检查导致 Bug 检查，请在驱动程序源代码上运行静态驱动程序验证程序，并指定由导致 Bug 检查的参数 1 值) 标识的 DDI 符合性 (规则。 静态驱动程序验证程序可以帮助你在源代码中查找问题的原因。在启用驱动程序验证程序的情况下处理 Bug 检查原因解决方法注解另请参阅", "0xC5": "BUG代码 0xC5：DRIVER_CORRUPTED_EXPOOL\n项目 • 2023/06/20DRIVER_CORRUPTED_EXPOOL Bug 检查 的值为 0x000000C5。 这表示系统尝试访问进程IRQL 过高的无效内存。参数 描述1 引用的内存2 引用时的 IRQL3 0： 读1： 写4 引用内存的地址当 IRQL 过高时，内核尝试访问可分页内存 (或可能完全无效的内存) 。 此问题的最终原因几乎肯定是驱动程序损坏了系统池。在大多数情况下，如果驱动程序损坏的少量分配 (小于 PAGE_SIZE) ，则会导致此 Bug 检查。 较大的分配会导致", "0xC6": "BUG代码 0xC6：DRIVER_CAUGHT_MODIFYING_FREED_POOL\n项目 • 2023/06/20DRIVER_CAUGHT_MODIFYING_FREED_POOL Bug 检查的值为 0x000000C6。 这表示驱动程序尝试访问已释放的内存池。参数 描述1 引用的内存2 0： 读1： 写3 0： 内核模式1： 用户模式4 保留故障组件将显示在当前内核堆栈中。 应替换或调试此驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_CAUGHT_MODIFYING_FREED_POOL参数备注", "0xC7": "BUG代码 0xC7：TIMER_OR_DPC_INVALID\n项目 • 2023/06/20TIMER_OR_DPC_INVALID Bug 检查 的值为 0x000000C7。 如果内核计时器或延迟过程调用 (DPC) 在内存中出现不允许的某个位置，则会发出此错误。参数 1 参数 2 参数 3 参数 4 错误原因0x0 计时器对象的地址正在检查的内存范围的开始正在检查的内存范围的结束计时器对象是在不允许计时器对象的内存块中找到的。 .0x1 DPC 对象的地址正在检查的内存范围的开始正在检查的内存范围的结束DPC 对象是在不允许使用 DPC 对象的内存块中找到的。0x2 DPC 例程的地址正在检查的内存范围的开始正在检查的内存范围的结束DPC 例程是在不允许使用 DPC 对象的内存块中找到的。0x3 DPC 对象的地址处理器编号 系统中的处理器数DPC 对象的处理器编号不正确。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TIMER_OR_DPC_INVALID参数参数 1 参数 2 参数 3 参数 4 错误原因0x4 DPC 例程的地址线程的 APC 在内核调用 DPC例程之前禁用计数调用 DPC 例程后，线程的APC 禁用计数线程的 APC 禁用计数在DPC 例程执行期间已更改。每次驱动程序调用KeEnterCriticalRegion、FsRtlEnterFileSystem 或获取互斥体时，APC 禁用计数都会递减。每次驱动程序调用KeLeaveCriticalRegion、KeReleaseMutex 或FsRtlExitFileSystem 时，APC 禁用计数都会递增。0x5 DPC 例程的地址线程的 APC 在内核调用 DPC例程之前禁用计数调用 DPC 例程后，线程的APC 禁用计数线程的 APC 禁用计数在执行计时器 DPC 例程期间已更改。每次驱动程序调用KeEnterCriticalRegion、FsRtlEnterFileSystem 或获取互斥体时，APC 禁用计数都会递减。每次驱动程序调用KeLeaveCriticalRegion、KeReleaseMutex 或FsRtlExitFileSystem 时，APC 禁用计数都会递增。这种情况通常是由驱动程序在释放计时器或 DPC 之前未能取消计时器或 DPC 所驻留的内存引起的。如果你是驱动程序编写者，请使用通过此 Bug 检查获取的信息来修复代码中的 Bug。如果你是系统管理员，则应在问题仍然存在时卸载驱动程序。原因解决方法", "0xC8": "BUG代码 0xC8：IRQL_UNEXPECTED_VALUE\n项目 • 2023/06/20IRQL_UNEXPECTED_VALUE Bug 检查的值为 0x000000C8。 这表示处理器的 IRQL 目前不是它应该的。参数 说明1 以下位计算的值：(当前 IRQL << 16) | (预期 IRQL << 8)|UniqueValue2 - 依赖于 UniqueValue 如果 UniqueValue 为 0 或 1：APC->KernelRoutine。如果 UniqueValue 为 2：标注例程如果 UniqueValue 为 3：中断的 ServiceRoutine如果 UniqueValue 0xfe：如果禁用 APC，则为 13- 依赖于 UniqueValue 如果 UniqueValue 为 0 或 1：APC如果 UniqueValue 为 2：标注的 参数如果 UniqueValue 为 3：KINTERRUPT4 - 依赖于 UniqueValue 如果 UniqueValue 为 0 或 1：APC->NormalRoutine此错误通常是由设备驱动程序或其他较低级别的程序引起的，该程序在一段时间内更改了IRQL，并在该时间段结束时未还原原始 IRQL。 例如，例程可能已获取旋转锁，但未能释） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。IRQL_UNEXPECTED_VALUE参数原因放它。！analyze 调试扩展显示有关 Bug 检查的信息，在确定根本原因方面非常有用。另请参阅使用 Windows 调试器 (WinDbg) 进行故障转储分析使用 WinDbg 分析内核模式转储文件", "0xC9": "BUG代码 0xC9：DRIVER_VERIFIER_IOMANAGER_VIOLATION\n项目 • 2023/06/15DRIVER_VERIFIER_IOMANAGER_VIOLATION Bug 检查 的值为 0x000000C9。 这是所有驱动程序验证程序 I/O 验证冲突的 Bug 检查代码。当驱动程序验证程序处于活动状态且选择 I/O 验证时，各种 I/O 冲突将导致发出此 Bug检查。 参数 1 标识冲突的类型。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x01 正在释放的IRP 的地址0 0 驱动程序尝试释放其类型不是IO_TYPE_IRP的对象。0x02 正在释放的IRP 的地址0 0 驱动程序尝试释放仍与线程关联的 IRP。0x03 正在发送的IRP 的地址0 0 驱动程序向 IoCallDriver 传递了不等于 IRP_TYPE 的 IRP 类型。0x04 设备对象的地址0 0 驱动程序向 IoCallDriver 传递了无效的设备对象。0x05 与违规驱动程序关联的设备对象的地址IoCallDriver 之前的 IRQLIoCallDriver 之后的 IRQLIRQL 在调用驱动程序调度例程期间发生了更改。0x06 IRP 状态 正在完成的 IRP地址0 名为 IoCompleteRequest 的驱动程序，其状态标记为挂起 (或等于-1) 。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。DRIVER_VERIFIER_IOMANAGER_VIOLATION参数参数 1 参数 2 参数 3 参数 4 错误消息的原因0x07 取消例程的地址正在完成的 IRP地址0 驱动程序调用IoCompleteRequest ，而其取消例程仍处于设置状态。0x08 设备对象的地址IRP 主要函数代码异常状态代码 驱动程序向IoBuildAsynchronousFsdRequest传递了无效缓冲区。0x09 设备对象的地址I/O 控制代码 异常状态代码 驱动程序传递了IoBuildDeviceIoControlRequest无效缓冲区。0x10 当前 IRQL 预留 预留 DISPATCH_LEVEL上面调用了IoCallDriver。0x11 驱动程序快速 I/O 调度例程地址调用驱动程序调度例程之前的 IRQL当前 IRQL DISPATCH_LEVEL上面调用了IoCallDriver。0x12 驱动程序调度例程地址调用驱动程序调度例程之前的 IRQL当前 IRQL DISPATCH_LEVEL上面调用了IoCallDriver。0x0A 设备对象的地址0 0 驱动程序向 IoInitializeTimer 传递了具有已初始化计时器的设备对象。0x0C I/O 状态块的地址0 0 驱动程序已将 I/O 状态块传递给IRP，但此块在已取消转换的堆栈上分配。0x0D 用户事件对象的地址0 0 驱动程序将用户事件传递给 IRP，但此事件在已超过该点的堆栈上分配。0x0E 当前 IRQL IRP 地址 0 名为 IoCompleteRequest 的驱动程序与 IRQL >DISPATCH_LEVEL。0x0F IRP 要发送到的设备对象的地址指向 IRP 的指针指向文件对象的指针驱动程序发送了一个创建请求，其中包含已关闭或已取消其打开的文件对象。除了上表中提到的错误外，还有许多 I/O 验证 错误会导致驱动程序验证程序停止系统，但实际上不是 Bug 检查。这些错误会导致消息显示在蓝屏、故障转储文件和内核调试器中。 这些消息在每个位置的显示方式都不同。 发生这些错误时，十六进制 Bug 检查代码0xC9，Bug 检查字符串DRIVER_VERIFIER_IOMANAGER_VIOLATION不会出现在蓝屏或调试器中，尽管它们将显示在故障转储文件中。在蓝屏上，将显示以下数据：消息 IO 系统验证错误。消息 WDM DRIVER ERRORXXX，其中 XXX 是表示特定错误的十六进制代码。 (有关 I/O 错误代码及其含义的列表，请参阅下表。)导致错误的驱动程序的名称。通常，驱动程序代码中检测到错误的地址 (参数 2) 。如果已启用内核模式故障转储，则故障转储文件中将显示以下信息：消息 BugCheck 0xC9 (DRIVER_VERIFIER_IOMANAGER_VIOLATION) 。十六进制 I/O 错误代码。 (有关 I/O 错误代码及其含义的列表，请参阅下表。)通常，驱动程序代码中检测到错误的地址 (参数 2) 。如果内核调试器附加到导致此冲突的系统，则会将以下信息发送到调试器：消息 WDM DRIVER ERROR，以及错误严重性的评估。导致错误的驱动程序的名称。说明此错误原因的描述性字符串。 通常传递其他信息，例如指向 IRP 的指针或指向设备对象或 IRQL 信息的指针。 (有关这些描述性字符串的列表以及指定了哪些其他信息，请参阅下表。)进一步操作的查询。 可能的响应包括 b (break) 、 i (ignore) 、 z (zap) 、 r (remove)或 d (disable) 。 通过指示操作系统继续操作，你可以查看未发生此错误时“下行”会发生什么情况。 当然，这通常会导致额外的 Bug 检查。 “zap”选项实际上会删除导致发现此错误的断点。注意 不能以这种方式忽略任何其他 Bug 检查。 只能忽略此类 I/O 验证 错误，即使这些错误也只能在附加内核调试器时被忽略。下表列出了可能出现的 I/O 验证 错误。I/O 错误代码 严重性 错误消息的原因0x200 未知 此代码涵盖所有未知 的 I/O 验证 错误。I/O 错误代码 严重性 错误消息的原因0x201 Fatal error 设备正在删除自身，而驱动程序堆栈中下有另一个设备。 这可能是因为调用方忘记先调用 IoDetachDevice ，或者较低的驱动程序可能已错误地删除了自身。参数 2 - 驱动程序代码中检测到错误的地址。0x202 Fatal error 驱动程序尝试从未附加到任何对象的设备对象分离。 如果在同一设备对象上调用分离两次，则可能会发生这种情况。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - 设备对象地址。0x203 Fatal error 驱动程序调用 了 IoCallDriver， 但没有将IRP 中的取消例程设置为 NULL。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x204 Fatal error 调用方已传入 NULL 作为设备对象。 这是致命的。参数 2 - 保留参数 3 - 保留0x205 Fatal error 调用方正在转发当前正在其下排队的IRP。 处理此驱动程序中返回STATUS_PENDING的 IRP 的代码似乎已损坏。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x206 Fatal error 调用方错误地转发了 IRP (控件字段未归零) 。 驱动程序应使用IoCopyCurrentIrpStackLocationToNext或 IoSkipCurrentIrpStackLocation。参数 2 - 保留参数 3 - 保留I/O 错误代码 严重性 错误消息的原因0x207 Fatal error 调用方手动复制堆栈，无意中复制了上层的完成例程。 驱动程序应使用IoCopyCurrentIrpStackLocationToNext。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x208 Fatal error 此 IRP 即将耗尽堆栈位置。 可能有人从另一个堆栈转发了此 IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x209 Fatal error 调用方正在完成当前在 IRP 下排队的IRP。 处理此驱动程序中返回STATUS_PENDING的 IRP 的代码似乎已损坏。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x20A Fatal error IoFreeIrp 的调用方正在释放仍在使用的IRP。参数 2 - 保留参数 3 - 保留0x20B Fatal error IoFreeIrp 的调用方正在释放仍在使用的IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x20C Fatal error IoFreeIrp 的调用方正在释放仍针对线程排队的 IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x20D Fatal error IoInitializeIrp 的调用方传递了使用IoAllocateIrp 分配的 IRP。 这是非法和不必要的，并已导致配额泄漏。 如果正在回收此 IRP，请查看 IoReuseIrp 的文档。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x20E 非致命错误 PNP IRP 的状态无效。 (任何 PNP IRP 都必须将其状态初始化为STATUS_NOT_SUPPORTED.)参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x20F 非致命错误 Power IRP 的状态无效。 (任何 Power IRP都必须将其状态初始化为STATUS_NOT_SUPPORTED.)参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x210 非致命错误 WMI IRP 的状态无效。 (任何 WMI IRP 都必须将其状态初始化为STATUS_NOT_SUPPORTED.)参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x211 非致命错误 调用方在跳过堆栈中的设备对象时转发了IRP。 调用方可能正在向 PDO 而不是IoAttachDeviceToDeviceStack 返回的设备发送 IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x212 非致命错误 调用方已回收或未正确复制 IRP 的堆栈。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x213 非致命错误 调用方更改了它无法理解的 IRP 的状态字段。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x214 非致命错误 调用方更改了它无法理解的 IRP 的信息字段。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x215 非致命错误 IRP_MJ_PNP的非成功非STATUS_NOT_SUPPORTED IRP 状态正在向下传递堆栈。 必须完成失败的 PNPIRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x216 非致命错误 以前设置的IRP_MJ_PNP状态已转换为STATUS_NOT_SUPPORTED。 此失败状态保留供操作系统使用。 驱动程序无法使用此值使 PnP IRP 失败。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x217 非致命错误 驱动程序未处理所需的 IRP。 驱动程序必须更新 IRP 的状态，以指示是否已处理它。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x218 非致命错误 驱动程序已响应为堆栈中其他位置的其他设备对象保留的 IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x219 非致命错误 正在向下传递IRP_MJ_POWER的不成功非STATUS_NOT_SUPPORTED IRP 状态。 必须完成失败的 POWER IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x21A 非致命错误 以前设置的IRP_MJ_POWER状态已转换为STATUS_NOT_SUPPORTED。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x21B 非致命错误 驱动程序返回了可疑状态。 这可能是由于驱动程序中未初始化的变量 Bug 造成的。参数 3 - IRP 地址。0x21C 警告 调用方已复制 IRP 堆栈，但未设置完成例程。 这效率低下 -- 改用IoSkipCurrentIrpStackLocation 。参数 2 - 保留参数 3 - 保留0x21D Fatal error 收到删除 IRP 后，IRP 调度处理程序未从其下面的堆栈正确分离。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。I/O 错误代码 严重性 错误消息的原因0x21E Fatal error IRP 调度处理程序在收到删除 IRP 时未正确删除其设备对象。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。0x21F 非致命错误 驱动程序尚未为所需的 IRP 主要函数填写调度例程。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x220 非致命错误 IRP_MJ_SYSTEM_CONTROL已由ProviderId 以外的人完成。 此 IRP 应已提前完成，或者应已传递。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - ProviderId。0x221 Fatal error PDO 的 IRP 调度处理程序已删除其设备对象，但尚未在总线关系查询中报告硬件缺失。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。0x222 Fatal error 当 PDO 仍处于活动状态时，总线筛选器的 IRP 调度处理程序在收到删除 IRP 时分离。 总线筛选器必须在 FastIoDetach 回调中清理。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。I/O 错误代码 严重性 错误消息的原因0x223 Fatal error 总线筛选器的 IRP 调度处理程序已删除其设备对象，但 PDO 仍然存在。 总线筛选器必须在 FastIoDetach 回调中清理。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。0x224 Fatal error IRP 调度处理程序返回的状态与 IRP 的IoStatus.Status 字段不一致。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 预期状态代码。0x225 非致命错误 IRP 调度处理程序返回的状态为非法(0xFFFFFFFF) 。 这可能是由于未初始化的堆栈变量造成的。 若要调试此错误，请使用具有指定地址的 ln (List NearestSymbols) 命令。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 状态代码。0x226 Fatal error IRP 调度处理程序返回时未传递或完成此IRP，或者有人忘记返回STATUS_PENDING。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x227 Fatal error IRP 完成例程位于可分页代码中。 (绝不允许此操作。)参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x228 非致命错误 如果在传递给它的 IRP 中设置了PendingReturned 字段，则驱动程序的完成例程未将 IRP 标记为挂起。 这可能会导致 Windows 挂起，尤其是在堆栈返回错误时。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x229 Fatal error 已为当前由堆栈中较低层的驱动程序处理的 IRP 设置了取消例程，这可能会破坏其取消例程。参数 2 - 保留。参数 3 - 保留。0x22A 非致命错误 PDO) (物理设备对象尚未响应所需的IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x22B 非致命错误 物理设备对象 (PDO) 忘记使用TargetDeviceRelation 查询的 PDO 填写设备关系列表。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x22C Fatal error 实现 TargetDeviceRelation 查询的代码未在 PDO 上调用 ObReferenceObject 。参数 2 - 保留。参数 3 - 保留。0x22D 非致命错误 调用方已完成一个IRP_MJ_PNP它无法理解，而不是传递它。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x22E 非致命错误 调用方已完成成功的IRP_MJ_PNP，而不是向下传递。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x22F 非致命错误 调用方已完成未受影响IRP_MJ_PNP (而不是将 IRP 向下传递) ，或者非 PDO 使用非法值STATUS_NOT_SUPPORTED使 IRP 失败。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x230 非致命错误 调用方已完成其无法理解的IRP_MJ_POWER，而不是将其传递。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x231 Fatal error 调用方已完成成功的IRP_MJ_POWER，而不是向下传递。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x232 非致命错误 调用方已完成未受影响IRP_MJ_POWER (，而不是将 IRP 向下传递) ，或者非 PDO 使用非法值STATUS_NOT_SUPPORTED使 IRP失败。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x233 非致命错误 查询功能 IRP 中查询功能结构的版本字段未正确初始化。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x234 非致命错误 查询功能 IRP 中查询功能结构的大小字段未正确初始化。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x235 非致命错误 查询功能 IRP 中查询功能结构的地址字段未正确初始化为 -1。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x236 非致命错误 查询功能 IRP 中查询功能结构的 UINumber 字段未正确初始化为 -1。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x237 Fatal error 驱动程序发送了仅限系统使用的 IRP。参数 2 - 保留。参数 3 - 保留。0x238 警告 IoInitializeIrp 的调用方已通过IoAllocateIrp 分配的 IRP。 这是非法的、不必要的，并且会对正常使用的性能产生负面影响。 如果正在回收此 IRP，请参阅Windows 驱动程序工具包中的IoReuseIrp 。参数 2 - 保留。参数 3 - 保留。0x239 警告 IoCompleteRequest 的调用方正在完成从未通过调用 IoCallDriver 或 PoCallDriver转发的 IRP。 这可能是一个 Bug。参数 2 - 保留。参数 3 - 保留。I/O 错误代码 严重性 错误消息的原因0x23A Fatal error 驱动程序转发了 IRQL 中的 IRP，该 IRP 对于此主要代码是非法的。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x23B 非致命错误 调用方已更改它无法理解的 IRP 的状态字段。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。下表列出了可能出现的其他 I/O 验证 错误。 激活 增强型 I/O 验证 时会出现这些错误。有关详细信息，请参阅 增强型 I/O 验证。I/O 错误代码 严重性 错误消息的原因0x23C Fatal error 驱动程序已完成 IRP，但未将 IRP 中的取消例程设置为 NULL。参数 2 - 保留。参数 3 - 保留。0x23D 非致命错误 驱动程序已返回STATUS_PENDING但未通过调用 IoMarkIrpPending 将IRP 标记为挂起。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 状态代码。0x23E 非致命错误 驱动程序已将 IRP 标记为挂起，但没有返回STATUS_PENDING。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 状态代码。I/O 错误代码 严重性 错误消息的原因0x23F Fatal error 驱动程序尚未从它附加到的堆栈继承DO_POWER_PAGABLE位。参数 2 - 保留。参数 3 - 保留。0x240 Fatal error 驱动程序正在尝试删除已通过先前调用 IoDeleteDevice 删除的设备对象。参数 2 - 驱动程序代码中检测到错误的地址。参数 2 - 保留。参数 3 - 保留。0x241 Fatal error 驱动程序在意外删除 IRP 期间分离了其设备对象。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。0x242 Fatal error 驱动程序在意外删除 IRP 期间删除了其设备对象。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。0x243 Fatal error 驱动程序未能清除 AddDevice 末尾的DO_DEVICE_INITIALIZING标志。参数 2 - 保留。参数 3 - 保留。参数 4 -I/O 错误代码 严重性 错误消息的原因0x244 Fatal error 驱动程序尚未从其附加到的设备对象复制DO_BUFFERED_IO或DO_DIRECT_IO标志。参数 2 - 保留。参数 3 - 保留。0x245 Fatal error 驱动程序已设置DO_BUFFERED_IO和DO_DIRECT_IO标志。 这些标志互斥。参数 2 - 保留。参数 3 - 保留。0x246 Fatal error 驱动程序无法从要附加到的设备对象复制 DeviceType 字段。参数 2 - 保留。参数 3 - 保留。0x247 Fatal error参数 2 - 保留。参数 3 - 保留。驱动程序已使无法合法失败的 IRP 失败。0x248 Fatal error 驱动程序已将不是 PDO 的设备对象添加到了设备关系查询。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。0x249 非致命错误 驱动程序枚举了返回相同设备 ID 的两个子 PDO。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - 第一个设备对象地址。参数 4 - 第二个设备对象地址。I/O 错误代码 严重性 错误消息的原因0x24A Fatal error 驱动程序错误地调用了 IRQL 不等于PASSIVE_LEVEL 的文件 I/O 函数。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - 保留。参数 4 - 保留。0x24B Fatal error 驱动程序已成功完成TargetDeviceRelation 类型的IRP_MN_QUERY_DEVICE_RELATIONS请求，但未正确填写请求或将 IRP 转发到基础硬件堆栈。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - 设备对象地址。0x24C 非致命错误 驱动程序已返回STATUS_PENDING但未通过调用 IoMarkIrpPending 将IRP 标记为挂起。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 状态代码。0x24D Fatal error 驱动程序已将无效设备对象传递给需要 PDO 的函数。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 设备对象地址。I/O 错误代码 严重性 错误消息的原因0x300 非致命错误 驱动程序返回了可疑状态。 这可能是由于驱动程序中未初始化的变量Bug 造成的。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 可疑状态代码。0x301 非致命错误 驱动程序已在 IRQL >DISPATCH_LEVEL转发 IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - IRQL 值不正确0x302 非致命错误 驱动程序已在 IRQL > = APC_LEVEL转发 IRP。I/O 管理器需要将 APC 排队才能完成此请求。 APC 将无法运行，因为调用方已在 APC 级别，因此调用方可能会死锁。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。参数 4 - 错误的 IRQL 值。0x306 非致命错误 驱动程序正在完成IRP_MJ_PNP (主)，IRP_MN_REMOVE_DEVICE (具有失败状态代码的次要) 请求。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。I/O 错误代码 严重性 错误消息的原因0x307 非致命错误 驱动程序发出 I/O 请求，其中包含已发出信号并收到STATUS_PENDING响应的事件。 这可能会导致在 I/O 完成之前展开。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x310 非致命错误 驱动程序正在重新初始化仍在使用的IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x311 非致命错误 驱动程序正在重新初始化使用IoMakeAssociatedIrp、IoBuildAsynchronousFsdRequest、IoBuildSynchronousFsdRequest、IoBuildDeviceIoControlRequest 创建的 IRP。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。0x312 非致命错误 调用方为 IRP 状态信息字段提供的值大于系统缓冲区的输出部分。参数 2 - 驱动程序代码中检测到错误的地址。参数 3 - IRP 地址。有关原因的说明，请参阅参数部分中每个代码的说明。仅当驱动程序验证程序已指示监视一个或多个驱动程序时，才会发生此 Bug 检查。 如果不打算使用驱动程序验证程序，则应停用它。 有关详细信息，请参阅驱动程序验证程序原因解决方法中的“如何控制 驱动程序验证程序”。 你也可以考虑更新或删除导致此问题的驱动程序。如果你是驱动程序开发人员，请使用通过此 Bug 检查获取的信息来修复代码中的 Bug。有关驱动程序验证程序的完整详细信息，请参阅 驱动程序验证程序。", "0xCA": "BUG代码 0xCA：PNP_DETECTED_FATAL_ERROR\n项目 • 2023/06/20PNP_DETECTED_FATAL_ERROR Bug 检查 值为 0x000000CA。 这表示即插即用管理器遇到严重错误，可能是由于即插即用驱动程序出现问题。参数 1 标识冲突的类型。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x1 新报告的 PDO 的地址 已复制的旧 PDO 的地址保留 重复的 PDO： 驱动程序的特定实例枚举了具有相同设备 ID 和唯一 ID 的多个PDO。0x2 据称的 PDO 的地址 驱动程序对象的地址保留 PDO 无效： 需要 PDO 的API 已使用随机内存、FDO或尚未初始化的 PDO 调用。(未初始化的 PDO 是QueryDeviceRelation 或QueryBusRelations.即插即用 )0x3 已查询其 ID 的 PDO 的地址ID 缓冲区的地址1： DeviceID2： UniqueID3：HardwareIDs4：CompatibleIDsID 无效： 枚举器返回了包含非法字符或未正确终止的ID。 (ID 必须仅包含0x200x2B和0x2D - 0x7F.)） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PNP_DETECTED_FATAL_ERROR参数参数 1 参数 2 参数 3 参数 4 错误消息的原因0x4 设置了DOE_DELETE_PENDING的 PDO 地址预留 预留 已删除 PDO 的枚举无效：枚举器返回了它以前使用IoDeleteDevice 删除的PDO。0x5 PDO 的地址 预留 预留 在开发节点树中链接时释放PDO：当开发节点仍在树中链接时，PDO 上的对象管理器引用计数下降到零。(这通常表示驱动程序在查询 IRP.)0x8 其堆栈返回无效总线关系的 PDO 的地址作为总线关系返回的 PDO 总数索引 (从零开始)找到第一个NULL PDO作为总线关系返回的 NULL指针： 总线上存在的一个或多个设备是 NULLPDO。0x9 传递的连接类型 预留 预留 传递给IoDisconnectInterruptEx的连接类型无效： 驱动程序已将无效的连接类型传递给IoDisconnectInterruptEx。传递给此例程的连接类型必须与对IoConnectInterruptEx 的相应成功调用返回的连接类型匹配。0xA 驱动程序对象 从驱动程序回调返回后的IRQL合并的 APC 在从驱动程序回调返回后禁用计数不正确的通知回调行为：驱动程序无法保留 IRQL 或组合的 APC 禁用“n”播放通知的计数。0xB 相关 PDO 删除关系 保留 已删除的 PDO 报告为关系： 已删除的设备的删除关系之一。", "0xCB": "BUG代码 0xCB：DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS\n项目 • 2023/06/20DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS Bug 检查 的值为 0x000000CB。 这表示驱动程序或 I/O 管理器在 I/O 操作后未能释放锁定的页面。参数 描述1 内部锁跟踪结构的地址。2 0 (保留)3 包含锁定页的 MDL 的地址。4 锁定页数有关内存描述符列表的详细信息，请参阅以下主题：使用 MDLwdm.h) (MDL 结构有关锁定内存的详细信息，请参阅 锁定可分页代码或数据。若要研究此 Bug 检查的原因，请使用 ！lockedpages 调试器扩展显示当前进程的所有锁定的 MDL。仅当注册表值等于 DWORD 1 时，才会发出此 Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS 参数备注\\\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SessionManager\\Memory Management\\TrackLockedPages如果未设置此值，系统将发出信息较少的", "0xCC": "BUG代码 0xCC：PAGE_FAULT_IN_FREED_SPECIAL_POOL\n项目 • 2023/06/20PAGE_FAULT_IN_FREED_SPECIAL_POOL Bug 检查 的值为 0x000000CC。 这表示系统引用了先前释放的内存。参数 描述1 引用的内存地址2 0： 读1： 写3 引用内存的地址（如果已知）4 保留如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中kiBugCheckDriver (PUNICODE_STRING) 位置。驱动程序验证程序特殊池选项已捕获系统访问先前释放的内存。 这通常表示存在系统驱动程序同步问题。有关特殊池的信息，请参阅 Windows 驱动程序工具包的驱动程序验证程序部分。这不能通过 try（处理程序除外 ）进行保护，只能由探测保护。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PAGE_FAULT_IN_FREED_SPECIAL_POOL参数原因备注", "0xCD": "BUG代码 0xCD：PAGE_FAULT_BEYOND_END_OF_ALLOCATION\n项目 • 2023/06/20PAGE_FAULT_BEYOND_END_OF_ALLOCATION Bug 检查 的值为 0x000000CD。 这表示系统访问了某些驱动程序池分配结束之后的内存。参数 描述1 引用的内存地址2 0： 读1： 写3 引用内存的地址（如果已知）4 保留如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中kiBugCheckDriver (PUNICODE_STRING) 位置。驱动程序从特殊池中分配了 n 个字节的内存。 随后，系统从此池引用了超过 n 个 字节。这通常表示存在系统驱动程序同步问题。有关特殊池的信息，请参阅 Windows 驱动程序工具包的驱动程序验证程序部分。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PAGE_FAULT_BEYOND_END_OF_ALLOCATION参数原因备注这不能通过 try（处理程序除外 ）进行保护，只能由探测保护。", "0xCE": "BUG代码 0xCE：DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS\n项目 • 2023/06/22DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS Bug 检查 的值为 0x000000CE。 这表示驱动程序在卸载之前未能取消挂起的操作。参数 说明1 引用的内存地址2 0： 读1： 写3 引用内存的地址（如果已知）4 保留如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中 kiBugCheckDriver(PUNICODE_STRING) 位置。此驱动程序在卸载之前未能取消查看列表、DPC、工作线程或其他此类项。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS参数原因解决方法0xCE:DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS\n\n问题原因：\n\n第三方软件缺陷\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xCF": "BUG代码 0xCF：TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE\n项目 • 2023/06/20TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE Bug 检查 的值为 0x000000CF。 这表示驱动程序已错误地移植到终端服务器。参数 描述1 引用的内存地址2 0： 读1： 写3 引用内存的地址（如果已知）4 保留如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中 kiBugCheckDriver (PUNICODE_STRING)位置。驱动程序从系统进程上下文中引用会话空间地址。 这可能是由于驱动程序将项排队到系统工作线程的结果。此驱动程序需要符合终端服务器的内存管理规则。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE参数原因", "0xD0": "BUG代码 0xD0：DRIVER_CORRUPTED_MMPOOL\n项目 • 2023/06/20DRIVER_CORRUPTED_MMPOOL Bug 检查 的值为 0x000000D0。 这表示系统尝试访问进程 IRQL 过高的无效内存。参数 描述1 引用的内存2 引用时的 IRQL3 0： 读1： 写4 引用内存的地址当 IRQL 过高时，内核尝试访问可分页内存 (或可能完全无效的内存) 。 此问题的最终原因几乎肯定是驱动程序损坏了系统池。在大多数情况下，如果驱动程序损坏了大型分配 (PAGE_SIZE或更大的) ，则检查此 Bug。较小的分配会导致", "0xD1": "BUG代码 0xD1：DRIVER_IRQL_NOT_LESS_OR_EQUAL\n项目 • 2023/06/15DRIVER_IRQL_NOT_LESS_OR_EQUAL Bug 检查 的值为 0x000000D1。 这表示内核模式驱动程序在进程 IRQL 过高时尝试访问可分页内存。参数 说明1 引用的内存。2 引用时 IRQL。3 0 - 读取1 - 写入2 - 执行8 - 执行4 引用内存的地址。 使用 ln (列出此地址上) 最近的符号 以查看函数的名称。若要确定原因，需要 Windows 调试器、编程经验和对故障模块源代码的访问权限。通常，发生此错误时，驱动程序尝试访问可分页 (地址或) 完全无效的地址，而中断请求级别 (IRQL) 过高。 这可能是由于：在 DISPATCH_LEVEL 或更高级别执行时，取消引用错误指针（例如 NULL 或释放的指针）。在 DISPATCH_LEVEL 或更高级别访问可分页数据。在 DISPATCH_LEVEL 或更高级别执行可分页代码。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。DRIVER_IRQL_NOT_LESS_OR_EQUAL参数原因如果可以识别出导致错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中KiBugCheckDriver (PUNICODE_STRING) 位置。 可以使用 dx (显示调试器对象模型表达式) （调试器命令）来显示此对象： dx KiBugCheckDriver。此 Bug 检查通常是由使用不正确的内存地址的驱动程序引起的。页面错误的可能原因包括以下事件：函数标记为可分页，并在提升的 IRQL (运行，其中包括获取锁) 。函数调用是向另一个驱动程序中的函数进行的，并且该驱动程序已卸载。该函数是使用作为无效指针的函数指针调用的。有关 Windows IRQL 的详细信息，请参阅由 Pavel Yosifovich、Mark E. Russinovich、David A. Solomon 和 Alex Ionescu 撰写的 Windows Internals 第 7 版第 1 部分 。如果问题是由你正在开发的驱动程序引起的，请确保在出现 Bug 时执行的函数检查为：未标记为可分页不调用任何其他可以分页的内联函数。!analyze 调试程序扩展显示有关 Bug 检查的信息，有助于确定根本原因。 下面的示例是!analyze 的输出。dbgcmd如果可以识别出导致错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中KiBugCheckDriver (PUNICODE_STRING) 位置。 可以使用一个调试器命令 dx（显示调试器对象模型表达式）来显示此内容：dx KiBugCheckDriver。dbgcmd解决方法DRIVER_IRQL_NOT_LESS_OR_EQUAL (d1)An attempt was made to access a pageable (or completely invalid) address ataninterrupt request level (IRQL) that is too high. This is usuallycaused by drivers using improper addresses.If kernel deBugger is available get stack backtrace.Arguments:Arg1: fffff808add27150, memory referencedArg2: 0000000000000002, IRQLArg3: 0000000000000000, value 0 = read operation, 1 = write operationArg4: fffff808adc386a6, address which referenced memory0: kd> dx KiBugCheckDriverKiBugCheckDriver : 0xffffc6092de892c8 : \"Wdf01000.sys\"[Type: _UNICODE_STRING *]如果转储文件中提供了陷阱帧，请使用 .trap 命令将上下文设置为提供的地址。若要开始调试此类 Bug 检查，请使用 k、kb、kc、kd、kp、kP、kv (显示堆栈回溯) 命令来检查堆栈跟踪。在调试器中，运行 ！irql 命令，在调试器中断之前显示有关目标计算机上处理器 IRQL 的信息。 例如：dbgcmd0: kd> !irqlDeBugger saved IRQL for processor 0x0 -- 2 (DISPATCH_LEVEL)在大多数此类 Bug 检查的情况下，问题不在于 IRQL 级别，而在于正在访问的内存。由于此 Bug 检查通常是由使用不正确内存地址的驱动程序引起的，因此请使用参数 1、3和 4 进一步调查。使用 ln (列出参数 4) 最近的符号 以查看调用的函数的名称。 此外，检查 ！analyze 输出以查看是否已识别出错误代码。使用参数 1 地址上的 ！pool 查看它是否为分页池。 使用 ！address 和高级 ！pte 命令了解有关此内存区域的详细信息。使用 显示内存 命令检查参数 1 中的命令中引用的内存。使用 u、 ub、 uu (unassemble) 命令查看引用参数 4 中内存的地址中的代码。使用 命令 lm t n 列出内存中加载的模块。 使用 ！memusage 和 检查系统内存的一般状态。驱动程序验证程序驱动程序验证程序是一个实时运行的工具，用于检查驱动程序的行为。 例如，驱动程序验证程序检查内存资源（如内存池）的使用。 如果在执行驱动程序代码时标识错误，它会主动创建一个异常，以允许进一步检查该部分驱动程序代码。 驱动程序验证程序管理器内置于 Windows 中，可在所有 Windows 电脑上使用。若要启动驱动程序验证程序管理器，请在命令提示符下键入 验证程序 。 你可以配置要验证的驱动程序。 验证驱动程序的代码在运行时会增加开销，因此请尝试验证尽可能少的驱动程序。 有关详细信息，请参阅驱动程序验证程序。备注如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。在系统登录事件查看器中查看其他错误消息，这些错误消息可能有助于识别导致此Bug 的设备或驱动程序检查。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以在Windows10规范 中获取有关所需硬件的信息。有关其他常规疑难解答信息，请参阅蓝屏数据。0xD1:DRIVER_IRQL_NOT_LESS_OR_EQUAL\n\n问题原因：\n\n第三方软件缺陷\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xD2": "BUG代码 0xD2：BugCODE_ID_DRIVER\n项目 • 2023/06/15BugCODE_ID_DRIVER Bug 检查 的值为 0x000000D2。 这表示 NDIS 驱动程序出现问题。参数 1 参数 2 参数 3 参数4消息和原因微型端口块的地址请求的字节数 0 1 在引发的 IRQL 处分配共享内存。 名为NdisMAllocateSharedMemory且 IRQL >= DISPATCH_LEVEL的驱动程序。微型端口块的地址提交到NdisMResetComplete的状态值提交到NdisMResetComplete的 AddressingReset 值0 在一个未挂起时完成重置。 名为NdisMResetComplete 的驱动程序，但未挂起任何重置。微型端口块的地址包含正在释放的地址的内存页共享内存签名的地址 正在释放的虚拟地址释放未分配的共享内存。 名为NdisMFreeSharedMemory 或NdisMFreeSharedMemoryAsync的驱动程序，其地址不在 NDIS共享内存中。微型端口块的地址数据包数组中错误包含的数据包的地址数据包数组的地址 数组中的数据包数指示数据包不归其所有。 微型端口的数据包阵列已损坏。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。BugCODE_ID_DRIVER参数参数 1 参数 2 参数 3 参数4消息和原因MiniBlock的地址驱动程序对象的地址 0 0 NdisAddDevice：使用不在NdisMiniDriverList 上的MiniBlock 调用的 AddDevice。MiniBlock的地址MiniBlock 的引用计数 0 0 NdisMUnload：MiniBlock 正在卸载，但它仍在NdisMiniDriverList 上。微型端口块的地址内存页 包装器上下文 共享内存签名的地址覆盖已分配的共享内存。 要写入的地址不位于 NDIS 共享内存中。在此 Bug 检查的以下实例中，参数的含义取决于消息和参数 4 的值。参数 1 参数 2 参数 3 参数 4 消息和原因微型端口块的地址微型端口中断的地址微型端口计时器队列的地址1 在不取消注册中断的情况下卸载。 微型端口驱动程序初始化失败，但未取消注册其中断。微型端口块的地址微型端口计时器队列的地址微型端口中断的地址2 在不取消注册中断的情况下卸载。 微型端口驱动程序未在停止过程中取消注册其中断。微型端口块的地址微型端口中断的地址微型端口计时器队列的地址1 在不取消注册计时器的情况下卸载。 微型端口驱动程序初始化失败，但未成功取消其所有计时器。参数 1 参数 2 参数 3 参数 4 消息和原因微型端口块的地址微型端口计时器队列的地址微型端口中断的地址2 在不取消注册计时器的情况下卸载。 微型端口驱动程序停止，但未成功取消其所有计时器。此 Bug 检查代码仅在 Windows 2000 和 Windows XP 上出现。 在 Windows Server 2003及更高版本中，相应的代码是 (BugCODE_NDIS_DRIVER) 检查 0x7C Bug。在已检查的 Windows 版本中，仅此 Bug 检查实例的分配“已引发 IRQL”和“完成重置时完成重置”。", "0xD3": "BUG代码 0xD3：DRIVER_PORTION_MUST_BE_NONPAGED\n项目 • 2023/06/20DRIVER_PORTION_MUST_BE_NONPAGED Bug 检查 的值为 0x000000D3。 这表示系统尝试访问进程 IRQL 过高的可分页内存。参数 描述1 引用的内存2 引用时 IRQL3 0： 读1： 写4 引用内存的地址如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中kiBugCheckDriver (PUNICODE_STRING) 位置。此 Bug 检查通常是由驱动程序错误地将自己的代码或数据标记为可分页的驱动程序引起的。若要开始调试，请使用内核调试器获取堆栈跟踪：！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因，然后使用 kb (Display Stack Backtrace) 命令获取堆栈跟） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_PORTION_MUST_BE_NONPAGED参数原因解决方法踪。", "0xD4": "BUG代码 0xD4：SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD\n项目 • 2023/06/20SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD Bug 检查 的值为 0x000000D4。 这表示驱动程序在卸载之前未取消挂起的操作。参数 描述1 引用的内存2 引用时 IRQL3 0： 读1： 写4 引用内存的地址如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中 kiBugCheckDriver (PUNICODE_STRING) 位置。此驱动程序在卸载之前未能取消查看列表、DPC、工作线程或其他此类项。 随后，系统尝试在引发的 IRQL 中访问驱动程序的前一个位置。若要开始调试，请使用内核调试器获取堆栈跟踪：！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因，然后使用 kb (Display Stack Backtrace) 命令获取堆栈跟踪。 如果已确定导致错误的驱动程序，请激活驱动程序验证程序并尝试复制此 Bug。有关 驱动程序验证程序的完整详细信息，请参阅 Windows 驱动程序工具包。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD参数原因解决方法0xD4:SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD\n\n问题原因：\n\n第三方软件缺陷\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xD5": "BUG代码 0xD5：DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL\n项目 • 2023/06/20DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL Bug 检查 的值为 0x000000D5。 这表示驱动程序引用了先前释放的内存。参数 描述1 引用的内存地址2 0： 读1： 写3 引用内存的地址（如果已知）4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 如果可以识别出负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中 kiBugCheckDriver(PUNICODE_STRING) 位置。驱动程序验证程序 特殊池 选项捕获了驱动程序访问先前释放的内存。有关特殊池的信息，请参阅 Windows 驱动程序工具包的驱动程序验证程序部分。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL参数原因备注这不能通过 try（处理程序除外 ）进行保护，只能由探测保护。", "0xD6": "BUG代码 0xD6：DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION\n项目 • 2023/06/20DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION Bug 检查 的值为 0x000000D6。 这表示驱动程序访问了超出其池分配末尾的内存。参数 描述1 引用的内存地址2 0： 读1： 写3 引用内存的地址（如果已知）4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 如果可以识别负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中 kiBugCheckDriver(PUNICODE_STRING) 位置。驱动程序分配了 n 个字节的内存，然后引用 了 n 个 以上的字节。 驱动程序验证程序 特殊池选项检测到此冲突。有关特殊池的信息，请参阅 Windows 驱动程序工具包的驱动程序验证程序部分。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION参数原因备注这不能通过 try（处理程序除外 ）进行保护，只能由探测保护。", "0xD7": "BUG代码 0xD7：DRIVER_UNMAPPING_INVALID_VIEW\n项目 • 2023/06/20DRIVER_UNMAPPING_INVALID_VIEW Bug 检查 值为 0x000000D7。 这表示驱动程序正在尝试取消映射未映射的地址。参数 描述1 要取消映射的虚拟地址2 1： 视图正在取消映射2： 正在提交视图3 04 0!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 使用 kb (显示堆栈回溯) 命令获取堆栈跟踪：可从堆栈跟踪确定导致错误的驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_UNMAPPING_INVALID_VIEW参数备注", "0xD8": "BUG代码 0xD8：DRIVER_USED_EXCESSIVE_PTES\n项目 • 2023/06/20DRIVER_USED_EXCESSIVE_PTES Bug 检查 的值为 0x000000D8。 这表示没有更多的系统页表条目 (PTE) 剩余。参数 描述1 指向导致错误 (Unicode 字符串) 或零的驱动程序名称的指针2 如果参数 1 为非零) ，则驱动程序使用的导致错误的 PTE 数 (3 可用系统 PTE 总数4 系统 PTE 总数如果可以识别负责错误的驱动程序，则其名称将打印在蓝屏上，并存储在 内存中kiBugCheckDriver (PUNICODE_STRING) 位置。这通常是由驱动程序未正确清理其内存使用导致的。 参数 1 显示消耗了最多 PTE 的驱动程序。 调用堆栈会显示实际导致 Bug 检查的驱动程序。这两个驱动程序可能需要修复。 系统 PTE 的总数可能还需要增加。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_USED_EXCESSIVE_PTES参数原因解决方法", "0xD9": "BUG代码 0xD9：LOCKED_PAGES_TRACKER_CORRUPTION\n项目 • 2023/06/20LOCKED_PAGES_TRACKER_CORRUPTION Bug 检查 的值为 0x000000D9。 这表示内部锁定页跟踪结构已损坏。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x01 内部锁跟踪结构的地址内存描述符列表的地址当前进程锁定的页数在同一进程列表中插入 MDL 两次。0x02 内部锁跟踪结构的地址内存描述符列表的地址当前进程锁定的页数MDL 在系统范围内的列表中插入两次。0x03 找到的第一个内部跟踪结构的地址内部锁跟踪结构的地址内存描述符列表的地址释放时，在进程列表中发现了两次 MDL。0x04 内部锁跟踪结构的地址内存描述符列表的地址0 删除 MDL 后，在系统范围内的免费列表中找到了它。错误由参数 1 的值指示。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。LOCKED_PAGES_TRACKER_CORRUPTION参数原因", "0xDA": "BUG代码 0xDA：SYSTEM_PTE_MISUSE\n项目 • 2023/06/20SYSTEM_PTE_MISUSE Bug 检查 的值为 0x000000DA。 这表示页表条目 (PTE) 例程已被不当使用。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x01 内部锁跟踪结构的地址内存描述符列表的地址重复的内部锁跟踪结构的地址正在释放的映射是重复的。0x02 内部锁跟踪结构的地址系统预期释放的映射数驱动程序请求释放的映射数要释放的映射数不正确。0x03 找到的第一个内部跟踪结构的地址系统预期释放的映射地址驱动程序请求释放的映射地址正在释放的映射地址不正确。0x04 内部锁跟踪结构的地址系统预期的页帧编号应位于MDL 中的第一个MDL 中当前第一个的页面帧编号映射 MDL 后，映射的 MDL 的第一页已更改。0x05 找到的第一个内部跟踪结构的地址系统预期释放的虚拟地址驱动程序请求释放的虚拟地址自映射 MDL 后，要释放的 MDL 中的起始虚拟地址已更改。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SYSTEM_PTE_MISUSE参数参数 1 参数 2 参数 3 参数 4 错误消息的原因0x06 驱动程序指定的 MDL驱动程序指定的虚拟地址驱动程序指定的要释放 (的映射数)要释放的 MDL 从未 (或当前未) 映射。0x07 初始映射 映射数 保留 (Windows 2000 仅) 映射范围是双重分配的。0x08 初始映射 调用方正在释放的映射数系统认为应释放的映射数(Windows 2000 仅) 调用方要求释放错误数量的映射。0x09 初始映射 调用方正在释放的映射数系统认为的映射索引已可用(Windows 2000 仅) 调用方要求释放多个映射，但其中至少一个映射未分配。0x0A 1：驱动程序在 MDL中请求了“故障时检查 Bug”。0：驱动程序未在MDL 中请求“故障时检查Bug”。调用方正在分配的映射数请求的映射池的类型(Windows 2000 仅) 调用方要求分配零映射。0x0B 损坏的映射 调用方正在分配的映射数请求的映射池的类型(Windows 2000 仅) 映射列表在此分配时已损坏。 损坏的映射位于可能的最低映射地址下方。0x0C 损坏的映射 调用方正在分配的映射数请求的映射池的类型(Windows 2000 仅) 映射列表在此分配时已损坏。 损坏的映射位于可能的最低映射地址上方。0x0D 初始映射 调用方正在释放的映射数映射池的类型(Windows 2000 仅) 调用方尝试释放零映射。0x0E 初始映射 调用方正在释放的映射数映射池的类型(Windows 2000 仅) 调用方正在尝试释放映射，但防护映射已被覆盖。0x0F 不存在的映射调用方尝试释放的映射数要释放的映射池的类型(Windows 2000 仅) 调用方正在尝试释放不存在的映射。 不存在的映射位于可能的最低映射地址下方。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x10 不存在的映射调用方尝试释放的映射数要释放的映射池的类型(Windows 2000 仅) 调用方正在尝试释放不存在的映射。 不存在的映射位于可能的最高映射地址上方。0x11 不存在的映射调用方尝试释放的映射数要释放的映射池的类型(Windows 2000 仅) 调用方正在尝试释放不存在的映射。 不存在的映射位于映射地址空间的底部。0x100 请求的映射数调用方标识标记调用此例程的调用方例程的地址调用方请求了 0 个映射。0x101 第一个映射地址调用方标识标记所有者的标识标记调用方正在尝试释放其不拥有的映射地址范围。0x102 第一个映射地址调用方标识标记保留 调用方尝试释放的映射地址空间显然为空。0x103 无效映射的地址调用方标识标记映射地址空间中的映射数调用方尝试释放的映射地址空间仍保留。MmUnmapReservedMapping必须在 MmFreeMappingAddress 之前调用。0x104 第一个映射地址调用方标识标记所有者的标识标记调用方正在尝试将 MDL 映射到它不拥有的映射地址空间。0x105 第一个映射地址调用方标识标记保留 调用方尝试将 MDL 映射到无效的映射地址空间。 调用方很可能指定了无效地址。0x107 第一个映射地址非空映射的地址最后一个映射地址调用方正在尝试将 MDL 映射到未正确保留的映射地址空间。 调用方应在调用MmMapLockedPagesWithReservedMapping之前调用 MmUnmapReservedMapping0x108 第一个映射地址调用方标识标记所有者的标识标记调用方正在尝试取消映射其不拥有的锁定映射地址空间。0x109 第一个映射地址调用方标识标记保留 调用方正在尝试取消映射显然为空的锁定虚拟地址空间。0x10A 第一个映射地址锁定的映射地址空间中的映射数要取消映射的映射数调用方正在尝试取消映射锁定的映射地址空间中实际存在的映射数。0x10B 第一个映射地址调用方标识标记要取消映射的映射数调用方正在尝试取消映射当前未映射的锁定虚拟地址空间的一部分。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x10C 第一个映射地址调用方标识标记要取消映射的映射数调用方不会取消映射整个锁定的映射地址空间。0x200 第一个映射地址0 0 调用方正在尝试保留不包含映射的映射地址空间。0x2010x202要保留的第一个映射地址已保留的映射的地址要保留的映射数调用方尝试保留的映射之一已被保留。0x300 要发布的第一个映射地址0 0 调用方正在尝试释放不包含映射的映射地址空间。0x301 映射的地址 0 0 调用方正在尝试释放不允许释放的映射。0x302 调用方尝试释放的地址。预留 预留 调用方正在尝试释放当前未映射的系统地址。0x303 第一个映射地址要发布的映射数0 调用方正在尝试释放未保留的映射地址范围。0x304 第一个映射地址要发布的映射数0 调用方尝试释放从不同分配中间开始的映射地址范围。0x305 第一个映射地址调用方尝试释放的映射数应释放的映射数调用方尝试释放错误数量的映射。0x306 第一个映射地址免费映射地址要发布的映射数调用方尝试释放的映射之一已经免费。0x400 I/O 空间映射的基址要释放的页数0 调用方正在尝试释放系统不知道的 I/O 空间映射。错误由参数 1 的值指示。堆栈跟踪将识别导致错误的驱动程序。原因", "0xDB": "BUG代码 0xDB：DRIVER_CORRUPTED_SYSPTES\n项目 • 2023/06/20DRIVER_CORRUPTED_SYSPTES Bug 检查的值为 0x000000DB。 这表示尝试在无效 IRQL处触摸内存，可能是由于系统 PTE 损坏。参数 描述1 引用的内存2 IRQL3 0： 读1： 写4 引用内存的代码中的地址驱动程序尝试访问可分页 (或完全无效) 内存，其内存过高为 IRQL。 此 Bug 检查几乎总是由具有损坏系统 PTE 的驱动程序引起的。如果发生此 Bug 检查，可以通过编辑注册表来检测罪魁祸首。 在\\\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SessionManager\\Memory Management 注册表项中，创建或编辑 TrackPtes 值，并将其设置为等于 DWORD 3。 然后重新启动。 然后，系统将保存堆栈跟踪，如果驱动程序提交相同的错误，系统将发出", "0xDC": "BUG代码 0xDC：DRIVER_INVALID_STACK_ACCESS\n项目 • 2023/06/20DRIVER_INVALID_STACK_ACCESS Bug 检查 的值为 0x000000DC。 这表示驱动程序访问了位于堆栈线程的堆栈指针下方的堆栈地址。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_INVALID_STACK_ACCESS参数无备注!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0xDE": "BUG代码 0xDE：POOL_CORRUPTION_IN_FILE_AREA\n项目 • 2023/06/20POOL_CORRUPTION_IN_FILE_AREA Bug 检查 的值为 0x000000DE。 这表示驱动程序的池内存已损坏，用于存放发往磁盘的页。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。POOL_CORRUPTION_IN_FILE_AREA参数无原因内存管理器取消引用文件时，它发现池内存中出现此损坏。", "0xDF": "BUG代码 0xDF：IMPERSONATING_WORKER_THREAD\n项目 • 2023/06/20IMPERSONATING_WORKER_THREAD Bug 检查 的值为 0x000000DF。 这表示工作项在模拟完成之前未禁用。参数 说明1 导致此错误的工作线程例程2 传递给此辅助角色例程的参数3 指向工作项的指针4 保留工作线程正在模拟另一个进程，在返回之前未能禁用模拟。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。IMPERSONATING_WORKER_THREAD参数原因", "0xE0": "BUG代码 0xE0：ACPI_BIOS_FATAL_ERROR\n项目 • 2023/06/20ACPI_BIOS_FATAL_ERROR Bug 检查 的值为 0x000000E0。 这表示其中一个计算机组件有故障。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ACPI_BIOS_FATAL_ERROR参数此 Bug 检查的参数由 BIOS 发出，而不是由 Windows 发出。 它们只能由硬件供应商解释。原因计算机的 BIOS 报告系统中的某个组件存在错误，无法让 Windows 运行。 BIOS 指示除了发出 Bug 检查，别无选择。解决方法可以通过运行计算机附带的诊断磁盘或工具来确定哪个组件出错。如果没有此工具，则必须联系系统供应商，并向他们报告此错误消息。 它们将能够帮助你纠正此硬件问题。 这使 Windows 能够运行。Microsoft 无法解决此错误。 只有硬件供应商才有资格对其进行分析。", "0xE1": "BUG代码 0xE1：WORKER_THREAD_RETURNED_AT_BAD_IRQL\n项目 • 2023/06/20WORKER_THREAD_RETURNED_AT_BAD_IRQL Bug 检查 值为 0x000000E1。 这表示已完成并返回的工作线程，IRQL >= DISPATCH_LEVEL。参数 描述1 工作线程例程的地址2 工作线程返回的 IRQL3 工作项参数4 工作项地址已完成并返回的工作线程，IRQL >= DISPATCH_LEVEL。若要查找导致错误的驱动程序，请使用 ln (列出最接近的符号) 调试器命令：dbgcmd） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_RETURNED_AT_BAD_IRQL参数原因解决方法kd> ln address其中 address 是参数 1 中给定的辅助角色例程地址。", "0xE2": "BUG代码 0xE2：MANUALLY_INITIATED_CRASH\n项目 • 2023/06/20MANUALLY_INITIATED_CRASH Bug 检查 的值为 0x000000E2。 这表示用户故意从内核调试器或键盘启动故障转储。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MANUALLY_INITIATED_CRASH参数无备注有关手动启动的故障转储的详细信息，请参阅 强制系统崩溃。", "0xE3": "BUG代码 0xE3：RESOURCE_NOT_OWNED\n项目 • 2023/06/20RESOURCE_NOT_OWNED Bug 检查的值为 0x000000E3。 这表示线程尝试释放它不拥有的资源。参数 描述1 资源的地址2 线程地址3 所有者表 (的地址（如果存在) ）4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。RESOURCE_NOT_OWNED参数", "0xE4": "BUG代码 0xE4：WORKER_INVALID\n项目 • 2023/06/20WORKER_INVALID Bug 检查 的值为 0x000000E4。 这表示不应包含执行工作项的内存确实包含此类项，或者当前活动的工作项已排队。参数 1 指示代码位置。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x0 工作项的地址 池块的启动 池块结束 已释放活动辅助角色项。0x1 工作项的地址 队列编号 0 活动辅助角色项已排队。0x2 工作项的地址 I/O 辅助角色例程的地址0 已释放排队的 I/O辅助角色项。0x3 工作项的地址 无效对象的地址 0 尝试使用无效对象初始化 I/O 工作器项。0x5 工作项的地址 队列编号 NUMA 节点面向;如果搜索了所有节点，则为 -1。在初始化 WorkerQueued 之前，尝试对工作项进行排队。0x6 工作项的地址 队列编号 0 提供的队列类型无效。0x7 工作项的地址 队列编号 0 尝试使用无效的工作例程地址对工作项进行排队。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_INVALID参数原因这通常是由驱动程序释放内存（仍包含执行工作项）引起的。", "0xE6": "BUG代码 0xE6：DRIVER_VERIFIER_DMA_VIOLATION\n项目 • 2023/06/15DRIVER_VERIFIER_DMA_VIOLATION Bug 检查 的值为 0x000000E6。 这是所有驱动程序验证程序 DMA 验证冲突的 Bug 检查代码。参数 1 是唯一感兴趣的参数。 此参数标识确切的冲突。 如果附加了调试器，调试器中会显示一条信息性消息。参数 1 错误原因和调试器消息0x00 - 杂项 DMA 错误。 此代码可以表示参数 2 所指示的两种错误：0x1 - 驱动程序尝试将过多字节刷新到映射寄存器文件的末尾。参数 3 - MDL 中剩余的字节数。参数 4 - 请求刷新的剩余字节数。0x2 - Windows 已用完连续映射寄存器。参数 3 - 需要映射寄存器。参数 4 - 连续映射寄存器的数目。0x01 性能计数器已减少。 将显示计数器的旧值和新值。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。７ 备注未启用驱动程序验证程序时，可以观察到 E6 主要 Bug 检查代码。 如果在未启用驱动程序验证程序的情况下遇到此代码，请参阅 DMA 验证页以获取详细信息。DRIVER_VERIFIER_DMA_VIOLATION参数参数 1 错误原因和调试器消息0x02 性能计数器增长过快。 计数器值显示在调试器中。0x03 驱动程序释放了过多的 DMA 通用缓冲区。 通常，这意味着它释放了同一缓冲区两次。参数 2 - 释放的额外通用缓冲区数。0x04 驱动程序释放了过多的 DMA 适配器通道。 通常这意味着它释放了同一个适配器通道两次。参数 2 - 释放的额外适配器通道数。0x05 驱动程序释放了过多的 DMA 地图寄存器。 通常，这意味着它释放了同一映射寄存器两次。参数 2 - 释放的额外映射寄存器数。0x06 驱动程序释放了过多的 DMA 散点/收集列表。通常，这意味着它释放了两次相同的散点/收集列表。参数 2 - 分配的散点-收集列表。参数 3 - 释放的散点集合列表。0x07 驱动程序尝试释放适配器，但未首先释放其所有通用缓冲区。参数 2 - 指向 DMA 适配器的指针。参数 3 - 未完成的通用缓冲区数。参数 4 - 指向相应内部验证程序数据的指针。0x08 驱动程序尝试释放适配器，但未首先释放所有适配器通道、公共缓冲区或散点/收集列表。参数 2 - 指向 DMA 适配器的指针。参数 3 - 未完成的适配器通道数。参数 4 - 指向相应内部验证程序数据的指针。参数 1 错误原因和调试器消息0x09 驱动程序尝试释放适配器，但未首先释放所有映射寄存器。参数 2 - 指向 DMA 适配器的指针。参数 3 - 未完成的映射寄存器数。参数 4 - 指向相应内部验证程序数据的指针。0x0A 驱动程序尝试释放适配器，但未首先释放其所有散点/收集列表。参数 2 - 指向 DMA 适配器的指针。参数 3 - 未完成的散点集合列表的数目。参数 4 - 指向相应内部验证程序数据的指针。0x0B 驱动程序同时分配了过多的适配器通道 (每个适配器只允许一个适配器通道。)参数 2 - 未完成的适配器通道。0x0C 驱动程序尝试同时分配过多的映射寄存器。参数 2 - 所需的映射寄存器。参数 3 - 最大映射寄存器数。0x0D 驱动程序未刷新其适配器缓冲区。参数 2 - 映射的字节数。参数 3 - 一次可以映射的最大字节数。0x0E 驱动程序在没有锁定缓冲区的情况下尝试了DMA 传输。 有问题的缓冲区位于分页内存中。参数 2 - DMA 缓冲区 MDL 的地址。参数 1 错误原因和调试器消息0x0F 驱动程序或硬件在其分配的 DMA 缓冲区之外写入。 参数 2 是冲突代码。0x01 ：修改 DMA 缓冲区之前的标记。预期的标记为 DmaVrfy0。参数 3 - 缓冲区长度。参数 4 - 缓冲区启动。0x02 ：修改 DMA 缓冲区后的标记。预期的标记为 DmaVrfy0。参数 3 - 缓冲区长度。参数 4 - 缓冲区启动。0x03：覆盖了免费地图寄存器。参数 3 - 损坏地址。 预期填充模式0x0F。0x04：在缓冲区被错误修改之前进行填充。参数 3 - 缓冲区启动。 预期填充0x0F。参数 4 - 损坏地址。0x05：缓冲区被错误修改后的填充。参数 3 - 缓冲区启动。参数 4 - 损坏地址。 预期填充模式0x0F。0x10 司机试图释放其地图寄存器，而有些寄存器仍然被映射。参数 2 - 仍映射的寄存器数。0x11 驱动程序具有太多未完成的适配器引用计数。参数 2 - 引用计数。参数 3 - 指向 DMA 适配器的指针。参数 4 - 指向相应内部验证程序数据的指针。参数 1 错误原因和调试器消息0x13 驱动程序在不正确的 IRQL 中调用 DMA 例程。参数 2 是冲突代码。0x01：当前 IRQL 与预期不同。参数 3 - 预期的 IRQL。参数 4 - 当前 IRQL。0x02：当前 IRQL 高于预期。参数 3 - 预期的最大 IRQL。参数 4 - 当前 IRQL。0x14 驱动程序在不正确的 IRQL 中调用 DMA 例程。0x15 驱动程序尝试分配过多的映射寄存器。参数 2 - 分配的映射寄存器。参数 3 - 最大映射寄存器数。0x16 驱动程序尝试刷新未映射的缓冲区。参数 2 - 映射寄存器的系统虚拟空间中的地址。参数 3 - 指向相应的内部验证程序数据的指针。0x18 驱动程序尝试使用已释放且不再存在的适配器执行 DMA 操作。参数 2 - 指向 DMA 适配器的指针。参数 3 - 指向相应的内部验证程序数据的指针。0x19 驱动程序将 null DMA_ADAPTER 值传递给 HAL例程。0x1B 驱动程序将地址和 MDL 传递给 HAL 例程。 但是，此地址不在此 MDL 的边界内。参数 2 - 超出 MDL 边界的虚拟地址。参数 3 - MDL。0x1D 驱动程序尝试映射已映射的地址范围。参数 2 - 映射开始的缓冲区。参数 3 - 映射末尾的缓冲区。参数 4 - 已映射的缓冲区中的系统地址。参数 1 错误原因和调试器消息0x1E 名为 HalGetAdapter 的驱动程序。 此函数已过时 -- 必须改用 IoGetDmaAdapter 。0x1F 无效的 DMA 缓冲区。 驱动程序引用了无效的系统地址 -- 在第一个 MDL 之前或第一个 MDL 的末尾之后，或者通过使用比 MDL 缓冲区长且跨越 MDL 中的页边界的传输长度。Parameter 2是冲突代码。0x01 ：虚拟缓冲区地址位于第一个 MDL 之前。参数 3 - DMA 缓冲区开始的虚拟地址。参数 4 - 指向描述 DMA 缓冲区的第一个 MDL的指针。0x02：虚拟地址位于第一个 MDL 之后。参数 3 - DMA 缓冲区开始的虚拟地址。参数 4 - 指向描述 DMA 缓冲区的第一个 MDL的指针。0x03：额外的传输长度将跨越页面边界。参数 3 - 指向描述 DMA 缓冲区的 MDL 的指针。参数 4 - DMA 传输的长度。0x04：DMA 缓冲区的虚拟地址未对齐缓存。参数 3 - DMA 缓冲区开始的虚拟地址。参数 4 - 指向描述 DMA 缓冲区的 MDL 的指针。0x05：DMA 缓冲区长度未对齐缓存。参数 3 - DMA 缓冲区的长度。参数 4 - 指向描述 DMA 缓冲区的 MDL 的指针。参数 1 错误原因和调试器消息0x20 驱动程序尝试刷新尚未映射的映射寄存器。参数 2 - 映射寄存器基。参数 3 - DMA 缓冲区开头的 VA。参数 4 - 指向用于描述 DMA 缓冲区的 MDL 的指针。0x21 驱动程序尝试映射零长度缓冲区以用于传输。参数 2 - 指向相应的内部验证程序数据的指针。0x22 DMA 缓冲区未在系统 VA 中映射。参数 2 - MDL0x23 无法刷新尚未完成或取消的通道。参数 2 - 冲突代码。值：0x00：非法通道刷新参数 3 - 控制器 ID。参数 4 - 通道编号。0x24 请求的长度缓冲区不足。参数 2 - 未记入的长度。0x25 未知的设备说明版本。0x26 IOMMU 检测到 DMA 冲突。参数 2 - 故障设备的 Device 对象。参数 3 - 故障信息 (通常会) 物理地址出错。参数 4 - 故障类型 (特定于硬件的) 。有关原因的说明，请参阅参数部分中每个代码的说明。原因解决方法仅当驱动程序验证程序已指示监视一个或多个驱动程序时，才会发生此 Bug 检查。 如果不打算使用驱动程序验证程序，则应停用它。 还可以考虑删除导致此问题的驱动程序。如果你是驱动程序编写者，请使用通过此 Bug 检查获取的信息来修复代码中的 Bug。有关驱动程序验证程序的详细信息，请参阅 驱动程序验证程序。", "0xE7": "BUG代码 0xE7：INVALID_FLOATING_POINT_STATE\n项目 • 2023/06/20INVALID_FLOATING_POINT_STATE Bug 检查 的值为 0x000000E7。 这表示线程保存的浮点状态无效。参数 1 指示哪个有效性检查失败。 不使用参数 4。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 错误消息的原因0x0 标志字段 0 保存的上下文标志字段无效。 未设置FLOAT_SAVE_VALID，或者某些保留位不为零。0x1 保存的 IRQL 当前 IRQL 当前处理器的 IRQL 与保存浮点上下文时不同。0x2 拥有此浮点上下文的线程的已保存地址当前线程 保存的上下文不属于当前线程。还原线程以前保存的浮点状态时，发现状态无效。参数 1 指示哪个有效性检查失败。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_FLOATING_POINT_STATE参数原因", "0xE8": "BUG代码 0xE8：INVALID_CANCEL_OF_FILE_OPEN\n项目 • 2023/06/20INVALID_CANCEL_OF_FILE_OPEN Bug 检查 的值为 0x000000E8。 这表示传递到IoCancelFileOpen 的文件对象无效。参数 描述1 传递给 IoCancelFileOpen 的文件对象2 传递给 IoCancelFileOpen 的设备对象3 保留4 保留传递给 IoCancelFileOpen 的文件对象无效。 它应引用一个。 调用 IoCancelFileOpen 的驱动程序出错。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_CANCEL_OF_FILE_OPEN参数原因", "0xE9": "BUG代码 0xE9：ACTIVE_EX_WORKER_THREAD_TERMINATION\n项目 • 2023/06/20ACTIVE_EX_WORKER_THREAD_TERMINATION Bug 检查 的值为 0x000000E9。 这表示正在终止活动的执行辅助角色线程。参数 说明1 退出的 ETHREAD2 保留3 保留4 保留执行工作线程在未完成工作线程运行代码的情况下被终止。 这是禁止的：排队到ExWorkerQueue 的工作项不得终止其线程。堆栈跟踪应指示原因。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ACTIVE_EX_WORKER_THREAD_TERMINATION参数原因", "0xEA": "BUG代码 0xEA：THREAD_STUCK_IN_DEVICE_DRIVER\n项目 • 2023/06/20THREAD_STUCK_IN_DEVICE_DRIVER Bug 检查 的值为 0x000000EA。 这表示设备驱动程序中的线程无休止地旋转。参数 描述1 指向停滞线程对象的指针2 指向 DEFERRED_WATCHDOG 对象的指针3 指向有问题的驱动程序名称的指针4 在内核调试器中：命中“截获”0xEA:ACTIVE_EX_WORKER_THREAD_TERMINATION\n\n问题原因：\n\n第三方软件缺陷\n\n硬件故障（通常是RAM）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xEB": "BUG代码 0xEB：DIRTY_MAPPED_PAGES_CONGESTION\n项目 • 2023/06/20DIRTY_MAPPED_PAGES_CONGESTION Bug 检查 的值为 0x000000EB。 这表示没有可用于继续操作的免费页面。参数 描述1 脏页总数2 发往页面文件的脏页数3 仅限 Windows Server 2003：在页面检查 (Bug时可用的非分页池的大小)Windows Vista 及更高版本：保留4 仅限 Windows Server 2003：当前搁浅的转换页数Windows Vista 及更高版本：最近修改的写入错误状态文件系统驱动程序堆栈已死锁，大多数修改的页面都发往文件系统。 由于文件系统不可运行，因此系统已崩溃，因为任何修改后的页面都不能重复使用，而不会丢失数据。 堆栈中的任何文件系统或筛选器驱动程序都可能存在故障。若要查看常规内存统计信息，请使用 ！vm 3 扩展。此 Bug 检查可能由于以下任一原因而发生：） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DIRTY_MAPPED_PAGES_CONGESTION参数原因驱动程序已阻止、死锁修改或映射的页编写器。 例如，文件系统驱动程序或筛选器驱动程序中的互斥死锁或对分页内存的访问。 这表示驱动程序 Bug。如果参数 1 或参数 2 较大，则有可能发生这种情况。 使用 ！vm 3。存储驱动程序未处理请求。 例如，搁浅的队列和无响应的驱动器。 这表示驱动程序Bug。如果参数 1 或参数 2 较大，则有可能发生这种情况。 使用 ！process 0 7。仅限 Windows Server 2003：存储堆栈没有足够的池可用于写出修改的页面。 这表示驱动程序 Bug。如果参数 3 较小，则有可能这样做。 使用 ！vm 和 ！poolused 2。", "0xEC": "BUG代码 0xEC：SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT\n项目 • 2023/06/20SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT Bug 检查 的值为 0x000000EC。 这表示会话驱动程序仍保留内存时发生了会话卸载。参数 描述1 会话 ID2 正在泄漏的特殊池页数3 保留4 保留此错误是由会话驱动程序在会话卸载之前未释放其特殊池分配导致的。 这表示win32k.sys、atmfd.dll、rdpdd.dll或视频驱动程序存在 Bug。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT参数原因", "0xED": "BUG代码 0xED：UNMOUNTABLE_BOOT_VOLUME\n项目 • 2023/06/20UNMOUNTABLE_BOOT_VOLUME Bug 检查 的值为 0x000000ED。 这表示 I/O 子系统尝试装载启动卷，但失败。参数 描述1 启动卷的设备对象2 文件系统中的状态代码，用于描述无法装载卷的原因3 保留4 保留如果要调试此错误，请使用 ！analyze -v 扩展。 此扩展向错误显示相关的数据特定错误。此 Bug 检查通常与 OS 启动存储设备（如硬盘驱动器）的故障有关。 若要尝试验证文件系统并恢复启动记录，以下故障排除步骤可能会有所帮助。1. 在Windows 10中，使用故障排除>高级选项>启动修复。 可能需要创建可启动的恢复媒体，并从 USB 驱动器或 DVD 启动才能运行 Windows 恢复环境。2. 在 Windows 恢复环境的命令提示符下，使用 CHKDSK /r 尝试修复文件系统。3. 使用 bootrec 命令修复主记录和启动记录。如果这些步骤不成功，则可能是硬盘驱动器出现故障。 某些硬盘驱动器供应商提供诊断工具，可帮助确认硬件故障。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UNMOUNTABLE_BOOT_VOLUME参数解决方法", "0xEF": "BUG代码 0xEF：CRITICAL_PROCESS_DIED\n项目 • 2023/06/15CRITICAL_PROCESS_DIED Bug 检查 的值为 0x000000EF。 此检查指示关键系统进程已终止。 如果系统终止，关键进程会强制系统检查 Bug。 当进程的状态损坏或损坏时，会发生此检查。 发生损坏或损坏时，由于这些进程对 Windows 的运行至关重要，因此检查出现系统 Bug，因为操作系统完整性存在问题。内置的 Windows 关键系统服务包括csrss.exe、wininit.exe、logonui.exe、smss.exe、services.exe、conhost.exe和winlogon.exe。开发人员还可以创建服务并将其恢复选项设置为 “重新启动计算机”。 有关详细信息，请参阅 设置恢复操作，以便在服务发生故障时发生。参数 说明1 进程对象2 如果为 0，则表示进程已终止。 如果为 1，则为线程终止。3 保留4 预留确定此问题的原因通常需要使用调试器来收集其他信息。 应检查多个转储文件，查看此停止代码是否具有类似的特征，例如，出现停止代码时正在运行的代码。有关详细信息，请参阅 使用 Windows 调试器进行故障转储分析 (WinDbg) 、 使用 ！analyze 扩展 和 ！analyze。） 重要本主题面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CRITICAL_PROCESS_DIED参数解决方法在许多情况下，还会在系统 Bug 检查之前创建用户转储。 通常，当用户转储可用时，应首先检查该转储以找出问题的根本原因。 从内核转储调试用户模式代码存在限制，包括分页/缺失数据。 有关详细信息，请参阅 用户模式转储文件。请考虑使用事件日志来查看是否存在导致此停止代码的错误。 如果有，可以使用这些错误来检查要调查的特定服务或其他代码。有关相关代码的信息可用后，在执行此代码之前，请在相关代码中设置断点。 从那里，单步执行代码，查看用于控制代码流的关键变量的值。 仔细检查代码的此区域，以查找错误假设或其他错误。使用 Bug 检查的第二个参数来确定某个垂死的进程或线程是否导致 Bug 检查。如果是进程，请使用 ！process 命令在故障点前后显示有关进程的信息，以查找异常行为。 进程资源管理器实用工具可以收集有关父子关系以及正在运行的进程的常规信息。如果是线程，请考虑使用 ！thread 命令显示有关线程的信息。 有关内核模式下的线程的信息，请参阅 更改上下文。有关 Windows 保护的关键代码（如 wininit 和 csrss）上的线程、进程和其他细节的一般信息，请参阅由 Pavel Yosifovich、Mark E. Russinovich、David A. Solomon 和 AlexIonescu 撰写的 Windows Internals 。常规疑难解答技巧如果无法使用调试器，这些常规故障排除提示可能会有所帮助。如果最近向系统添加了硬件，请尝试删除或更换该硬件。 还可以与制造商检查，以查看是否有可用的修补程序。如果最近添加了新的设备驱动程序或系统服务，请尝试删除或更新它们。 尝试确定系统中导致新 Bug 检查代码出现的原因。检查系统登录事件查看器中是否有其他错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。 有关详细信息，请参阅打开事件查看器 。 在系统日志中查找与蓝屏同时出现的严重错误。请与制造商联系，了解是否有更新的系统 BIOS 或固件可用。尝试运行系统制造商提供的硬件诊断。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以按Windows10规格 获取有关所需硬件的信息。运行病毒检测程序。 病毒可能会感染为 Windows 格式化的所有类型的硬盘。 由此产生的磁盘损坏可能会生成系统 Bug 检查代码。 确保病毒检测程序检查主启动记录是否存在感染。使用 系统文件检查器 工具修复丢失或损坏的系统文件。 系统文件检查器是Windows 中的一个实用工具，允许用户扫描 Windows 系统文件中的损坏并还原损坏的文件。 使用以下命令运行 系统文件检查器 工具 (SFC.exe) 。控制台SFC /scannow有关详细信息，请参阅 使用系统文件检查器工具修复丢失或损坏的系统文件 。查看设备管理器，查看是否有任何设备标有感叹号 (！) 。 查看驱动程序属性中显示的事件日志，了解是否有任何故障驱动程序。 请尝试更新相关驱动程序。另请参阅使用 Windows 调试器 (WinDbg) 进行故障转储分析使用 WinDbg 分析内核模式转储文件0xEF:CRITICAL_PROCESS_DIED\n\n问题原因：\n\n第三方软件冲突\n\n硬件故障（通常是SSD）\n\n解决方案：\n\n如频繁出现此蓝屏，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xF0": "BUG代码 0xF0：STORAGE_MINIPORT_ERROR\n项目 • 2023/06/20STORAGE_MINIPORT_ERROR Bug 检查的值为 0x00000F0。 它指示存储微型端口驱动程序无法完成 SRB 请求。参数 描述1 错误代码。 请参阅下面的值。2 请参阅下面的值。3 请参阅下面的值。4 请参阅下面的值。值text） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。STORAGE_MINIPORT_ERROR参数1: Miniport failed to complete a SRB request even after successful resetoperation. 2 - Driver name unicode string address 3 - SRB address 4 - Storport unit device object2: Miniport failed to complete a SRB request even after successful abortoperation for the SRB. 2 - Driver name unicode string address 3 - Abort SRB address 4 - SRB that was being aborted3: Miniport failed to complete a request within a given timeout. 2 - Driver name unicode string address 3 - SRB address 4 - Timeout of the request4: Miniport failed to complete a request for a crypto operation. This canoccur if it is trying to enable an encryption key on an ICE (Inline CryptoEngine) enabled UFS host.  2 - Driver name unicode string address 3 - The STOR_CRYPTO_OPERATION_TYPE for this failure, typicallyStorCryptoOperationInsertKey 4 - Reserved 原因存储微型端口驱动程序中的 Bug 使 SRB 请求无法完成。 有关特定故障类型，请参阅上面列出的错误代码值。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。参数 2 中返回的驱动程序名称应指向有问题的驱动程序。另请参阅Bug 检查代码参考Storport 的接口与 Storport 微型端口驱动程序", "0xF1": "BUG代码 0xF1：SCSI_VERIFIER_DETECTED_VIOLATION\n项目 • 2023/06/20SCSI_VERIFIER_DETECTED_VIOLATION Bug 检查 的值为 0x000000F1。 这是所有驱动程序验证程序 SCSI 验证冲突的 Bug 检查代码。参数 1 标识冲突的类型。参数 1 参数 2 参数 3 参数4错误消息的原因0x1000 传递的第一个参数 传递的第二个参数 保留 微型端口驱动程序向ScsiPortInitialize 传递了错误的参数。0x1001 延迟（以微秒为单位） 预留 预留 微型端口驱动程序名为ScsiPortStallExecution ，并指定了大于 0.1 秒的延迟，导致处理器停止太久。0x1002 耗时过长的例程的地址 微型端口HW_DEVICE_EXTENSION的地址例程的持续时间（以微秒为单位）端口驱动程序调用的微型端口例程的执行时间超过 0.5 秒。(0.5 秒是大多数例程的限制。但是， HwInitialize 例程允许 5秒， FindAdapter 例程是豁免的。)0x1003 微型端口HW_DEVICE_EXTENSION的地址SRB 的地址 保留 微型端口驱动程序多次完成请求。0x1004 SRB 的地址 微型端口HW_DEVICE_EXTENSION的地址保留 微型端口驱动程序完成了 SRB状态无效的请求。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SCSI_VERIFIER_DETECTED_VIOLATION参数参数 1 参数 2 参数 3 参数4错误消息的原因0x1005 微型端口HW_DEVICE_EXTENSION的地址LOGICAL_UNIT_EXTENSION地址保留 微型端口驱动程序调用ScsiPortNotification 以请求NextLuRequest，但未标记的请求仍处于活动状态。0x1006 微型端口HW_DEVICE_EXTENSION的地址虚拟地址无效 保留 微型端口驱动程序将无效的虚拟地址传递给ScsiPortGetPhysicalAddress。(这通常意味着提供的地址不会映射到公共缓冲区。)0x1007 ADAPTER_EXTENSION地址微型端口HW_DEVICE_EXTENSION的地址保留 总线的重置保留期已结束，但微型端口驱动程序仍有未完成的请求。0x2001 延迟（以微秒为单位） 预留 预留 Storport 微型端口驱动程序名为StorPortStallExecution ，并指定了超过 0.1 秒的延迟，导致处理器停止过长的时间。0x2002 预留 预留 预留 StorPortGetUncachedExtension不是从微型端口驱动程序的HwStorFindAdapter 例程调用的。StorPortGetUncachedExtension例程只能从微型端口驱动程序的HwStorFindAdapter 例程调用，并且只能用于总线主适配器。在调用StorPortGetUncachedExtension之前，Storport 微型端口驱动程序必须设置HW_INITIALIZATION_DATA(Storport) 结构的SrbExtensionSize。0x2003 预留 预留 预留 传递到 StorPortGetDeviceBase例程的地址无效。StorPortGetDeviceBase 例程仅支持系统即插即用 (PnP) 管理器分配给驱动程序的地址。0x2004 预留 预留 预留 Storport 微型端口驱动程序多次完成同一 I/O 请求。参数 1 参数 2 参数 3 参数4错误消息的原因0x2005 预留 预留 预留 Storport 微型端口驱动程序将无效的虚拟地址传递给StorPortReadxxx 或StorPortWritexxx 例程之一。 这通常意味着提供的地址不会映射到公共缓冲区。 指定的 Register或 Port 必须位于StorPortGetDeviceBase 例程返回的映射内存空间范围内。有关原因的说明，请参阅参数部分中每个代码的说明。仅当驱动程序验证程序已指示监视一个或多个驱动程序时，才会发生此 Bug 检查。 如果不打算使用驱动程序验证程序，则应停用它。 可以考虑删除导致此问题的驱动程序。如果你是驱动程序编写者，请使用通过此 Bug 检查获取的信息来修复代码中的 Bug。驱动程序验证程序 SCSI 验证 选项仅在 Windows XP 及更高版本中可用。 驱动程序验证程序 Storport 验证 选项仅在 Windows 7 及更高版本中可用。 有关驱动程序验证程序的完整详细信息，请参阅 Windows 驱动程序工具包。原因解决方法", "0xF2": "BUG代码 0xF2：HARDWARE_INTERRUPT_STORM\n项目 • 2023/06/20HARDWARE_INTERRUPT_STORM Bug 检查 的值为 0x000000F2。 这表示内核检测到中断风暴。参数 描述1 连接到风暴中断矢量的链) ISR (或第一个 ISR 的地址2 ISR 上下文值3 风暴中断矢量的中断对象的地址4 如果 ISR 未链接，则0x1;如果 ISR 已链接，则0x2此 Bug 检查指示内核已检测到中断风暴。 中断风暴定义为保持断言状态的级别触发中断信号。 这在系统硬挂起或“总线锁定”时对系统来说是致命的。发生这种情况的原因如下：设备驱动程序告知硬件后不会释放其中断信号。设备驱动程序不会指示其硬件释放中断信号，因为它不认为中断是从其硬件发起的。即使中断不是从其硬件发起的，设备驱动程序也会声明中断。 请注意，仅当多个设备共享同一 IRQ 时，才会发生这种情况。ELCR (边缘级别控制寄存器) 设置不正确。边缘和级别中断触发的设备共享 IRQ。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HARDWARE_INTERRUPT_STORM参数原因所有这些情况都会立即将系统挂起。 此 Bug 检查是启动的，而不是硬挂系统，因为在许多情况下，它可以识别罪魁祸首。发生 Bug 检查时，屏幕上会显示包含 ISR (中断服务例程) 的模块。 下面是你将看到的内容的示例：控制台*** STOP: 0x000000F2 (0xFCA7C55C, 0x817B9B28, 0x817D2AA0, 0x00000002)An interrupt storm has caused the system to hang.*** Address FCA7C55C base at FCA72000, Datestamp 3A72BDEF - ACPI.sys如果第四个参数是0x00000001，则指向的模块很可能是罪魁祸首。 驱动程序损坏或硬件出现故障。如果第四个参数是0x00000002，则指向的模块是链中的第一个 ISR，并且永远不会保证是罪魁祸首。解决方法反复遇到此 Bug 检查的用户应尝试通过查找与模块是 (驱动程序的 IRQ 上的设备（ACPI使用) 相同的 IRQ）来隔离问题。", "0xF3": "BUG代码 0xF3：DISORDERLY_SHUTDOWN\n项目 • 2023/06/20DISORDERLY_SHUTDOWN Bug 检查的值为 0x000000F3。 这表明 Windows 由于内存不足而无法关闭。参数 说明1 脏页总数2 发往页文件的脏页数3 仅限 Windows Server 2003：在页面检查 (Bug时可用的非分页池的大小)Windows Vista 及更高版本：保留4 仅限 Windows Server 2003：当前关闭阶段Windows Vista 及更高版本：最近修改的写入错误状态Windows 尝试关闭，但没有可用于继续操作的免费页面。由于应用程序未终止且驱动程序未卸载，因此即使在修改的编写器终止后，它们仍会继续访问页面。 这会导致系统用完页面，因为可以使用页面文件。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DISORDERLY_SHUTDOWN参数原因", "0xF4": "BUG代码 0xF4：CRITICAL_OBJECT_TERMINATION\n项目 • 2023/06/20CRITICAL_OBJECT_TERMINATION Bug 检查 的值为 0x000000F4。 这表示对系统操作至关重要的进程或线程已意外退出或终止。参数 描述1 终止对象类型：0x3： 过程0x6： 线程2 终止对象3 进程映像文件名4 指向包含说明消息的 ASCII 字符串的指针系统操作需要多个进程和线程。 当它们因任何原因终止时，系统将无法再正常运行。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CRITICAL_OBJECT_TERMINATION参数原因解决方法", "0xF5": "BUG代码 0xF5：FLTMGR_FILE_SYSTEM\n项目 • 2023/06/20FLTMGR_FILE_SYSTEM Bug 检查 的值为 0x000000F5。 这表示筛选器管理器中发生了不可恢复的故障。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。参数1参数2参数 3 参数 4 错误原因0x66 指向操作的回调数据结构的指针。0 0 微筛选器从操作前回调返回FLT_PREOP_SUCCESS_WITH_CALLBACK或FLT_PREOP_SYNCHRONIZE，但未注册相应的操作后回调。0x67 指向操作的回调数据结构的指针。0 操作的错误NTSTATUS代码内部对象空间不足，系统无法分配新空间。0x68 保留 FLT_FILE_NAME_INFORMATIONN结构的地址保留 FLT_FILE_NAME_INFORMATION结构取消引用次数过多。0x6A 文件的文件对象指针。0 0 无法取消文件打开或文件创建请求，因为已为文件创建了一个或多个句柄。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FLTMGR_FILE_SYSTEM参数参数1参数2参数 3 参数 4 错误原因0x6B 帧ID0 线程 无效的 BACKPOCKET IRPCTRL 状态。0x6C 帧IDBackPocket 列表 线程 BACKPOCKETED IRPCTR 的嵌套PageFault 过多。0x6D 微筛选器上下文结构的地址CONTEXT_NODE结构的地址 0 取消引用上下文结构的次数过多。 这意味着，筛选器管理器的CONTEXT_NODE结构的引用计数在仍附加到其关联的对象时为零。0x6E 微筛选器上下文结构的地址CONTEXT_NODE结构的地址 0 释放后引用了上下文结构。问题的原因由参数 1 的值指示。 请参阅参数部分中的表。如果参数 1 等于 0x66，则可以通过验证微筛选器驱动程序是否已为此操作注册操作后回调来调试此问题。 可以在回调数据结构中找到当前操作。 (请参阅参数 2.) 使用 ！fltkd.cbd 调试器扩展。如果参数 1 等于 0x67，则应验证系统中某个位置是否没有非分页池泄漏。如果参数 1 等于 0x6A，请确保微筛选器驱动程序未引用此文件对象 (请参阅参数 2) ，以在微筛选器处理此操作期间随时获取句柄。如果参数 1 等于 0x6B 或 0x6C，则发生不可恢复的内部状态错误，这将导致操作系统检查 Bug。如果参数 1 等于 0x6D，请确保微筛选器驱动程序不会为给定上下文调用FltReleaseContext 太多次 (请参阅参数 2) 。如果参数 1 等于0x6E，请确保在删除给定上下文后，微筛选器驱动程序不会调用FltReferenceContext ， (请参阅参数 2) 。原因解决方法", "0xF6": "BUG代码 0xF6：PCI_VERIFIER_DETECTED_VIOLATION\n项目 • 2023/06/20PCI_VERIFIER_DETECTED_VIOLATION Bug 检查 的值为 0x000000F6。 这表示 BIOS 或 PCI驱动程序正在验证的其他设备中发生错误。参数 1 是唯一感兴趣的参数;这标识检测到的故障的性质。参数 1 错误消息的原因0x01 在停靠事件期间，BIOS 重新编程了活动网桥。0x02 PMCSR 寄存器未在规范规定的时间内更新。0x03 驱动程序已写入 PCI 设备配置空间的 Windows控制部分。PCI 驱动程序在正在验证的设备或 BIOS 中检测到错误。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PCI_VERIFIER_DETECTED_VIOLATION参数原因", "0xF7": "BUG代码 0xF7：DRIVER_OVERRAN_STACK_BUFFER\n项目 • 2023/06/20DRIVER_OVERRAN_STACK_BUFFER Bug 检查 的值为 0x000000F7。 这表示驱动程序已超载基于堆栈的缓冲区。参数 描述1 堆栈中的实际安全检查 Cookie2 预期的安全检查 Cookie3 预期安全检查 Cookie 的位补充4 0驱动程序以覆盖函数返回地址并在函数返回时跳转回任意地址的方式) 基于堆栈的缓冲区(或局部变量。这是经典的“缓冲区溢出”黑客攻击。 系统已关闭，以防止恶意用户完全控制它。使用 kb (显示堆栈回溯) 命令获取堆栈跟踪。在缓冲区溢出处理程序和 Bug 检查调用之前堆栈上的最后一个例程是覆盖其局部变量的例程。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_OVERRAN_STACK_BUFFER参数原因解决方法", "0xF8": "BUG代码 0xF8：RAMDISK_BOOT_INITIALIZATION_FAILED\n项目 • 2023/06/20RAMDISK_BOOT_INITIALIZATION_FAILED Bug 检查 的值为 0x000000F8。 这表示尝试从RAM 磁盘启动时发生初始化失败。参数 描述1 指示失败的原因。1： 在加载程序内存列表中找不到LoaderXIPRom 描述符。2： 无法打开 RAM 磁盘驱动程序 (ramdisk.sys或 \\Device\\Ramdisk) 。3： FSCTL_CREATE_RAM_DISK失败。4： 无法从二进制 GUID 创建 GUID 字符串。5： 无法创建指向 RAM 磁盘设备的符号链接。2 NTSTATUS 代码3 04 0） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。RAMDISK_BOOT_INITIALIZATION_FAILED参数", "0xF9": "BUG代码 0xF9：DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN\n项目 • 2023/06/20DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN Bug 检查 的值为 0x000000F9。 这表示驱动程序STATUS_REPARSE返回到没有尾随名称的IRP_MJ_CREATE请求。参数 描述1 打开的设备对象2 向其发出IRP_MJ_CREATE请求的设备对象3 包含要重新分析的文件的新名称的 Unicode 字符串的地址 ()4 驱动程序为IRP_MJ_CREATE请求返回的信息!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。应仅为具有尾随名称的IRP_MJ_CREATE请求返回STATUS_REPARSE，因为这表明驱动程序支持名称空间。有关使用文件系统驱动程序的详细信息，请参阅 文件系统驱动程序设计指南。 有关IRP_MJ_CREATE请求的信息 ，请参阅 IRP_MJ_CREATE (IFS) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN参数备注", "0xFA": "BUG代码 0xFA：HTTP_DRIVER_CORRUPTED\n项目 • 2023/06/20HTTP_DRIVER_CORRUPTED Bug 检查 的值为 0x000000FA。 这表示 HTTP 内核驱动程序(Http.sys) 已达到损坏状态，无法恢复。参数 1 标识 HTTP 内核驱动程序的确切状态。参数 1 参数 2 参数 3 参数 4 错误消息的原因0x1 工作项的地址 包含工作项的文件的名称检查文件中的工作项检查行号工作项无效。 这最终会导致线程池损坏和访问冲突。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HTTP_DRIVER_CORRUPTED参数", "0xFC": "BUG代码 0xFC：ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY\n项目 • 2023/06/20ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY Bug 检查的值为 0x000000FC。 这表示已尝试执行非可执行内存。参数 描述1 尝试执行其虚拟地址2 页表项的内容 (PTE)3 保留4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 如果可能，尝试执行非可执行内存的驱动程序名称的 Unicode 字符串将打印在 Bug 检查 屏幕上，并保存在 KiBugCheckDriver 中。 否则，通常可以通过运行堆栈跟踪并查看当前指令指针来找到有问题的驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY参数解决方法0xFC:ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY\n\n问题原因：\n\n第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0xFD": "BUG代码 0xFD：DIRTY_NOWRITE_PAGES_CONGESTION\n项目 • 2023/06/20DIRTY_NOWRITE_PAGES_CONGESTION Bug 检查 的值为 0x000000FD。 这表示没有可用于继续基本系统操作的免费页面。参数 描述1 脏页总数2 不可写脏页数3 保留4 最近修改的写入错误状态此 Bug 检查通常是因为拥有修改后不可写页面的组件在将相关文件标记为“不写入”到内存管理后未能写出这些页面。 这表示驱动程序 Bug。有关导致此问题的驱动程序的详细信息，请使用 ！vm 3 扩展，后跟 ！memusage 1 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DIRTY_NOWRITE_PAGES_CONGESTION参数原因解决方法", "0xFE": "BUG代码 0xFE：BugCODE_USB_DRIVER\n项目 • 2023/06/20BugCODE_USB_DRIVER Bug 检查 的值为 0x000000FE。 这表示通用串行总线 (USB) 驱动程序发生错误。四个 Bug 检查参数显示在 Bug 检查停止屏幕上，并使用 ！analyze 提供。 参数 1 标识冲突的类型。参数1参数 2 参数 3 参数 4 错误消息的原因0x1 预留 预留 预留 USB 堆栈中发生了内部错误。0x2 挂起的 IRP的地址传入的 IRP 的地址 导致错误的USB 请求块(URB) 的地址USB 客户端驱动程序已提交一个URB，该 URB 仍附加到总线驱动程序中挂起的另一个 IRP。0x3 预留 预留 预留 USB 微型端口驱动程序检查生成了Bug。 这通常是为了响应硬件故障而发生的。0x4 IRP 的地址 URB 的地址 保留 调用方已提交已在 USB 总线驱动程序中挂起的 IRP。0x5 主机控制器的设备扩展指针PCI 供应商，控制器的产品 ID指向终结点数据结构的指针由于硬件数据结构中发现的物理地址不正确，发生了硬件故障。0x6 对象地址 预期的签名 保留 内部数据结构 (对象) 已损坏。0x7 指向usbport.sys调试日志的指针消息字符串 文件名 有关详细信息，请参阅提供的消息字符串。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BugCODE_USB_DRIVER参数参数1参数 2 参数 3 参数 4 错误消息的原因0x8 1 保留 预留 保留2 设备对象 IRP 中心驱动程序收到 IRP，它不需要或尚未注册。3 预留 预留 保留4 如果参数 3 不为 NULL，则 PDO。 如果参数 3 为NULL，则为上下文。上下文或NULL致命 PDO 陷阱5 预留 预留 保留6 超时代码。 请参阅下表。 超时代码上下文：端口数据严重超时如果参数 1 的值为 8，而参数 2 的值为 6，则参数 3 是超时代码。 下表中提供了超时代码的可能值。超时代码 含义0 非致命超时1 无法恢复挂起的端口。2 在挂起端口之前等待客户端驱动程序启动的重置完成时超时。3 在挂起端口之前等待端口完成恢复时超时。4 在挂起端口之前等待禁用端口更改状态机时超时。5 等待挂起端口请求完成超时。6 等待端口更改状态机被禁用时超时。7 等待端口更改状态机关闭时超时。8 等待中心从选择性挂起恢复时超时。9 在系统挂起之前等待中心从选择性挂起恢复时超时。10 等待端口更改状态机变为空闲状态时超时。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。", "0xFF": "BUG代码 0xFF：RESERVE_QUEUE_OVERFLOW\n项目 • 2023/06/20RESERVE_QUEUE_OVERFLOW Bug 检查 的值为 0x000000FF。 这表示尝试将新项插入保留队列，导致队列溢出。参数 说明1 保留队列的地址2 保留队列的大小3 04 0！analyze 调试扩展显示有关 Bug 检查的信息，在确定根本原因方面非常有用。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。RESERVE_QUEUE_OVERFLOW参数解决方法", "0x100": "BUG代码 0x100：LOADER_BLOCK_MISMATCH\n项目 • 2023/06/20LOADER_BLOCK_MISMATCH Bug 检查的值为 0x00000100。 这表示加载程序块无效，或者与正在加载的系统不匹配。参数 说明1 32 加载程序黑色扩展的大小3 加载程序块的主版本4 加载程序块的次要版本） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。LOADER_BLOCK_MISMATCH参数Bug 检查0x101：CLOCK_WATCHDOG_TIMEOUT\n项目 • 2023/03/08CLOCK_WATCHDOG_TIMEOUT Bug 检查的值为 0x00000101。 此 Bug 检查指示在分配的时间间隔内未收到多处理器系统中辅助处理器的预期时钟中断。参数 说明1 时钟中断超时间隔，以名义时钟计时周期为单位。2 03 对于无响应处理器，处理器控制块 (PRCB) 的地址。4 挂起处理器的索引。指定的处理器未处理中断。 通常，当处理器无响应或死锁时，会发生此 Bug 检查。以下调试器命令可用于调查处理器状态、IRQL 级别和正在运行的代码，以尝试确定哪个代码段不允许向前执行。!analyzek、kb、kc、kd、kp、kP、kv（显示堆栈回溯）!pcr!prcb） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CLOCK_WATCHDOG_TIMEOUT参数原因解决方法!irql另请参阅Bug 检查代码参考", "0x102": "BUG代码 0x102：DPC_WATCHDOG_TIMEOUT\n项目 • 2023/06/21DPC_WATCHDOG_TIMEOUT Bug 检查 的值为 0x00000102。 这表示未在分配的时间间隔内执行 DPC 监视器例程。参数 说明1 DPC 监视器超时间隔（以名义时钟计时周期为单位）。2 挂起处理器的 PRCB 地址。3 保留4 保留此 Bug 检查通常意味着 ISR 在低于时钟级别且高于调度级别的 IRQL 上挂起，或者 DPC例程挂起在指定的处理器上。例如，对于 StorPort 微型端口驱动程序，StorPort.sys处理在 DISPATCH_LEVEL 处运行的例程中的 I/O 完成，并串行调用刚刚完成的所有 IRP 的 I/O 完成例程。 如果 I/O 完成例程单独或一起花费太多时间，键盘和/或鼠标可能会停止响应。 Windows DPC 监视器计时器例程也可能确定 StorPort 例程花费了很长时间才能完成。存储堆栈中的内核驱动程序可以通过高效编码驱动程序的 I/O 完成例程来降低问题的可能性。 如果仍然无法在足够时间内完成例程中执行所有必要的处理，则例程可以为 I/O 工作创建工作元素，将元素排入工作队列并返回STATUS_MORE_PROCESSING_REQUIRED;然） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DPC_WATCHDOG_TIMEOUT参数原因解决方法后，驱动程序的工作线程应查找工作元素，执行工作并为 IRP 执行 IoCallerDriver，以确保 IRP 的进一步 I/O 处理。", "0x103": "BUG代码 0x103：MUP_FILE_SYSTEM\n项目 • 2023/06/20MUP_FILE_SYSTEM Bug 检查 值为 0x00000103。 此 Bug 检查 指示 MUP) (多个 UNC 提供程序遇到无效或意外的数据。 因此，MUP 无法将远程文件系统请求传送到网络重定向程序（通用命名约定 (UNC) 提供程序）。参数 1 标识冲突的类型。参数 1 参数 2 参数 3 参数 4 错误原因0x1 挂起的 IRP 的地址。找不到其文件上下文的文件对象的地址。设备对象的地址。MUP 找不到与文件对象对应的文件上下文。 这通常表示 MUP 看到针对 MUP未看到相应IRP_MJ_CREATE请求的文件对象的 I/O 请求。 此Bug 检查的可能原因是筛选器驱动程序错误。0x2 预期文件上下文的地址。实际从文件对象检索到的地址。保留 已知文件对象存在文件上下文，但不是预期的 (例如，它可能是 NULL) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MUP_FILE_SYSTEM参数参数 1 参数 2 参数 3 参数 4 错误原因0x3 IRP 上下文的地址。IRP 完成状态代码。完成 IRP (的UNC 提供程序的驱动程序对象可能是 NULL)。IRP 完成状态意外或无效。此 Bug 检查仅在使用已检查的 Windows 内部版本时发生，并且仅应由附加到旧网络重定向程序的文件系统筛选器驱动程序引起。 已检查的版本在Windows 10 版本 1803 之前的较旧版本的 Windows上可用。 旧版重定向程序使用FsRtlRegisterUncProvider注册到 MUP。 此 Bug 检查检测返回在IRP_MJ_CLEANUP或IRP_MJ_CLOSE请求中未STATUS_SUCCESSNTSTATUS 的筛选器驱动程序。0x4 IRP 的地址 文件对象的地址文件对象的文件上下文在文件对象的创建请求完成之前，对文件对象启动了 I/O 操作。MUP 基于每个文件对象维护其处理的所有文件对象的上下文信息。备注", "0x104": "BUG代码 0x104：AGP_INVALID_ACCESS\n项目 • 2023/06/20AGP_INVALID_ACCESS Bug 检查的值为 0x00000104。 这表示 GPU 写入一系列加速图形端口， (AGP) 之前尚未提交的内存。参数 描述1 在 AGP 验证程序页中将 ULONG) 中的 (偏移到已损坏的第一个 ULONG 数据2 03 04 0通常，此 Bug 检查是由未签名或测试不当的视频驱动程序引起的。 它也可能由旧 BIOS引起。检查显示驱动程序和计算机 BIOS 更新。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。AGP_INVALID_ACCESS参数原因解决方法", "0x105": "BUG代码 0x105：AGP_GART_CORRUPTION\n项目 • 2023/06/20AGP_GART_CORRUPTION Bug 检查 的值为 0x00000105。 这表明图形光圈重映射表(GART) 已损坏。参数 描述1 GART 的虚拟) (基址2 发生损坏的 GART 的偏移量3 GART 缓存 (虚拟) 基址 (GART)4 0此 Bug 检查通常是由驱动程序 (DMA) 的直接内存访问不当引起的。为所有未签名的驱动程序启用驱动程序验证程序。 删除它们或逐个禁用它们，直到识别出有问题驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。AGP_GART_CORRUPTION参数原因解决方法", "0x106": "BUG代码 0x106：AGP_ILLEGALLY_REPROGRAMMED\n项目 • 2023/06/20AGP_ILLEGALLY_REPROGRAMMED Bug 检查 值为 0x00000106。 这表示加速图形端口(AGP) 硬件已被未经授权的代理重新编程。参数 说明1 最初编程的 AGP 命令寄存器值2 当前命令寄存器值3 04 0此 Bug 检查通常是由未签名或测试不当的视频驱动程序引起的。在视频制造商的网站中查看更新的显示驱动程序或使用 VGA 模式。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。AGP_ILLEGALLY_REPROGRAMMED参数原因解决方法", "0x108": "BUG代码 0x108：THIRD_PARTY_FILE_SYSTEM_FAILURE\n项目 • 2023/06/20THIRD_PARTY_FILE_SYSTEM_FAILURE Bug 检查 的值为 0x00000108。 这表示第三方文件系统或文件系统筛选器中出现了不可恢复的问题。参数 说明1 标识失败的文件系统。 可能的值包括：1： Polyserve (Psfs.sys)2 异常记录的地址。3 上下文记录的地址。4 保留。此 Bug 检查的一个可能原因是磁盘损坏。 第三方文件系统损坏或硬盘上) 扇区 (坏块可能会导致此错误。 损坏的 SCSI 和 IDE 驱动程序也会对 Windows 操作系统读取和写入磁盘的能力产生不利影响，从而导致错误。另一个可能的原因是非分页池内存耗尽。 如果非分页池完全耗尽，则此错误可能会停止系统。若要调试此问题，请执行以下操作： 将 .cxr (显示上下文记录) 命令与参数 3 配合使用，然后使用 kb (显示堆栈回溯) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。THIRD_PARTY_FILE_SYSTEM_FAILURE参数原因解决方法若要解决磁盘损坏问题，请执行以下操作：检查事件查看器是否有来自系统中的 SCSI、IDE 或其他磁盘控制器的错误消息，这些错误消息可能有助于查明导致错误的设备或驱动程序。 尝试禁用任何持续监视系统的病毒扫描程序、备份程序或磁盘碎片整理程序工具。 还应运行文件系统或文件系统筛选器制造商提供的硬件诊断。若要解决非分页池内存耗尽问题，请执行以下操作： 将新的物理内存添加到计算机。 这将增加内核可用的非分页池内存数量。", "0x109": "BUG代码 0x109：CRITICAL_STRUCTURE_CORRUPTION\n项目 • 2023/06/15CRITICAL_STRUCTURE_CORRUPTION Bug 检查 的值为 0x00000109。 这表示内核已检测到关键内核代码或数据损坏。参数 说明1 保留2 预留3 保留4 损坏区域的类型。 (请参阅本页稍后的下表。)参数 4 的值指示损坏区域的类型。参数 4 损坏区域类型、损坏类型或导致损坏的操作类型0x0 通用数据区域0x1 函数修改0x2 IDT) (处理器中断调度表0x3 GDT) (处理器全局描述符表0x4 类型 1 进程列表损坏0x5 类型 2 进程列表损坏0x6 调试例程修改0x7 关键 MSR 修改） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。CRITICAL_STRUCTURE_CORRUPTION参数参数 4 损坏区域类型、损坏类型或导致损坏的操作类型0x8 对象类型0x9 处理器 IVT0xA 修改系统服务函数0xB 通用会话数据区域0xC 修改会话函数或 .pdata0xD 修改导入表0xE 修改会话导入表0xF Ps Win32 标注修改0x10 调试开关例程修改0x11 IRP 分配器修改0x12 驱动程序调用调度程序修改0x13 IRP 完成调度程序修改0x14 IRP 解除分配器修改0x15 处理器控制寄存器0x16 关键浮点控制寄存器修改0x17 本地 APIC 修改0x18 内核通知标注修改0x19 已加载模块列表修改0x1A 类型 3 进程列表损坏0x1B 类型 4 进程列表损坏0x1C 驱动程序对象损坏0x1D 执行回调对象修改0x1E 修改模块填充0x1F 修改受保护的进程0x20 通用数据区域0x21 页面哈希不匹配参数 4 损坏区域类型、损坏类型或导致损坏的操作类型0x22 会话页哈希不匹配0x23 加载配置目录修改0x24 反转函数表修改0x25 会话配置修改0x26 扩展的处理器控制寄存器0x27 类型 1 池损坏0x28 类型 2 池损坏0x29 类型 3 池损坏0x101 常规池损坏0x102 修改win32k.sys此 Bug 检查通常有三种不同的原因：1. 驱动程序无意中或故意修改了关键内核代码或数据。 适用于基于 x64 的计算机的Microsoft Windows Server 2003 Service Pack 1 (SP1) 及更高版本的 Windows 不允许修补内核，除非通过授权的 Microsoft 发起的热修补程序进行修补。2. 开发人员尝试使用启动系统时未附加的内核调试器设置正常的内核断点。 只有在启动时附加调试器时，才能设置常规断点 (bp) 。 可随时设置处理器断点 (ba) 。3. 发生了硬件损坏。 例如，内核代码或数据可能存储在失败的内存中。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。若要开始，请使用 k、kb、kc、kd、kp、kP、kv (Display Stack Backtrace) 命令检查堆栈跟踪 。 可以指定处理器编号来检查所有处理器上的堆栈。还可以在导致此停止代码的代码中设置断点，并尝试单步执行错误代码。有关详细信息，请参阅以下主题：使用 Windows 调试器 (WinDbg) 进行故障转储分析原因解决方法如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。检查事件查看器中的系统日志，了解可能有助于识别导致此 Bug 检查的设备或驱动程序的其他错误消息。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。运行 Windows 内存诊断工具以测试内存。 在控制面板搜索框中，键入“内存”，然后选择“ 诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 查找“内存诊断结果”条目以查看结果 。你可尝试运行系统制造商提供的硬件诊断。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以在Windows10规范 中获取有关所需硬件的信息。有关其他常规故障排除信息，请参阅 蓝屏数据。0x109:CRITICAL_STRUCTURE_CORRUPTION\n\n问题原因：\n\n第三方软件冲突（通常是病毒）\n\n解决方案：\n\n请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x10A": "BUG代码 0x10A：APP_TAGGING_INITIALIZATION_FAILED\n项目 • 2023/06/20APP_TAGGING_INITIALIZATION_FAILED Bug 检查 的值为 0x0000010A。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x10C": "BUG代码 0x10C：FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION\n项目 • 2023/06/20FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION Bug 检查 的值为 0x0000010C。 这表示在文件系统运行时库 (FsRtl) 额外创建参数 (ECP) 包中检测到冲突。参数 说明1 冲突的类型。 (有关) 的更多详细信息，请参阅本页后面的下表。2 03 ECP 的地址。4 ECP 列表的起始地址。参数 1 的值指示冲突的类型。参数 1 冲突类型0x1 由于指针错误或内存损坏，ECP 签名无效。0x2 ECP 设置了未定义的标志。0x3 ECP 不是由 FsRtl 分配的。0x4 ECP 的标志集对于创建调用方传递的参数是非法的。0x5 ECP 已损坏;其大小小于标头大小。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION参数参数 1 冲突类型0x6 正在释放的 ECP 具有非空列表指针;它可能仍然是 ECP 列表的一部分。0x11 由于指针错误或内存损坏，ECP 列表签名无效。0x12 ECP 列表设置了未定义的标志。0x13 ECP 列表不是由 FsRtl 分配的。0x14 ECP 列表的标志集对于创建调用方传递的参数列表是非法的。0x15 创建调用方传递的 ECP 列表为空。", "0x10D": "BUG代码 0x10D：WDF_VIOLATION\n项目 • 2023/06/20检查WDF_VIOLATION Bug 的值为 0x0000010D。 这表示Kernel-Mode驱动程序框架(KMDF) 检测到 Windows 在基于框架的驱动程序中发现错误。参数 1 指示 Bug 检查的特定错误代码。 保留参数 4。参数1参数 2 参数 3 错误消息的原因0x1 指向WDF_POWER_ROUTINE_TIMED_OUT_DATA结构的指针保留 基于框架的驱动程序在电源操作期间超时。 这通常意味着设备堆栈未设置DO_POWER_PAGABLE位，并且驱动程序在关闭分页设备堆栈后尝试了可分页操作。0x2 预留 预留 正在尝试获取当前持有的锁。0x3 WDFREQUEST 句柄 两个缓冲区上保留的未完成引用数Windows 驱动程序框架验证程序遇到严重错误。 具体而言，I/O 请求已完成，但无法删除框架请求对象，因为存在对输入缓冲区和/或输出缓冲区的未完成引用。0x4 保留 调用方地址NULL 参数已传递给需要非 NULL 值的函数。0x5 传入的句柄值 保留 错误类型的框架对象句柄已传递到框架对象方法。0x6 请参阅下表。0x7 框架对象的句柄 保留 驱动程序尝试通过调用WdfObjectDereference 删除句柄而不是调用 WdfObjectDelete 来错误地删除框架对象。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WDF_VIOLATION参数参数1参数 2 参数 3 错误消息的原因0x8 DMA 事务对象的句柄 保留 在 DMA 事务对象未处于正确状态时发生操作。0x9 当前未使用。0xA 指向WDF_QUEUE_FATAL_ERROR_DATA结构的指针保留 处理当前位于队列中的请求时发生严重错误。0xB 请参阅下表。0xC WDFDEVICE 句柄 指向新PnPIRP 的指针当驱动程序正在处理另一个状态更改 PnPIRP 时，新的状态更改 PnP IRP 到达。0xD WDFDEVICE 句柄 指向电源 IRP的指针设备的电源策略所有者收到了它未请求的电源 IRP。 可能有多个电源策略所有者，但只允许一个。 KMDF 驱动程序可以通过调用WdfDeviceInitSetPowerPolicyOwnership来更改电源策略所有权。0xE 调用事件回调函数的 IRQL。 事件回调函数返回的IRQL。事件回调函数未在调用它的同一 IRQL 处返回。 回调函数直接或间接 (更改 IRQL，例如，通过获取自旋锁（将 IRQL 提升为DISPATCH_LEVEL，但不释放) 旋转锁）。0xF 事件回调函数的地址。 保留 事件回调函数已进入关键区域，但在返回之前未离开关键区域。参数 1 等于 0x6如果参数 1 等于 0x6，则在处理 WDF 请求时出错。 在这种情况下，参数 2 进一步指定已发生的错误类型，如枚举WDF_REQUEST_FATAL_ERROR所定义。参数 2 参数 3 错误消息的原因0x1 IRP 的地址 没有其他I/O 堆栈位置可用于设置基础 IRP 的格式。参数 2 参数 3 错误消息的原因0x2 WDF 请求句柄值 尝试格式化不包含IRP 的框架请求对象。0x3 WDF 请求句柄值 驱动程序尝试发送已发送到I/O 目标的框架请求。0x4 指向WDR_REQUEST_FATAL_ERROR_INFORMATION_LENGTH_MISMATCH_DATA结构的指针，该结构包含指向 IRP 的指针、WDF 请求句柄值、IRP 主函数以及尝试写入的字节数驱动程序已完成框架请求，但向输出缓冲区写入的字节数超过了IRP 中指定的字节数。参数 1 等于 0xB如果参数 1 等于 0xB，则尝试获取或释放锁无效。 在这种情况下，参数 3 进一步指定已发生的错误。参数 2 参数 3 错误消息的原因句柄值 0x0 传递给 WdfObjectAcquireLock或 WdfObjectReleaseLock 的句柄表示不支持同步锁的对象。WDF 旋转锁手柄 0x1 未获取旋转锁的线程正在释放该锁。有关原因的说明，请参阅参数部分中每个代码的说明。原因解决方法！analyze 调试扩展显示有关 Bug 检查的信息，并有助于收集信息，例如错误代码模块。通常，WDF 转储文件会生成有关导致此 Bug 检查的驱动程序的进一步信息。 使用此命令查看日志文件。dbgcmdkd> !wdfkd.wdflogdump <WDF_Driver_Name>如果参数 1 等于 0x2，请检查调用方堆栈以确定有问题的锁。如果参数 1 等于 0x3，驱动程序Kernel-Mode驱动程序框架错误日志将包含有关未完成引用的详细信息。如果参数 1 等于 0x4，请使用参数 3 值为的 ln 调试器命令作为其参数，以确定哪个函数需要非 NULL 参数。如果参数 1 等于 0x7，请使用 ！wdfkd.wdfhandle参数 2 扩展命令来确定句柄类型。如果参数 1 等于 0xA，则WDF_QUEUE_FATAL_ERROR_DATA结构将指示有问题的请求或队列句柄。 它还将指示 NTSTATUS（如果不是STATUS_SUCCESS）（如果可用）。0x10D:WDF_VIOLATION\n\n问题原因：\n\nWindows缺陷\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x10E": "BUG代码 0x10E：VIDEO_MEMORY_MANAGEMENT_INTERNAL\n项目 • 2023/06/20VIDEO_MEMORY_MANAGEMENT_INTERNAL Bug 检查 的值为 0x0000010E。 这表示视频内存管理器遇到了无法从中恢复的情况。参数 1 描述视频内存错误的类型。 必须单独检查未出现在此表中的参数 1 的值。参数 1 错误消息的原因0x1 尝试旋转非旋转范围。0x2 尝试销毁非空进程堆。0x3 尝试从光圈段取消映射失败。0x4 必须成功路径中的旋转失败。0x5 延迟的命令失败。0x6 已尝试重新分配已取消其逐出的分配的资源。0x7 尝试延迟免费使用无效。0x8 DMA) 缓冲区 (拆分直接内存访问包含无效引用。0x9 尝试逐出分配失败。0xA 尝试使用固定的分配无效。0xB 驱动程序从 BuildPagingBuffer 返回了无效的错误代码。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_MEMORY_MANAGEMENT_INTERNAL参数参数 1 错误消息的原因0xC 在段中检测到资源泄漏。0xD 段使用不当。0xE 尝试将分配映射到光圈段失败。0xF 驱动程序从 AcquireSwizzlingRange 返回了无效的错误代码。参数 1 错误消息的原因0x10 驱动程序从 ReleaseSwizzlingRange 返回了无效的错误代码。0x11 尝试使用光圈段时无效。0x12 驱动程序溢出了提供的 DMA 缓冲区。0x13 驱动程序溢出了提供的专用数据缓冲区。0x14 尝试清除所有段失败。0x15 尝试释放仍处于旋转状态的 VAD) (虚拟地址描述符0x16 驱动程序破坏了保证的 DMA 缓冲区模型协定。0x17 发生意外的系统命令故障。0x18 尝试释放固定分配的资源失败。0x19 驱动程序无法修补 DMA 缓冲区。0x1A 已释放共享分配的所有者。0x1B 试图释放仍在使用的光圈范围。0x1C VidMm 尝试从帧缓冲区旋转分配，但 VA 未按预期旋转。0x1D VidMm 尝试使用已取消映射的分页缓冲区。0x1E VidMm 尝试从错误的进程上下文执行操作。0x1F VidMm 尝试使用比当前标记的要低的围栏标记分配。参数 1 错误消息的原因参数 1 错误消息的原因0x20 VidMm 正在尝试操作分配，假设分配处于空闲状态，但未处于空闲状态。0x21 VidMm 正在尝试刷新准备外部的分页缓冲区，或者在准备开始时在分页缓冲区中发现未刷新的数据。0x22 VidMm 正在尝试将 VA 旋转到无效范围。0x23 计划程序在等待完成之前唤醒线程。0x24 正在销毁具有对其后备存储的未完成引用的分配...物理内存将泄漏。0x25 GPU 尝试对光圈的未定义区域进行写入。0x26 VIDMM_LOCAL_ALLOC已从其所有者以外的进程关闭。0x27 VIDMM_ALLOC未在当前拆分点重新编程。0x28 引用全局分配时发生意外异常。0x29 在操作VIDMM_ALLOC DMA 引用计数时检测到溢出或下溢。0x2A VidMm 尝试释放对当前显示的分配的最后一个引用。0x2B VidMm 正在尝试释放无效的 Cpu 主机光圈页面范围。0x2C VidMm 正在尝试将页面范围映射到之前已映射的 Cpu 主机光圈。 内存泄漏的最佳情况。0x2D 对 DdiMapCpuHostAperture 的调用失败，但预期会成功。0x2E 调用 DdiUnmapCpuHostAperture 失败，但预期会成功。0x2F 报告的范围大小与为数组分配的元素数不匹配。参数 1 错误消息的原因0x30 GPU 虚拟地址操作期间出错。0x31 正在删除的分页队列仍在由 VidMm 工作线程处理。参数 1 错误消息的原因0x32 正在删除的分页队列仍包含正在运行的数据包。0x33 设备正在被销毁，但仍有分配驻留在它上。0x34 堆分配收到了与当前状态不兼容的状态转换事件。0x35 分页请求在默认分页队列中失败。0x36 分页请求在以前标记为不可恢复的分页数据包或设备恢复时失败，预计后续调用会成功。0x37 在 TDR 期间，VidMm 未能锁定分配页。0x38 VidMm 正在释放仍具有引用它的分页数据包的分配。0x39 VidMm 正在将设备放入无限期处罚箱，但它有分页数据包。0x3A VidMm 工作线程正在运行暂停的分页队列。0x3B 在 D3 转换期间，内存仍会旋转到帧缓冲区。0x3C 内存仍分配或映射到 CPU 主机光圈。 这表示在D3 转换期间，内存仍可能旋转到帧缓冲区。0x3D 在操作期间指定了无效的段组。0x3E 未能获取VIDMM_ALLOC断开保护。0x3F 在移动或碎片整理操作期间恢复计划程序设备与惩罚框状态冲突。 这意味着我们将恢复内存尚无法访问的设备的计划程序。参数 1 错误消息的原因0x40 尝试在另一个操作正在进行时启动准备括号。0x41 删除具有非零驻留或适配器计数的VIDMM_CROSSADAPTER_ALLOC。0x42 删除具有负驻留或适配器计数的VIDMM_CROSSADAPTER_ALLOC。0x43 保存或还原保留的帧缓冲区内容时，我们无法映射节对象的至少一页来向前推进。0x44 内存预算簿记最终处于下溢状态。原因此 Bug 检查通常是由视频驱动程序行为不当引起的。解决方法如果问题仍然存在，检查 Windows 更新更新的视频驱动程序。0x10E:VIDEO_MEMORY_MANAGEMENT_INTERNAL\n\n问题原因：\n\n显卡驱动故障\n\n解决方案：\n\n卸载显卡驱动，然后通过联想电脑管家更新显卡驱动。并更新Windows到最新版本。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x10F": "BUG代码 0x10F：RESOURCE_MANAGER_EXCEPTION_NOT_HANDLED\n项目 • 2023/06/20RESOURCE_MANAGER_EXCEPTION_NOT_HANDLED Bug 检查 的值为 0x0000010F。 这表示内核事务管理器检测到内核模式资源管理器在响应直接回调时引发了异常。 资源管理器处于意外且无法恢复的状态。参数 说明1 异常记录的地址2 上下文记录的地址3 异常代码的地址4 资源管理器的地址） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。RESOURCE_MANAGER_EXCEPTION_NOT_HANDLED参数", "0x111": "BUG代码 0x111：RECURSIVE_NMI\n项目 • 2023/06/20RECURSIVE_NMI Bug 检查 的值为 0x00000111。 此 Bug 检查指示在上一个 NMI 正在进行时发生了不可屏蔽的中断 (NMI) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。备注当系统管理中断 (SMI) 代码出错，并且 SMI 中断 NMI 并启用中断时，将发生此 Bug 检查。 然后，在启用 NMI 的情况下继续执行，另一个 NMI 中断正在进行的 NMI。", "0x112": "BUG代码 0x112：MSRPC_STATE_VIOLATION\n项目 • 2023/06/20MSRPC_STATE_VIOLATION Bug 检查 的值为 0x00000112。 这表明Msrpc.sys驱动程序已启动 Bug 检查。参数 1 和 2 是唯一感兴趣的参数。 参数 1 指示状态冲突类型;参数 2 的值由参数 1 的值确定。参数 1 参数 2 错误消息的原因0x01 异常代码 调用方继续出现非连续异常。0x02 错误 (ALPC) 高级本地过程调用返回无效错误。0x03 与服务器的会话 调用方卸载了 MICROSOFT 远程过程调用 (MSRPC) 驱动程序，而该驱动程序仍在使用中。 打开的绑定句柄很可能仍然存在。0x04 和0x05与服务器的会话 从 ALPC 收到无效的 close 命令。0x06 绑定句柄 尝试将远程过程调用绑定 (RPC)第二次处理。0x07 绑定句柄 尝试对未绑定的绑定句柄执行操作。0x08 绑定句柄 尝试在已绑定的绑定句柄上设置安全信息。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MSRPC_STATE_VIOLATION参数参数 1 参数 2 错误消息的原因0x09 绑定句柄 尝试在已绑定的绑定句柄上设置选项。0x0A 调用对象 尝试取消无效的异步远程过程调用。0x0B 调用对象 尝试在异步管道调用不预期时推送。0x0C 和0x0E管道对象 尝试在不等待通知的情况下推送异步管道。0x0F 管道对象 第二次尝试同步终止管道。0x15 最接近错误的对象 发生 RPC 内部错误。0x16 保留 按 RPC 无法强制执行的顺序发出两个因果排序的调用。0x17 调用对象 服务器管理器例程在完成调用之前未取消订阅通知。0x18 异步句柄 异步句柄上的操作无效。此 Bug 检查的最常见原因是Msrpc.sys驱动程序的调用方违反了此类调用的状态语义。原因", "0x113": "BUG代码 0x113：VIDEO_DXGKRNL_FATAL_ERROR\n项目 • 2023/06/20VIDEO_DXGKRNL_FATAL_ERROR Bug 检查 的值为 0x00000113。 这表示 MicrosoftDirectX 图形内核子系统检测到冲突。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。0x113:VIDEO_DXGKRNL_FATAL_ERROR\n\n问题原因：\n\n显卡驱动故障\n\n解决方案：\n\n卸载显卡驱动，然后通过联想电脑管家更新显卡驱动。并更新Windows到最新版本。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x114": "BUG代码 0x114：VIDEO_SHADOW_DRIVER_FATAL_ERROR\n项目 • 2023/06/20VIDEO_SHADOW_DRIVER_FATAL_ERROR Bug 检查 的值为 0x00000114。 这表示影子驱动程序检测到冲突。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x115": "BUG代码 0x115：AGP_INTERNAL\n项目 • 2023/06/20AGP_INTERNAL Bug 检查 的值为 0x00000115。 这表示 AGP) 驱动程序 (加速图形端口检测到冲突。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x116": "BUG代码 0x116：VIDEO_TDR_FAILURE\n项目 • 2023/06/15VIDEO_TDR_FAILURE Bug 检查 的值为 0x00000116。 此 Bug 检查 表示尝试重置显示驱动程序并从超时恢复失败。参数 说明1 指向内部 TDR 恢复上下文的指针（如果可用）。2 例如，指向负责任设备驱动程序模块的指针 (所有者标记) 。3 上一个失败操作的错误代码（如果可用）。4 内部上下文相关数据（如果可用）。当系统在处理最终用户命令或操作时出现完全冻结或挂起时，会出现图形中常见的稳定性问题。 通常，GPU 正忙于处理密集型图形操作，通常在玩游戏期间。 不会发生屏幕更新，并且用户假定其系统已冻结。 用户通常会等待几秒钟，然后按电源按钮重新启动系统。 Windows 会尝试检测这些有问题的挂起情况，并动态恢复响应式桌面。此检测和恢复过程称为超时检测和恢复 (TDR) 。 默认超时为 2 秒。 在视频卡的 TDR 过程中，操作系统的 GPU 计划程序调用显示微型端口驱动程序的 DxgkDdiResetFromTimeout函数来重新初始化驱动程序并重置 GPU。在此过程中，操作系统会告知驱动程序不要访问硬件或内存，并为当前正在运行的线程提供短时间来完成。 如果线程在超时内未完成，则系统 Bug 会检查0x116VIDEO_TDR_FAILURE。 有关详细信息，请参阅 线程同步和 TDR。如果多个 TDR 事件在短时间内发生，则系统还可以使用 VIDEO_TDR_FAILURE 检查Bug。 默认金额在一分钟内超过五个 TDR。） 重要本文面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。VIDEO_TDR_FAILURE参数原因如果恢复过程成功，将显示一条消息，指示“显示驱动程序已停止响应并已恢复”。有关详细信息，请参阅超时检测和恢复 (TDR) 、TDR 注册表项和 Windows 8 及更高版本中的 TDR 更改。解决方法GPU 花费的时间比在显示器上显示图形所允许的时间多。 以下一种或多种原因可能会导致此行为：可能需要为显示驱动程序安装最新更新，以便它正确支持 TDR 过程。影响视频卡正常运行能力的硬件问题，包括：时钟过度的组件，如主板错误的组件兼容性和设置 (特别是内存配置和计时)系统冷却不足系统功率不足内存模块、主板等 (缺陷部件)视觉效果或后台运行过多的程序可能会降低电脑速度，因此视频卡无法根据需要做出响应。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。dbgcmd1: kd> !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************VIDEO_TDR_FAILURE (116)Attempt to reset the display driver and recover from timeout failed.Arguments:Arg1: ffffe000c2c404c0, Optional pointer to internal TDR recovery context(TDR_RECOVERY_CONTEXT).Arg2: fffff8016470c14c, The pointer into responsible device driver module(e.g. owner tag).Arg3: ffffffffc000009a, Optional error code (NTSTATUS) of the last failedoperation.Arg4: 0000000000000004, Optional internal context dependent data....还会显示出错的模块名称。dbgcmdMODULE_NAME: nvlddmkmIMAGE_NAME: nvlddmkm.sys可以使用 lm (列出加载的模块) 命令显示有关故障驱动程序的信息，包括时间戳。dbgcmd1: kd> lmvm nvlddmkmBrowse full module liststart end module namefffff801`63ec0000 fffff801`649a7000 nvlddmkm T (no symbols)  Loaded symbol image file: nvlddmkm.sys Image path: \\SystemRoot\\system32\\DRIVERS\\nvlddmkm.sys Image name: nvlddmkm.sys Browse all global symbols functions data Timestamp: Wed Jul 8 15:43:44 2015 (559DA7A0) CheckSum: 00AA7491 ImageSize: 00AE7000 Translations: 0000.04b0 0000.04e4 0409.04b0 0409.04e4参数 1 包含指向TDR_RECOVERY_CONTEXT的指针。 如 ！analyze 输出中所示，如果你有关联代码的符号，则可以使用 dt 命令显示此数据。dbgcmd1: kd> dt dxgkrnl!_TDR_RECOVERY_CONTEXT ffffe000c2c404c0 +0x000 Signature : 0x52445476 +0x008 pState : 0xffffe000`c2b12a40 ?? +0x010 TimeoutReason : 9 ( TdrEngineTimeoutPromotedToAdapterReset ) +0x018 Tick : _ULARGE_INTEGER 0xb2 +0x020 pAdapter : 0xffffe000`c2a89010 DXGADAPTER +0x028 pVidSchContext : (null)  +0x030 GPUTimeoutData : _TDR_RECOVERY_GPU_DATA +0x048 CrtcTimeoutData : _TDR_RECOVERY_CONTEXT::<unnamed-type￾CrtcTimeoutData> +0x050 pProcessName : (null)  +0x058 DbgOwnerTag : 0xfffff801`6470c14c +0x060 PrivateDbgInfo : _TDR_DEBug_REPORT_PRIVATE_INFO +0xb00 pDbgReport : 0xffffe000`c2c3f750 _WD_DEBug_REPORT +0xb08 pDbgBuffer : 0xffffc000`bd000000 Void +0xb10 DbgBufferSize : 0x37515 +0xb18 pDumpBufferHelper : (null)  +0xb20 pDbgInfoExtension : 0xffffc000`ba7e47a0_DXGKARG_COLLECTDBGINFO_EXT +0xb28 pDbgBufferUpdatePrivateInfo : 0xffffc000`bd000140 Void +0xb30 ReferenceCount : 0n1 +0xb38 pResetCompletedEvent : (null) 参数 2 包含指向负责任设备驱动程序模块的指针， (例如，所有者标记) 。dbgcmd1: kd> ub fffff8016470c14cnvlddmkm+0x84c132:fffff801`6470c132 cc int 3fffff801`6470c133 cc int 3fffff801`6470c134 48ff254d2deaff jmp qword ptr [nvlddmkm+0x6eee88(fffff801`645aee88)]fffff801`6470c13b cc int 3fffff801`6470c13c 48ff252d2eeaff jmp qword ptr [nvlddmkm+0x6eef70(fffff801`645aef70)]fffff801`6470c143 cc int 3fffff801`6470c144 48ff257d2deaff jmp qword ptr [nvlddmkm+0x6eeec8(fffff801`645aeec8)]fffff801`6470c14b cc int 3你可能希望使用 k、kb、kc、kd、kp、kP、kv (Display Stack Backtrace) 命令来检查堆栈跟踪。dbgcmd1: kd> k # Child-SP RetAddr Call Site00 ffffd001`7d53d918 fffff801`61ba2b4c nt!KeBugCheckEx[d:\\th\\minkernel\\ntos\\ke\\amd64\\procstat.asm @ 122]01 ffffd001`7d53d920 fffff801`61b8da0e dxgkrnl!TdrBugcheckOnTimeout+0xec[d:\\th\\windows\\core\\dxkernel\\dxgkrnl\\core\\dxgtdr.cxx @ 2731]02 ffffd001`7d53d960 fffff801`61b8dd7f dxgkrnl!ADAPTER_RENDER::Reset+0x15e[d:\\th\\windows\\core\\dxkernel\\dxgkrnl\\core\\adapter.cxx @ 19443]03 ffffd001`7d53d990 fffff801`61ba2385 dxgkrnl!DXGADAPTER::Reset+0x177[d:\\th\\windows\\core\\dxkernel\\dxgkrnl\\core\\adapter.cxx @ 19316]04 ffffd001`7d53d9e0 fffff801`63c5fba7 dxgkrnl!TdrResetFromTimeout+0x15[d:\\th\\windows\\core\\dxkernel\\dxgkrnl\\core\\dxgtdr.cxx @ 2554]05 ffffd001`7d53da10 fffff801`63c47e5d dxgmms1!VidSchiRecoverFromTDR+0x11b[d:\\th\\windows\\core\\dxkernel\\dxgkrnl\\dxgmms1\\vidsch\\vidscher.cxx @ 1055]06 ffffd001`7d53dbc0 fffff801`aa55c698 dxgmms1!VidSchiWorkerThread+0x8d[d:\\th\\windows\\core\\dxkernel\\dxgkrnl\\dxgmms1\\vidsch\\vidschi.cxx @ 426]07 ffffd001`7d53dc00 fffff801`aa5c9306 nt!PspSystemThreadStartup+0x58[d:\\th\\minkernel\\ntos\\ps\\psexec.c @ 6845]08 ffffd001`7d53dc60 00000000`00000000 nt!KxStartSystemThread+0x16[d:\\th\\minkernel\\ntos\\ke\\amd64\\threadbg.asm @ 80]如果可以一致地重现停止代码，还可以在导致此停止代码的代码中设置断点，并尝试单步执行错误代码。有关详细信息，请参阅 使用 WinDbg 分析故障转储文件。如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。在系统登录事件查看器中查看其他错误消息，这些错误消息可能有助于识别导致此Bug 的设备或驱动程序检查。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。验证所有图形相关软件（如 DirectX 和 OpenGL）是否都是最新的，并且所有图形密集型应用程序 (（如游戏) ）都已完全修补。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以在Windows10规范 中获取有关所需硬件的信息。运行 Windows 内存诊断工具以测试内存。 在控制面板搜索框中，输入 “内存”，然后选择“ 诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 查找“内存诊断结果”条目以查看结果 。你可尝试运行系统制造商提供的硬件诊断。使用安全模式请考虑使用安全模式来帮助隔离此问题。 在 Windows 启动期间，使用安全模式仅加载所需的最低驱动程序和系统服务。1. 若要进入安全模式，请转到“设置”中的 “更新和安全 ”。2. 选择“ 恢复>高级启动 ”以启动到维护模式。3. 在生成的菜单中，选择“高级选项>疑难解答>”“启动设置>重启”。4. Windows 重启到 “启动设置” 屏幕后，选择选项 4、5 或 6 以启动到安全模式。可以通过在启动时按功能键（例如 F8）来使用安全模式。 有关特定启动选项，请参阅制造商提供的信息。有关常规故障排除信息，请参阅 蓝屏数据。有关硬件设备在实现 TDR 时必须满足的要求的信息，请参阅 Windows 硬件实验室工具包文档。 例如， TDR2 - 标准双设备测试图形。注解另请参阅Bug 检查代码参考0x116:VIDEO_TDR_FAILURE\n\n问题原因：\n\n显卡驱动故障\n\n解决方案：\n\n卸载显卡驱动，然后通过联想电脑管家更新显卡驱动。并更新Windows到最新版本。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x117": "BUG代码 0x117：VIDEO_TDR_TIMEOUT_DETECTED\n项目 • 2023/06/15VIDEO_TDR_TIMEOUT_DETECTED实时转储的值为 0x00000117。 这表示显示驱动程序无法及时响应。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明1 指向内部 TDR 恢复上下文的指针（如果可用）。2 指向负责设备驱动程序模块的指针 (例如，所有者标记) 。3 辅助驱动程序特定的存储桶密钥。4 内部上下文相关数据（如果可用）。当系统在处理最终用户命令或操作时出现完全冻结或挂起时，会出现图形中常见的稳定性问题。 通常，GPU 正忙于处理密集的图形操作，通常在玩游戏期间。 不会发生屏幕更新，并且用户假定其系统已冻结。 用户通常等待几秒钟，然后按电源按钮重新启动系统。 Windows 会尝试检测这些有问题的挂起情况，并动态恢复响应式桌面。此检测和恢复过程称为超时检测和恢复 (TDR) 。 默认超时为 2 秒。 在视频卡的 TDR 进程中，操作系统的 GPU 计划程序调用显示微型端口驱动程序的 DxgkDdiResetFromTimeout函数来重新初始化驱动程序并重置 GPU。如果恢复过程成功，将显示一条消息，指示“显示驱动程序已停止响应并已恢复”。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。VIDEO_TDR_TIMEOUT_DETECTED参数原因有关详细信息，请参阅超时检测和恢复 (TDR) 、TDR 注册表项和Windows 8中的 TDR 更改，这些更改位于超时检测和恢复 (TDR)解决方法GPU 花费的时间超过了向监视器显示图形所允许的时间。 以下一种或多种原因可能会导致此行为：可能需要安装显示驱动程序的最新更新，以便它正确支持 TDR 过程。影响视频卡正常运行能力的硬件问题，包括：时钟过度的组件，如主板错误的组件兼容性和设置 (尤其是内存配置和计时)系统冷却不足系统电源不足内存模块、主板等 (缺陷部件)视觉效果或后台运行的程序过多可能会减慢电脑速度，使视频卡无法根据需要做出响应。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。dbgcmd3: kd> !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************VIDEO_TDR_TIMEOUT_DETECTED (117)The display driver failed to respond in timely fashion.(This code can never be used for a real Bug check; it is used to identifylive dumps.)Arguments:Arg1: 8975d500, Optional pointer to internal TDR recovery context(TDR_RECOVERY_CONTEXT).Arg2: 9a02381e, The pointer into responsible device driver module (e.g ownertag).Arg3: 00000000, The secondary driver specific bucketing key.Arg4: 00000000, Optional internal context dependent data....还将显示出错的模块名称dbgcmdMODULE_NAME: atikmpagIMAGE_NAME: atikmpag.sys可以使用 lmv 命令显示有关故障驱动程序的信息，包括时间戳。dbgcmd3: kd> lmvm atikmpagBrowse full module liststart end module name9a01a000 9a09a000 atikmpag T (no symbols)  Loaded symbol image file: atikmpag.sys Image path: atikmpag.sys Image name: atikmpag.sys Browse all global symbols functions data Timestamp: Fri Dec 6 12:20:32 2013 (52A23190) CheckSum: 0007E58A ImageSize: 00080000 Translations: 0000.04b0 0000.04e4 0409.04b0 0409.04e4参数 1 包含指向TDR_RECOVERY_CONTEXT的指针。dbgcmd3: kd> dt dxgkrnl!_TDR_RECOVERY_CONTEXT fffffa8010041010 +0x000 Signature : ?? +0x004 pState : ????  +0x008 TimeoutReason : ?? +0x010 Tick : _ULARGE_INTEGER +0x018 pAdapter : ????  +0x01c pVidSchContext : ????  +0x020 GPUTimeoutData : _TDR_RECOVERY_GPU_DATA +0x038 CrtcTimeoutData : _TDR_RECOVERY_CONTEXT::<unnamed-type￾CrtcTimeoutData> +0x040 DbgOwnerTag : ?? +0x048 PrivateDbgInfo : _TDR_DEBug_REPORT_PRIVATE_INFO +0xae0 pDbgReport : ????  +0xae4 pDbgBuffer : ????  +0xae8 DbgBufferSize : ?? +0xaec pDumpBufferHelper : ????  +0xaf0 pDbgInfoExtension : ????  +0xaf4 pDbgBufferUpdatePrivateInfo : ????  +0xaf8 ReferenceCount : ??Memory read error 10041b08参数 2 包含指向负责设备驱动程序模块的指针， (例如，所有者标记) 。dbgcmdBugCHECK_P2: ffffffff9a02381e你可能希望使用 k、kb、kc、kd、kp、kP、kv (Display Stack Backtrace) 命令检查堆栈跟踪。dbgcmd3: kd> k # ChildEBP RetAddr 00 81d9ace0 976e605e dxgkrnl!TdrUpdateDbgReport+0x93[d:\\blue_gdr\\windows\\core\\dxkernel\\dxgkrnl\\core\\dxgtdr.cxx @ 944]01 81d9acfc 976ddead dxgkrnl!TdrCollectDbgInfoStage2+0x195[d:\\blue_gdr\\windows\\core\\dxkernel\\dxgkrnl\\core\\dxgtdr.cxx @ 1759]02 81d9ad24 976e664f dxgkrnl!DXGADAPTER::Reset+0x23f[d:\\blue_gdr\\windows\\core\\dxkernel\\dxgkrnl\\core\\adapter.cxx @ 14972]03 81d9ad3c 977be9e0 dxgkrnl!TdrResetFromTimeout+0x16[d:\\blue_gdr\\windows\\core\\dxkernel\\dxgkrnl\\core\\dxgtdr.cxx @ 2465]04 81d9ad50 977b7518 dxgmms1!VidSchiRecoverFromTDR+0x13[d:\\blue_gdr\\windows\\core\\dxkernel\\dxgkrnl\\dxgmms1\\vidsch\\vidscher.cxx @1018]05 (Inline) -------- dxgmms1!VidSchiRun_PriorityTable+0xfa7106 81d9ad70 812c01d4 dxgmms1!VidSchiWorkerThread+0xfaf2[d:\\blue_gdr\\windows\\core\\dxkernel\\dxgkrnl\\dxgmms1\\vidsch\\vidschi.cxx @ 424]07 81d9adb0 81325fb1 nt!PspSystemThreadStartup+0x58[d:\\blue_gdr\\minkernel\\ntos\\ps\\psexec.c @ 5884]08 81d9adbc 00000000 nt!KiThreadStartup+0x15[d:\\blue_gdr\\minkernel\\ntos\\ke\\i386\\threadbg.asm @ 81]如果能够一致地重现停止代码，还可以在导致此停止代码的代码中设置断点，并尝试向前单步执行故障代码。有关详细信息，请参阅以下主题：使用 Windows 调试器 (WinDbg) 进行故障转储分析如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。检查事件查看器中的系统日志，了解可能有助于识别导致此 Bug 检查的设备或驱动程序的其他错误消息。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。验证与图形相关的所有软件（如 DirectX 和 OpenGL）是否都是最新的，并且所有图形密集型应用程序 (（如游戏) ）是否已完全修补。确认安装的任何新硬件都与已安装的 Windows 版本兼容。 例如，可以在Windows10规范 中获取有关所需硬件的信息。使用安全模式请考虑使用安全模式来帮助隔离此问题。 在 Windows 启动期间，使用安全模式仅加载所需的最低驱动程序和系统服务。 若要进入安全模式，请使用“设置 ”中的“更新和安全 ”。 选择“ 恢复->高级启动 ”以启动到维护模式。 在生成的菜单中，选择“故障排除”->“高级选项” ->“启动设置” -“>重启”。 Windows 重启到 “启动设置” 屏幕后，选择选项 4、5 或 6 以启动到安全模式。可以通过在启动时按功能键（例如 F8）来使用安全模式。 有关特定启动选项，请参阅制造商提供的信息。运行 Windows 内存诊断工具以测试内存。 在控制面板搜索框中，键入“内存”，然后选择“ 诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 查找“内存诊断结果”条目以查看结果 。你可尝试运行系统制造商提供的硬件诊断。有关其他常规故障排除信息，请参阅 蓝屏数据。注解硬件认证要求有关硬件设备在实现 TDR 时必须满足的要求的信息，请参阅 Device.Graphics... 上的WHCK 文档TDRResiliency。", "0x119": "BUG代码 0x119：VIDEO_SCHEDULER_INTERNAL_ERROR\n项目 • 2023/05/25VIDEO_SCHEDULER_INTERNAL_ERROR Bug 检查 的值为 0x00000119。 此 Bug 检查指示视频计划程序检测到严重冲突。参数 1 是唯一感兴趣的参数。 它标识确切的冲突。参数 1 错误原因0x1 驱动程序报告了无效的围栏 ID。 (DRIVER_REPORTED_INVALID_FENCE_ID)0x2 驱动程序在提交命令时失败。 (DRIVER_FAILED_SUBMIT_COMMAND)0x3 驱动程序在修补命令缓冲区时失败。 (DRIVER_FAILED_PATCH_COMMAND)0x4 驱动程序报告了无效的翻转功能。 (DRIVER_INVALID_FLIPQUEUE_LENGTH)0x5 驱动程序使系统或分页命令失败。 (DRIVER_FAULTED_SYSTEM_COMMAND)0x6 驱动程序报告 NULL PhysicalAdapterMask，以便在多适配器 GPU 上引发的中断。(DRIVER_INVALID_ADAPTER_MASK)0x7 驱动程序报表仅在呈现适配器上显示 VSync。(REPORT_VSYNC_ON_RENDER_ONLY_ADAPTER)0x8 驱动程序在 DMA 页面错误中断中报告了错误的 PageFaultFlags。(INVALID_NODE_MASK)0x9 驱动程序在取消命令上失败。 (FAILED_CANCEL_COMMAND)0xA 驱动程序报告且范围外无效，已中止围栏。 (REPORTED_INVALID_ABORTED_FENCE)0xB 驱动程序失败 SetVidPnSourceAddressWithMultiPlaneOverlay 命令。(FAILED_SETVIDPNSOURCEMPO_COMMAND)0xC 驱动程序 PageFaultFlags 指示严重硬件故障。 (FATAL_PAGE_FAULT)） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_SCHEDULER_INTERNAL_ERROR参数参数 1 错误原因0xD 驱动程序在 DMA 页面错误中断中报告了错误的 PageFaultFlags。(INVALID_DMA_FAULT_PARAMETERS)0xE 驱动程序报告的平面索引大于 GPU 上最大覆盖平面的平面索引的 VSync。(REPORT_VSYNC_PLANE_OUT_OF_RANGE)0xF 未使用。 (FAILED_POSTMPOPRESENT_COMMAND)0x10 驱动程序在引擎重置后和 OS 恢复引擎之前报告了意外中断。(UNEXPECTED_INTERRUPT_AFTER_RESET)0x11 驱动程序报告 OS 尚未生成的挂起上下文已完成围栏值。(INCORRECT_SUSPEND_FENCE)0x400 这是一个内部 OS 状态错误，通常是由内存损坏或硬件损坏引起的。0xE00 预分配的数据包用于处理被动翻转请求的 OS 内存不足。0x1000 这是一个内部 OS 状态错误，通常是由内存损坏或硬件损坏引起的。0xA000 这是一个内部 OS 状态错误，通常是由内存损坏或硬件损坏引起的。0x10000 这是一个内部 OS 状态错误，通常是由内存损坏或硬件损坏引起的。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。如果 ！analyze 输出中列出的故障模块是视频驱动程序，请查看供应商提供的该视频驱动程序是否有可用的更新。处理命令和 DMA 缓冲区提交命令缓冲区提供围栏标识符视频内存管理和 GPU 计划视频内存的直接交替解决方法另请参阅0x119:VIDEO_SCHEDULER_INTERNAL_ERROR\n\n问题原因：\n\n显卡驱动故障\n\n解决方案：\n\n卸载显卡驱动，然后通过联想电脑管家更新显卡驱动。并更新Windows到最新版本。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x11A": "BUG代码 0x11A：EM_INITIALIZATION_FAILURE\n项目 • 2023/06/20EM_INITIALIZATION_FAILURE Bug 检查 的值为 0x0000011A。此 Bug 检查很少出现。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x11B": "BUG代码 0x11B：DRIVER_RETURNED_HOLDING_CANCEL_LOCK\n项目 • 2023/06/20DRIVER_RETURNED_HOLDING_CANCEL_LOCK Bug 检查 的值为 0x0000011B。 此 Bug 检查指示驱动程序已从保留全局取消锁的取消例程返回。 这会导致以后的所有取消调用失败，并导致死锁或其他 Bug 检查。参数 描述1 (取消的 IRP 的地址可能无效) 。2 取消例程的地址。取消自旋锁应已由 取消 例程释放。驱动程序调用 IoCancelIrpIoCancelIrp 函数以取消单个 I/O 请求数据包 (IRP) 。 此函数获取取消旋转锁，在 IRP 中设置取消标志，然后调用由 IRP 中相应字段指定的 取消 例程（如果指定了例程）。 取消例程应释放取消旋转锁。 如果没有 取消 例程，则会释放取消旋转锁。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_RETURNED_HOLDING_CANCEL_LOCK参数备注", "0x11C": "BUG代码 0x11C：ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE\n项目 • 2023/06/20ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE Bug 检查 值为 0x0000011C。 此 Bug检查指示已尝试写入配置管理器的只读受保护存储。参数 说明1 尝试写入的虚拟地址2 PTE 内容3 保留4 保留如果可能，尝试写入操作的驱动程序的名称将打印为 Bug 检查 屏幕上的 Unicode 字符串，然后保存在 KiBugCheckDriver 中。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE参数备注", "0x11D": "BUG代码 0x11D：EVENT_TRACING_FATAL_ERROR\n项目 • 2023/06/20EVENT_TRACING_FATAL_ERROR Bug 检查 的值为 0x0000011D。 此 Bug 检查表示事件跟踪子系统遇到意外的致命错误。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。解决方法在内核调试器中，使用 ！analyze -v 命令执行初始 Bug 检查分析。 参数 1 将列出 Bug检查的子类型。0x01：无法初始化安全性。0x02：无法初始化处理器。0x03：内核模式注册损坏。0x04：取消注册中的句柄无效。0x05：EventWrite 调用中的数据溢出。0x06 ：事件已丢失。0x07：跟踪缓冲区损坏。0x08：无法为 ETW LoggerContext 分配缓存感知的运行保护。 参数 2 将包含记录器ID。0x09：ETW GuidEntry 的引用计数对于对象的当前状态是非法的。 参数 2 将包含指向ETW_GUID_ENTRY的指针。另请参阅使用 Windows 调试器 (WinDbg) 进行故障转储分析使用 WinDbg 分析内核模式转储文件", "0x11E": "BUG代码 0x11E：TOO_MANY_RECURSIVE_FAULTS\n项目 • 2023/06/20TOO_MANY_RECURSIVE_FAULTS Bug 检查 的值为 0x0000011E。 这表示文件系统在资源不足的情况下导致处理过多的递归错误。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TOO_MANY_RECURSIVE_FAULTS参数无", "0x11F": "BUG代码 0x11F：INVALID_DRIVER_HANDLE\n项目 • 2023/06/20INVALID_DRIVER_HANDLE Bug 检查 的值为 0x0000011F。 这表示有人在插入驱动程序对象和引用句柄之间关闭了驱动程序的初始句柄。参数 描述1 驱动程序对象的句柄值。2 尝试引用 对象时返回的状态。3 PDRIVER_OBJECT的地址。4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_DRIVER_HANDLE参数", "0x120": "BUG代码 0x120：BITLOCKER_FATAL_ERROR\n项目 • 2023/06/20BITLOCKER_FATAL_ERROR Bug 检查 的值为 0x00000120。 这表明 BitLocker 驱动器加密遇到了无法恢复的问题。参数 说明1 问题类型2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BITLOCKER_FATAL_ERROR参数", "0x121": "BUG代码 0x121：DRIVER_VIOLATION\n项目 • 2023/06/20DRIVER_VIOLATION Bug 检查 的值为 0x00000121。 此 Bug 检查 指示驱动程序已导致冲突。参数 1 指示冲突的类型。参数 1 参数 2 参数 3 参数 4 原因0x1 当前 IRQL。 所需的 IRQL。 保留 驱动程序调用了只能在特定 IRQL中调用的函数。使用内核调试器并查看调用堆栈以确定导致冲突的驱动程序的名称：！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因，然后输入 k (显示堆栈回溯) 命令之一以查看调用堆栈。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_VIOLATION参数备注", "0x122": "BUG代码 0x122：WHEA_INTERNAL_ERROR\n项目 • 2023/06/15WHEA_INTERNAL_ERROR Bug 检查 的值为 0x00000122。 此 Bug 检查 指示 Windows 硬件错误体系结构 (WHEA) 发生了内部错误。 错误可能由供应商提供的特定于平台的硬件错误驱动程序实现 (PSHED) 插件、错误记录的固件实现或错误注入的固件实现中的 Bug导致。参数 1 参数 2 参数 3 参数 4 错误原因0x1 内存大小 错误源计数 0 未能为硬件错误源表中的所有错误源分配足够的内存。0x2 处理器数目 0 0 未能为每个处理器的 WHEA 信息块分配足够的内存。0x5 状态 阶段 (Bug 检查)的初始化阶段0 WHEA 未能为错误源分配足够的内存，或者错误源枚举失败。0x6 状态 阶段 错误源类型 在参数 3 指定的阶段 (参数 4) 初始化错误源失败。0x7 状态 0 0 未能分配足够的内存。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。WHEA_INTERNAL_ERROR参数参数 1 参数 2 参数 3 参数 4 错误原因0x8 错误源数 0 0 未能为所有错误源描述符分配足够的内存。0x9 错误源类型 源 ID 0 WHEA 收到来自无效错误源的未更正错误源。0xA 错误源类型 源 ID 0 未能为未更正的错误分配错误记录。0xB 错误源类型 源 ID 0 未能为未更正的错误填充错误记录。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。如果参数 1 等于 0x6、0x9、0xA 或 0xB，则其他参数之一包含错误源类型。 下表提供了错误源类型的可能值。值 说明0x00 计算机检查异常0x01 更正的计算机检查0x02 更正的平台错误0x03 不可屏蔽的中断0x04 PCI Express 错误0x05 其他类型的错误源/泛型0x06 IA64 INIT 错误源0x07 BOOT 错误源0x08 基于 SCI 的泛型错误源0x09 Itanium 计算机检查中止0x0A Itanium 机器检查0x0B Itanium 更正的平台错误注解", "0x123": "BUG代码 0x123：CRYPTO_SELF_TEST_FAILURE\n项目 • 2023/06/20CRYPTO_SELF_TEST_FAILURE Bug 检查 值为 0x00000123。 这表示加密子系统在启动期间未通过强制算法自测试。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CRYPTO_SELF_TEST_FAILURE参数无", "0x124": "BUG代码 0x124：WHEA_UNCORRECTABLE_ERROR\n项目 • 2023/06/15检查WHEA_UNCORRECTABLE_ERROR Bug 的值为 0x00000124，表示发生了严重硬件错误。 此 Bug 检查使用 Windows 硬件错误体系结构 (WHEA) 提供的错误数据。若要确定错误的具体原因，通常需要了解 WHEA_ERROR_RECORD 结构。 有关详细信息，请参阅本文的 备注部分 。参数1参数 2 参数 3 参数 4 错误原因0x0 WHEA_ERROR_RECORD结构的地址具有错误的MCA 库的高32 位MCi_STATUSMSR具有错误的MCA 库的低32 位MCi_STATUSMSR发生计算机检查异常。如果处理器基于 x64 体系结构，或具有 MCA 功能的 x86 体系结构(例如 IntelPentium Pro、PentiumIV 或 Xeon) ，则这些参数说明适用。0x1 WHEA_ERROR_RECORD结构的地址预留 预留 发生异常检查更正的计算机。0x2 WHEA_ERROR_RECORD结构的地址预留 预留 发生了更正的平台错误。0x3 WHEA_ERROR_RECORD结构的地址预留 预留 发生不可掩码的中断 (NMI) 错误。0x4 WHEA_ERROR_RECORD结构的地址预留 预留 发生无法更正的 PCI Express 错误。0x5 WHEA_ERROR_RECORD结构的地址预留 预留 发生一般硬件错误。） 重要本主题面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。参数参数1参数 2 参数 3 参数 4 错误原因0x6 WHEA_ERROR_RECORD结构的地址预留 预留 出现初始化错误。0x7 WHEA_ERROR_RECORD结构的地址预留 预留 发生 BOOT 错误。0x8 WHEA_ERROR_RECORD结构的地址预留 预留 发生一般错误 (SCI) 可缩放的一致接口。0x9 WHEA_ERROR_RECORD结构的地址SAL 日志的长度（以字节为单位）SAL 地址 发生不可更正的基于 Itanium 的计算机检查中止错误。0xA WHEA_ERROR_RECORD结构的地址预留 预留 更正了基于 Itanium 的计算机检查发生错误。0xB WHEA_ERROR_RECORD结构的地址预留 预留 发生了更正的 Itanium 平台错误。0xC WHEA_ERROR_RECORD结构的地址预留 预留 其他类型的错误源 v2。0xD WHEA_ERROR_RECORD结构的地址预留 预留 基于 SCI 的 GHESv2 (ACPI 泛型硬件错误源) 。0xE WHEA_ERROR_RECORD结构的地址预留 预留 BMC (基板管理控制器) 错误信息。0xF WHEA_ERROR_RECORD结构的地址预留 预留 ARS PMEM (地址范围清理永久性内存) 错误源。0x10 WHEA_ERROR_RECORD结构的地址预留 预留 设备驱动程序错误源。0x11 WHEA_ERROR_RECORD结构的地址预留 预留 Arm 同步外部中止。0x12 WHEA_ERROR_RECORD结构的地址预留 预留 Arm SError 中断。此 Bug 检查通常与物理硬件故障相关。 它可能与热相关，也可能是由于硬件、内存或处理器开始发生故障或发生故障而导致的。 如果已启用超时钟，请尝试禁用它。 确认任何冷却系统（如风扇）都正常工作。 运行系统诊断以确认系统内存没有缺陷。 驱动程序导致硬件故障的可能性较小，但有可能检查此 Bug。原因若要详细了解常规 Bug 检查故障排除，请参阅蓝屏数据。注解！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因。参数 1 标识报告错误的错误源的类型。参数 2 保存描述错误条件 的WHEA_ERROR_RECORD 结构的地址。发生硬件错误时，WHEA 会创建错误记录来存储与硬件错误条件关联的错误信息。 每个错误记录由WHEA_ERROR_RECORD结构描述。 Windows 内核将错误记录与 Windows(ETW 的事件跟踪) 硬件错误事件包含在响应错误时引发的错误记录，以便错误记录保存在系统事件日志中。 WHEA 使用的错误记录的格式基于通用平台错误记录，如统一可扩展固件接口版本 2.2 的附录 N 中所述 (UEFI) 规范。 有关详细信息，请参阅WHEA_ERROR_RECORD 和 Windows 硬件错误体系结构 (WHEA) 。可以使用 ！errrec address 使用参数 2 中提供的地址显示WHEA_ERROR_RECORD结构。！whea 和 ！errpkt 扩展可用于显示其他 WHEA 信息。有关详细信息，请参阅以下文章：使用 Windows 调试器 (WinDbg) 进行故障转储分析使用 WinDbg 分析内核模式转储文件使用 ！analyze 扩展 和 ！analyze此 Bug 检查在 Windows Vista 之前的 Windows 版本中不受支持。 而是通过0x124:WHEA_UNCORRECTABLE_ERROR\n\n问题原因：\n\n硬件故障（通常是CPU）\n\n解决方案：\n\n请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x125": "BUG代码 0x125：NMR_INVALID_STATE\n项目 • 2023/06/15NMR_INVALID_STATE Bug 检查 的值为 0x00000125。 这表明 NMR (网络模块注册器) 检测到无效状态。 有关状态类型，请参阅参数 1。参数 说明） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。NMR_INVALID_STATE参数参数 说明1 Bug 检查的子类型。0x0：计算机检查异常参数 2 - WHEA_ERROR_RECORD结构的地址。参数 3 - MCi_STATUS值的高阶 32 位。参数 4 - MCi_STATUS值的低序 32 位。0x1：更正了计算机检查参数 2 - WHEA_ERROR_RECORD结构的地址。0x2：更正了平台错误参数 2 - WHEA_ERROR_RECORD结构的地址。0x3：不可屏蔽的中断参数 2 - WHEA_ERROR_RECORD结构的地址。0x4：PCI Express 错误参数 2 - WHEA_ERROR_RECORD结构的地址。0x5：一般错误参数 2 - WHEA_ERROR_RECORD结构的地址。0x6：INIT 错误参数 2 - WHEA_ERROR_RECORD结构的地址。0x7：BOOT 错误参数 2 - WHEA_ERROR_RECORD结构的地址。0x8：SCI 泛型错误参数 2 - WHEA_ERROR_RECORD结构的地址。0x9： Itanium Machine Check Abort参数 2 - WHEA_ERROR_RECORD结构的地址。参数 3 - SAL 日志的长度（以字节为单位）。 参数 4 - SAL 日志的地址。0xa：Itanium 更正的计算机检查参数 2 - WHEA_ERROR_RECORD结构的地址。0xb：Itanium 更正的平台错误参数 2 - WHEA_ERROR_RECORD结构的地址。2 指向 NMI 句柄的指针3 指向预期类型的指针（如果可用）4 预留", "0x126": "BUG代码 0x126：NETIO_INVALID_POOL_CALLER\n项目 • 2023/06/21NETIO_INVALID_POOL_CALLER Bug 检查的值为 0x00000126。 这表示已向 netio 托管内存池（例如 FSB 和 MDL）发出了无效的池请求。参数 描述1 Bug 检查的子类型。0x1：池无效。 池处于无效状态。参数 2 - 指向内存块或 MDL 的指针。 参数 3 -指向页面的指针。 参数 4 - 指向 CPU 池的指针。0x2：MDL 无效。 MDL 处于无效状态。参数 2 - 指向 MDL 的指针。 参数 3 - 指向 CPU池的指针。 参数 4 - 指向池标头的指针。2 请参阅参数 13 请参阅参数 14 请参阅参数 1!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。NETIO_INVALID_POOL_CALLER参数解决方法", "0x127": "BUG代码 0x127：PAGE_NOT_ZERO\n项目 • 2023/06/20PAGE_NOT_ZERO Bug 检查的值为 0x00000127。 此 Bug 检查指示本应使用零填充的页面没有。 此 Bug 检查可能是由于硬件错误或操作系统的特权组件在释放页面后修改了页面。参数 描述1 映射损坏页面的虚拟地址2 物理页码3 零 (保留)4 零 (保留)） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PAGE_NOT_ZERO参数", "0x128": "BUG代码 0x128：WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY\n项目 • 2023/06/20WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY Bug 检查 的值为 0x00000128。 这表示被调用的工作线程例程错误地修改了工作线程 IOPriority。参数 描述1 工作线程例程 (在此地址上使用 ln (List Nearest Symbols) 命令查找有问题的驱动程序)2 当前 IoPrioirity 值3 Workitem 参数4 Workitem 地址） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY参数", "0x129": "BUG代码 0x129：WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY\n项目 • 2023/06/20WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY Bug 检查 的值为 0x00000129。 这表示被调用的辅助角色例程错误地修改了分页 IOPriority 的工作线程。参数 说明1 辅助角色例程的地址在此地址上使用 ln (List Nearest Symbols) 命令查找有问题的驱动程序。2 当前分页 IoPrioirity 值3 Workitem 参数4 工作项地址） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY参数", "0x12A": "BUG代码 0x12A：MUI_NO_VALID_SYSTEM_LANGUAGE\n项目 • 2023/06/20MUI_NO_VALID_SYSTEM_LANGUAGE Bug 检查 的值为 0x0000012A。 这表明 Windows找不到系统默认 UI 语言的任何已安装的许可语言包。参数 描述1 Bugcheck 的子类型0x1：Windows 在第一阶段初始化期间找不到任何已安装的语言包。参数 2 - 描述失败原因的 NT 状态代码。0x2：在内核缓存创建过程中，Windows 找不到系统默认 UI 语言的任何已安装的许可语言包。参数 2 - 描述失败原因的 NT 状态代码。 .2 请参阅参数 13 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MUI_NO_VALID_SYSTEM_LANGUAGE参数", "0x12B": "BUG代码 0x12B：FAULTY_HARDWARE_CORRUPTED_PAGE\n项目 • 2023/06/15FAULTY_HARDWARE_CORRUPTED_PAGE Bug 检查 的值为 0x0000012B。 此 Bug 检查指示 Windows 内存管理器检测到损坏。 这种损坏只能由使用物理寻址访问内存的组件引起。有两种情况，内存管理器使用两组不同的参数引发FAULTY_HARDWARE_CORRUPTED_PAGE Bug 检查。如果参数 3 和参数 4 均为零，则 Bug 检查指示内存管理器在页中检测到内存管理器预期为零的单位错误。如果参数 3 和 4 不为零，则压缩存储管理器会引发 Bug 检查，原因是由于物理内存损坏而无法解压缩页面。此 Bug 检查指示在此页中发现了单位错误。 此错误是硬件内存错误。参数 说明1 虚拟地址映射到损坏的页面2 物理页码3 零个4 零个） 重要本主题面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FAULTY_HARDWARE_CORRUPTED_PAGE参数内存管理器页不为零的错误参数压缩的存储管理器错误参数此 Bug 检查指示发生了存储管理器内存错误。 这可能是身份验证失败、CRC 失败或解压缩失败。参数 说明1 FailStatus - 指示失败的类型2 正在读取的页面的 CompressedSize3 源缓冲区4 目标缓冲区此 Bug 检查只能通过物理内存访问导致的内存损坏发生。 物理内存损坏的原因包括：RAM 硬件有缺陷。驱动程序或设备通过错误的 DMA 操作或关联的 MDL 错误地修改物理页。硬件设备或固件损坏内存导致的损坏，例如固件在电源转换中非法修改物理页面。有关 Windows 内存管理器和内存压缩的详细信息，请参阅 Windows Internals 7thEdition 第 1 部分。若要调查此 Bug 检查是否由 RAM 硬件缺陷引起，请运行 Windows 内存诊断工具。 在控制面板搜索框中，输入“内存”，然后选择“诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 选择 “MemoryDiagnostics-Results” 条目以查看结果。Bug 检查代码参考原因７ 备注压缩的存储管理器可以检测损坏是否由单位错误引起，并自动更正此情况，而不会引发 Bug 检查。 如果损坏不是由单个位错误引起的，则压缩存储管理器会报告此Bug 检查。解决方法另请参阅Windows 内核模式内存管理器0x12B:FAULTY_HARDWARE_CORRUPTED_PAGE\n\n问题原因：\n\n硬件故障（通常是RAM）\n\n解决方案：\n\n请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x12C": "BUG代码 0x12C：EXFAT_FILE_SYSTEM\n项目 • 2023/06/20EXFAT_FILE_SYSTEM Bug 检查 值为 0x0000012C。 此 Bug 检查指示扩展文件分配表(exFAT) 文件系统中出现问题。参数 描述1 指定源文件和行号信息。 高 16 位 (“0x”之后的前四位十六进制数字，) 按标识符号确定源文件。 低 16 位确定文件中发生 Bug 检查的源行。2 如果 FppExceptionFilter 位于堆栈上，则此参数指定异常记录的地址。3 如果 FppExceptionFilter 位于堆栈中，则此参数指定上下文记录的地址。4 保留。此 Bug 检查是由文件系统引起的，当文件系统的内部记帐处于不可支持状态并且持续存在数据丢失风险时，这是最后的手段。 当磁盘结构损坏、磁盘扇区损坏或内存分配失败时，文件系统永远不会导致此 Bug 检查。 坏扇区可能会导致 Bug 检查，例如，当内核代码或数据中发生页面错误，并且内存管理器无法读取页面时。 但是，对于此 Bug 检查，文件系统不是原因。若要调试此问题，请执行以下操作： 将 .cxr (Display Context Record) 命令与参数 3 结合使用，然后使用 kb (显示堆栈回溯) 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。EXFAT_FILE_SYSTEM参数原因解决方法", "0x12D": "BUG代码 0x12D：VOLSNAP_OVERLAPPED_TABLE_ACCESS\n项目 • 2023/06/20VOLSNAP_OVERLAPPED_TABLE_ACCESS Bug 检查 的值为 0x0000012D。 这表示 volsnap尝试从两个不同的线程访问公用表，这可能会导致表损坏并最终损坏表。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VOLSNAP_OVERLAPPED_TABLE_ACCESS参数无", "0x12E": "BUG代码 0x12E：INVALID_MDL_RANGE\n项目 • 2023/06/20INVALID_MDL_RANGE Bug 检查的值为 0x0000012E。 这表明驱动程序已调用IoBuildPartialMdl () 函数，并向其传递 MDL 以映射源 MDL 的一部分，但指定的虚拟地址范围超出了源 MDL 中的范围。 这通常是驱动程序 Bug。源和目标 MDL 以及要映射的地址范围长度是 IoBuildPartialMdl () 函数的参数，即 ) 。C++参数 说明1 SourceMdl2 TargetMdl3 VirtualAddress4 长度IoBuildPartialMdl( IN PMDL SourceMdl, IN OUT PMDL TargetMdl, IN PVOID VirtualAddress, IN ULONG Length） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_MDL_RANGE参数", "0x12F": "BUG代码 0x12F：VHD_BOOT_INITIALIZATION_FAILED\n项目 • 2023/06/20VHD_BOOT_INITIALIZATION_FAILED Bug 检查 的值为 0x0000012F。 这表示尝试从 VHD启动时发生初始化失败。参数 描述1 失败的操作1：无法从启动设备中提取 VHD 信息。 2：等待VHD 父设备显示超时。 3：VHD 路径字符串内存分配错误。 4：VHD 路径构造失败。 5：VHD启动设备装载失败。 6：禁用睡眠状态失败。7：VHD 信息内存分配错误。 8：VHD 信息构造失败。2 NT 状态代码3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VHD_BOOT_INITIALIZATION_FAILED参数", "0x130": "BUG代码 0x130：DYNAMIC_ADD_PROCESSOR_MISMATCH\n项目 • 2023/06/20DYNAMIC_ADD_PROCESSOR_MISMATCH Bug 检查 值为 0x00000130。 此 Bug 检查指示添加到系统的新处理器与当前配置不兼容。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DYNAMIC_ADD_PROCESSOR_MISMATCH参数无", "0x131": "BUG代码 0x131：INVALID_EXTENDED_PROCESSOR_STATE\n项目 • 2023/06/20INVALID_EXTENDED_PROCESSOR_STATE Bug 检查 的值为 0x00000131。 这表示在保存或还原扩展处理器状态时检测到参数组合无效。参数 1 指示检查失败的有效性。参数 描述1 0 - 传递的功能掩码无效或未启用扩展处理器状态。2 如果启用了扩展状态，则为非零。3 功能掩码的低 32 位。4 特征掩码的高 32 位。参数 描述1 1 - 尝试在高于 DISPATCH_LEVEL 的 IRQL 处保存或还原扩展状态。2 The IRQL3 保留4 保留参数 描述1 2 - 以前保存的状态为相等或更高的级别。2 保存的级别。3 当前级别。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_EXTENDED_PROCESSOR_STATE参数参数 描述4 保留参数 描述1 3 - 以前保存的状态适用于不同的线程。2 保存的线程。3 当前线程。4 保留参数 描述1 4 - 以前保存的状态为不同的级别。2 保存的级别。3 当前级别。4 保留", "0x132": "BUG代码 0x132：RESOURCE_OWNER_POINTER_INVALID\n项目 • 2023/06/20RESOURCE_OWNER_POINTER_INVALID Bug 检查的值为 0x00000132。 这表示提供了无效的资源所有者指针。参数 描述1 资源2 Resource-OwnerTable>3 CurrentThread4 OwnerPointer） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。RESOURCE_OWNER_POINTER_INVALID参数Bug 检查0x133：DPC_WATCHDOG_VIOLATION\n项目 • 2023/06/20DPC_WATCHDOG_VIOLATION Bug 检查 的值为 0x00000133。 此 Bug 检查指示执行 DPC 监视器，可能是因为它检测到一个长时间运行的延迟过程调用 (DPC) ，或者因为系统长时间在中断请求级别花费了(IRQL) DISPATCH_LEVEL 或更高版本。参数 1 的值指示单个 DPC 是否超过超时，或者系统是否累积花费了在 IRQL DISPATCH_LEVEL 或更高版本的时间。 DPC 的运行时间不应超过 100 微秒，ISR 的运行时间不应超过 25 微秒，但系统上的实际超时值设置要高得多。有关 DPC 的详细信息，请参阅由 Pavel Yosifovich、Mark E. Russinovich、David A. Solomon 和 AlexIonescu 撰写的 DPC 对象 和 Windows 内部 7th 版简介第 1 部分 。参数 1 指示冲突的类型。 其他参数的含义取决于 参数 1 的值。参数1参数 2参数 3 参数 4 错误消息的原因0 DPC时间计数(刻度)DPC 时间分配 (刻度) 。 强制转换为 nt！DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK，其中包含有关此单个 DPC 超时的其他信息单个 DPC 或 ISR超出了其时间分配。 通常可以使用堆栈跟踪来标识有问题的组件。1 监视程序周期强制转换为 nt！DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK，其中包含有关此单个 DPC 超时的其他信息保留 系统累计在 IRQLDISPATCH_LEVEL或更高版本中花费了较长时间。通常可以使用堆栈跟踪来标识有问题的组件。若要确定原因，需要 Windows 调试器、编程经验和对故障模块源代码的访问权限。有关详细信息，请参阅以下主题：使用 Windows 调试器 (WinDbg) 进行故障转储分析） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DPC_WATCHDOG_VIOLATION参数原因使用 WinDbg 分析内核模式转储文件使用 ！analyze 扩展 和 ！analyze有关 Windows DPC 的详细信息，请参阅由 Pavel Yosifovich、Mark E. Russinovich、David A. Solomon和 Alex Ionescu 撰写的 Windows Internals 7th Edition 第 1 部分 。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。参数 1 = 0在此示例中，501 的时钟周期计数超过了 500 的 DPC 时间分配。 映像名称指示此代码在 Bug 检查发生时正在执行。dbgcmd使用以下调试器命令收集参数为 0 的失败的详细信息：k (显示堆栈回溯) 查看停止代码发生时正在运行的代码。你可能想要使用 u、ub、uu (Unassemble) 命令来更深入地了解正在运行的代码的具体情况。！pcr 扩展显示处理器控制区域的当前状态， (特定处理器上的 PCR) 。 在输出中为 Prcb 的地址dbgcmd示例 10: kd> !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************DPC_WATCHDOG_VIOLATION (133)The DPC watchdog detected a prolonged run time at an IRQL of DISPATCH_LEVELor above.Arguments:Arg1: 0000000000000000, A single DPC or ISR exceeded its time allotment. The offending component can usually be identified with a stack trace.Arg2: 0000000000000501, The DPC time count (in ticks).Arg3: 0000000000000500, The DPC time allotment (in ticks).Arg4: 0000000000000000...IMAGE_NAME: BthA2DP.sys...0: kd> !pcrKPCR for Processor 0 at fffff8035f5a4000: Major 1 Minor 1NtTib.ExceptionList: fffff80368e77fb0 NtTib.StackBase: fffff80368e76000 NtTib.StackLimit: 0000000000000000 NtTib.SubSystemTib: fffff8035f5a4000可以使用 dt (Display Type) 命令显示有关 DPC 和 DPC 监视器的其他信息。 对于地址，请使用 ！pcr 输出中列出的 Prcb：dbgcmddbgcmd参数 1 = 1对于参数 1，代码不能在代码的违规区域中停止。 在这种情况下，一种方法是使用事件跟踪来尝试跟踪哪个驱动程序超过其正常执行持续时间。使用 ！analyze 调试扩展显示有关 Bug 检查的信息。dbgcmd NtTib.Version: 000000005f5a4180 NtTib.UserPointer: fffff8035f5a4870 NtTib.SelfTib: 000000b6d3086000 SelfPcr: 0000000000000000 Prcb: fffff8035f5a4180 Irql: 0000000000000000 IRR: 0000000000000000 IDR: 0000000000000000 InterruptMode: 0000000000000000 IDT: 0000000000000000 GDT: 0000000000000000 TSS: 0000000000000000 CurrentThread: fffff80364926a00 NextThread: ffffe40b77c12040 IdleThread: fffff80364926a00dt nt!_KPRCB fffff80309974180 Dpc* 0: kd> dt nt!DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK fffff803648fa320 +0x000 Signature : 0xaebecede +0x004 Revision : 1 +0x006 Size : 0x10 +0x008 DpcWatchdogProfileOffset : 0x84a8 +0x00c DpcWatchdogProfileLength : 0x8200示例 20: kd> !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************DPC_WATCHDOG_VIOLATION (133)The DPC watchdog detected a prolonged run time at an IRQL of DISPATCH_LEVELor above.Arguments:强制转换 nt 的地址！DPC_WATCHDOG_GLOBAL_TRIAGE_BLOCK显示有关它的信息。dbgcmd使用 ！dpcs 命令显示排队的 DPC。dbgcmd若要确定特定原因并创建代码修复，需要具有编程经验和对故障模块源代码的访问权限。通常，此停止代码是由在某些条件下未在分配的时间范围内完成其工作的错误驱动程序代码引起的。如果你没有能力使用 Windows 调试器来解决此问题，则应使用一些基本的故障排除技术。如果在 Bug 检查消息中发现了驱动程序，则要隔离问题，请禁用驱动程序。 请与制造商联系以获取驱动程序更新。在系统登录事件查看器中查看其他错误消息，这些错误消息可能有助于识别导致", "0x134": "BUG代码 0x134：DRIVE_EXTENDER\n项目 • 2023/06/20DRIVE_EXTENDER Bug 检查 值为 0x00000134。 这表示驱动器扩展程序组件遇到了严重的内部错误，导致系统无法继续运行。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVE_EXTENDER参数无", "0x135": "BUG代码 0x135：REGISTRY_FILTER_DRIVER_EXCEPTION\n项目 • 2023/06/20REGISTRY_FILTER_DRIVER_EXCEPTION Bug 检查 的值为 0x00000135。 此 Bug 检查是由注册表筛选驱动程序中未经处理的异常引起的。参数 描述1 异常代码2 导致 Bug 检查的异常的上下文记录的地址3 驱动程序的回调例程地址4 保留此 Bug 检查指示注册表筛选驱动程序未在其通知例程中处理异常。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 使用第 3 个参数标识有问题的驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。REGISTRY_FILTER_DRIVER_EXCEPTION参数原因解决方法", "0x136": "BUG代码 0x136：VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE\n项目 • 2023/06/20VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE Bug 检查 的值为 0x00000136。 这表示尝试从 VHD 启动时发生初始化失败。 承载 VHD 的卷没有足够的可用空间来扩展VHD。参数 描述1 0 ：无法将 VHD 文件扩展到完整大小。2 NT 状态代码3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE参数", "0x137": "BUG代码 0x137：WIN32K_HANDLE_MANAGER\n项目 • 2023/06/20WIN32K_HANDLE_MANAGER Bug 检查 的值为 0x00000137。 这表示 win32k/ntuser 句柄管理器检测到严重错误。参数 说明1 保留2 对象 (地址（如果可用) ）3 保留4 保留在某些情况下，可能会返回此处未列出的其他参数。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WIN32K_HANDLE_MANAGER参数", "0x138": "BUG代码 0x138：GPIO_CONTROLLER_DRIVER_ERROR\n项目 • 2023/06/20GPIO_CONTROLLER_DRIVER_ERROR Bug 检查 的值为 0x00000138。 此 Bug 检查指示GPIO 类扩展驱动程序遇到严重错误。参数 1 指示冲突的类型。 其他参数的含义取决于 参数 1 的值。参数 1 参数 2 参数 3 参数 4 错误消息的原因1 GSIV 预留 预留 未注册管理特定GSIV 的 GPIO 控制器。2 上下文值 预留 预留 客户端驱动程序为锁定或解锁请求指定了无效上下文。3 指示是否正在请求关键转换。指示由于非关键转换，银行是否已处于 F1 中。指示由于关键转换，银行是否已在 F1 中。PoFx 要求 GPIO控制器通过不适当的 F1 电源状态和/或关键转换发送组。4 指示是否正在请求关键转换。指示银行是否由于非关键转换而处于 F1 中。指示银行是否由于关键转换而处于 F1 中。PoFx 要求 GPIO控制器通过不适当的 F0 电源状态和/或关键转换发送银行。5 NTSTATUS GPIO 设备扩展 GPIO 中断参数 Soc 上的 GPIO 中断操作失败。6 NTSTATUS GPIO 设备扩展 GPIO IO 参数 Soc 上的 GPIO IO操作失败。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。GPIO_CONTROLLER_DRIVER_ERROR参数参数 1 参数 2 参数 3 参数 4 错误消息的原因7 修订版 ID 功能索引 保留 _DSM方法返回格式不正确的数据。", "0x139": "BUG代码 0x139：KERNEL_SECURITY_CHECK_FAILURE\n项目 • 2023/06/20KERNEL_SECURITY_CHECK_FAILURE Bug 检查 的值为 0x00000139。 此 Bug 检查指示内核已检测到关键数据结构的损坏。参数 描述1 损坏的类型。 有关详细信息，请参阅下表。2 导致 Bug 的异常的陷阱帧的地址检查3 导致 Bug 的异常记录的地址检查4 保留下表描述了参数 1 的可能值。参数1描述0 基于堆栈的缓冲区已溢出 (旧版 /GS 冲突) 。1 VTGuard 检测代码检测到尝试使用非法虚拟函数表。 通常，C++ 对象已损坏，然后尝试使用损坏对象的 此 指针进行虚拟方法调用。2 堆栈 Cookie 检测代码检测到基于堆栈的缓冲区溢出 (/GS 冲突) 。3 LIST_ENTRY (损坏，例如双删除) 。 有关详细信息，请参阅以下原因部分。4 保留5 将无效参数传递给认为无效参数致命的函数。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。Bug 检查0x139KERNEL_SECURITY_CHECK_FAILURE参数参数1描述6 加载程序未正确初始化堆栈 Cookie 安全 Cookie。 这可能是由于生成仅在 Windows 8 上运行的驱动程序，并尝试在早期版本的 Windows 上加载驱动程序映像。 若要避免此问题，必须生成要在早期版本的 Windows 上运行的驱动程序。7 请求了致命程序退出。8 编译器插入的数组边界检查检测到非法数组索引操作。9 对 RtlQueryRegistryValues 的 调用是在未RTL_QUERY_REGISTRY_TYPECHECK的情况下指定RTL_QUERY_REGISTRY_DIRECT，并且目标值不在受信任的系统配置单元中。10 间接呼叫防护检查检测到无效的控制转移。11 写入防护检查检测到无效的内存写入。12 尝试切换到无效的纤程上下文。13 尝试分配无效的寄存器上下文。14 对象的引用计数无效。18 尝试切换到无效jmp_buf上下文。19 对只读数据进行了不安全的修改。20 加密自测试失败。21 检测到无效的异常链。22 发生加密库错误。23 从 DllMain 中进行的调用无效。24 检测到无效的映像基址。25 保护延迟加载导入时遇到不可恢复的故障。26 调用了不安全的分机。27 调用了已弃用的服务。28 检测到超出边界的缓冲区访问。29 RTL_BALANCED_NODE RBTree 条目已损坏。37 调用了范围外开关跳转表条目。38 尝试对无效目标执行 longjmp 操作。参 描述数139 无法将导出抑制的调用目标设为有效的调用目标。原因使用参数 1 表和转储文件，可以缩小此类型许多 Bug 检查的原因范围。LIST_ENTRY损坏可能难以追踪，并且此 Bug 检查，表示在向列表) 添加或删除单个列表条目元素时， (检测到双重链接列表中引入了不一致。 遗憾的是，在损坏发生时不一定能检测到不一致，因此可能需要一些侦探工作来确定根本原因。列表条目损坏的常见原因包括：驱动程序已损坏内核同步对象，例如 KEVENT (例如，当线程仍在等待同一 KEVENT时对 KEVENT 进行双重初始化，或者允许基于堆栈的 KEVENT 超出范围，而另一个线程正在使用该 KEVENT) 。 这种类型的 Bug 检查通常发生在 nt！Ke* or nt！Ki* 代码。 当线程完成等待同步对象或代码尝试将同步对象置于信号状态时，可能会发生这种情况。 通常，发出信号的同步对象是已损坏的同步对象。 有时，如果损坏的同步对象位于已) 释放的池块中，则具有特殊池的驱动程序验证程序可以帮助跟踪罪魁祸首 (。驱动程序损坏了定期 KTIMER。 这种类型的 Bug 检查通常发生在 nt！Ke* 或 nt！Ki*代码 和 涉及向计时器发出信号，或者从计时器表中插入或删除计时器。 正在操作的计时器可能是损坏的计时器，但可能需要使用 ！timer (检查计时器表，或手动遍历计时器列表链接) 以确定哪个计时器已损坏。 有时，如果损坏的 KTIMER 位于) 已释放的池块中，则具有特殊池的驱动程序验证程序可以帮助跟踪罪魁祸首 (。驱动程序管理不了内部LIST_ENTRY样式的链接列表。 典型的示例是在同一列表条目上调用 RemoveEntryList 两次，而不在两个 RemoveEntryList 调用之间重新插入列表条目。 可能还有其他变体，例如将条目重复插入到同一列表中。驱动程序释放了包含LIST_ENTRY的数据结构，而不会从其相应的列表中删除数据结构，从而导致稍后在重新使用旧池块后检查列表时检测到损坏。驱动程序在没有正确同步的情况下以并发方式使用LIST_ENTRY样式的列表，导致列表更新撕裂。在大多数情况下，可以通过向前和向后移动链接列表来识别损坏的数据结构， (dl 和 dlb命令可用于此目的) 和比较结果。 向前和向后走之间的列表不一致通常是损坏的位置。由于链接列表更新操作可以修改相邻元素的列表链接，因此应仔细查看损坏列表条目的邻居，因为它们可能是潜在的罪魁祸首。由于许多系统组件在内部利用LIST_ENTRY列表，因此驱动程序使用系统 API 管理的各种资源错误可能会导致系统管理的链接列表损坏。解决方法确定此问题的原因通常需要使用调试器来收集其他信息。 应检查多个转储文件，以查看此停止代码是否具有类似的特征，例如显示停止代码时正在运行的代码。有关详细信息，请参阅 使用 Windows 调试器故障转储分析 (WinDbg) 、 使用 ！analyze扩展 和 ！analyze。使用事件日志查看是否存在导致此停止代码的更高级别事件。这些常规故障排除提示可能会有所帮助。如果最近向系统添加了硬件，请尝试删除或替换它。 或与制造商联系，查看是否有可用的修补程序。如果最近添加了新的设备驱动程序或系统服务，请尝试删除或更新它们。 尝试确定系统中导致新 Bug 检查代码出现的原因。检查事件查看器中的系统日志，以获取可能有助于查明导致错误的设备或驱动程序的其他错误消息。 有关详细信息，请参阅打开事件查看器 。 在系统日志中查找与蓝屏同时出现的严重错误。查看设备管理器，查看是否有任何设备标有感叹号 (！) 。 查看驱动程序属性中显示的事件日志，了解是否有任何故障驱动程序。 请尝试更新相关驱动程序。运行病毒检测程序。 病毒可能会感染所有针对 Windows 格式化的硬盘类型，由此产生的磁盘损坏可能会检查代码生成系统 Bug。 确保病毒检测程序检查主启动记录中的感染。有关其他常规故障排除信息，请参阅 蓝屏数据。另请参阅使用 Windows 调试器 (WinDbg) 进行故障转储分析使用 WinDbg 分析内核模式转储文件Bug 检查0x13A：KERNEL_MODE_HEAP_CORRUPTION\n项目 • 2023/03/08KERNEL_MODE_HEAP_CORRUPTION Bug 检查的值为 0x0000013A。 此 Bug 检查指示内核模式堆管理器在堆中检测到损坏。参数 说明1 检测到的损坏类型 - 请参阅以下列表2 报告损坏的堆的地址3 检测到损坏的地址4 保留0x3：检测到损坏的条目标头。0x4：检测到多个损坏的条目标头。0x5：检测到大型分配中的条目标头损坏。0x6：检测到损坏，其功能与缓冲区溢出一致。0x7：检测到损坏的功能与缓冲区不足一致。0x8：已将可用块传递给仅对忙碌块有效的操作。0x9 ：为当前操作指定了无效参数。0xA：检测到无效的分配类型。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_MODE_HEAP_CORRUPTION参数参数 1 - 堆损坏的类型0xB：检测到损坏，其功能与释放后使用错误一致。0xC ：为当前操作指定了错误的堆。0xD：检测到免费列表损坏。0xE：堆检测到非免费列表中的列表损坏。0xF：已将可用块传递给仅对忙碌块有效的操作。0x10 ：堆在当前操作期间检测到内部状态无效。 这通常是缓冲区溢出的结果。0x11：堆在当前操作期间检测到内部状态无效。 这通常是缓冲区溢出的结果。0x12：堆在当前操作期间检测到内部状态无效。 这通常是缓冲区溢出的结果。0x13 ：向堆 API 传递了 NULL 堆句柄。 查看调用堆栈以确定为何向堆提供错误的句柄。0x14：请求的堆分配比当前分配限制更大。0x15：在执行提交请求的过程中，已确定请求将超过当前提交限制。0x16：在检查给定 VA Manager 分配的大小的过程中，已确定查询无效。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。！堆扩展显示堆使用情况信息、控制堆管理器中的断点、检测泄漏的堆块、搜索堆块或显示页堆信息。有关蓝屏 Bug 检查故障排除的常规信息，请参阅 蓝屏数据。另请参阅Bug 检查代码参考蓝屏的常规提示0x139:KERNEL_SECURITY_CHECK_FAILURE\n\n问题原因：\n\n第三方软件冲突\n\n硬件故障（通常是RAM或SSD）\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x13B": "BUG代码 0x13B：PASSIVE_INTERRUPT_ERROR\n项目 • 2023/06/20PASSIVE_INTERRUPT_ERROR Bug 检查 的值为 0x0000013B。 这表示内核已检测到被动级别中断的问题。参数 描述1 检测到的错误类型0x1：驱动程序尝试获取中断旋转锁，但传入了被动级中断对象。2 被动级别中断的 KINTERRUPT 对象的地址。3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PASSIVE_INTERRUPT_ERROR参数", "0x13C": "BUG代码 0x13C：INVALID_IO_BOOST_STATE\n项目 • 2023/06/20INVALID_IO_BOOST_STATE Bug 检查 的值为 0x0000013C。 这表示线程退出了 I/O 提升状态无效。 当线程退出时，此值应为零。参数 描述1 指向具有无效提升状态的线程的指针2 当前提升状态或限制计数3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_IO_BOOST_STATE参数", "0x13D": "BUG代码 0x13D：CRITICAL_INITIALIZATION_FAILURE\n项目 • 2023/06/20CRITICAL_INITIALIZATION_FAILURE Bug 检查 的值为 0x0000013D。 这表示早期内核初始化失败。参数 描述1 保留2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CRITICAL_INITIALIZATION_FAILURE参数", "0x140": "BUG代码 0x140：STORAGE_DEVICE_ABNORMALITY_DETECTED\n项目 • 2023/06/20STORAGE_DEVICE_ABNORMALITY_DETECTED Bug 检查 的值为 0x00000140。 这表示存储驱动程序堆栈遇到响应速率冲突、超过阈值或其他响应失败。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。STORAGE_DEVICE_ABNORMALITY_DETECTED参数无", "0x143": "BUG代码 0x143：PROCESSOR_DRIVER_INTERNAL\n项目 • 2023/06/20PROCESSOR_DRIVER_INTERNAL Bug 检查 的值为 0x00000143。 这表示处理器电源管理(PPM) 驱动程序遇到严重错误。参数 说明1 1 - POWER Engine 插件 (PEP) 无法接受所需的通知2 PEP 运行时通知类型3 指向通知消息的指针4 指向发出通知 (FDO_DATA) 处理器设备上下文的指针参数 说明1 2 - 电源引擎插件 (PEP) 返回无效的处理器空闲状态2 无效状态的类型0x0：PEP 为协调空闲状态请求过多的处理器参数 3 - 请求参与协调空闲转换的处理器数参数4 - 指向处理器设备上下文的指针 (FDO_DATA)0x1：PEP 请求的处理器处于无效空闲状态参数 3 - 空闲状态索引请求参数 4 - 指向对应于无效空闲状态的处理器设备上下文 (FDO_DATA)的指针0x2：PEP 请求平台处于无效空闲状态参数 3 - 平台空闲状态索引请求参数 4 - 指向与无效空闲状态对应的处理器设备上下文(FDO_DATA) 的指针） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PROCESSOR_DRIVER_INTERNAL参数参数 说明3 请参阅参数 24 请参阅参数 2处理器驱动程序检测到一个不可调和的条件，提示它进行 Bug 检查。 这可能发生在处理器空闲和性能状态更改执行期间，这可能涉及其他实体，例如内核、HAL 和 PowerEngine 插件 (PEP) 。 来自 Bug 检查的信息将有助于确定处理器驱动程序在处理其他实体时做出的哪些假设被违反。 根本原因可能在于其他实体，转储文件可能会揭示更多信息，以确定 Bug 检查的原因。原因", "0x144": "BUG代码 0x144：BugCODE_USB3_DRIVER\n项目 • 2023/03/08BugCODE_USB3_DRIVER Bug 检查 的值为 0x00000144。 这是用于所有 USB 3 Bug 检查的代码。 参数 1 指定 USB 3 Bug 检查的类型，其他参数的含义取决于参数 1。参数 1 参数 2 参数 3 参数4错误原因0x1 可选。 指向用于重新发送 URB的 IRP 的指针指向 URB 的指针 指向客户端驱动程序的设备对象的指针客户端驱动程序使用了它之前发送到核心堆栈的 URB。0x2 指向启动设备 (PDO) 的物理设备对象的指针预留 预留 启动或分页设备重新枚举失败。0x3 可选。 指向用于发送 URB 的IRP 的指针指向损坏的 URB 的指针指向客户端驱动程序的设备对象的指针客户端驱动程序向核心堆栈发送了损坏的URB。 发生这种情况的原因是客户端驱动程序未使用USBD_xxxUrbAllocate分配 URB ，或者客户端驱动程序为 URB 执行了缓冲区不足。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。BugCODE_USB3_DRIVER参数参数 1 参数 2 参数 3 参数4错误原因0x800 发送开放静态流请求的 IRQL 指向开放静态流 IRP 的指针指向客户端驱动程序的设备对象的指针在 IRQL > 被动级别发送了开放静态流请求。0x801 指向开放静态流 IRP 的指针 指向打开静态流 URB的指针指向客户端驱动程序的设备对象的指针客户端驱动程序在查询流功能之前尝试打开静态流。 客户端驱动程序在成功查询流功能之前无法打开静态流。有关详细信息，请参阅“备注”。0x802 客户端驱动程序尝试打开的静态流数授予客户端驱动程序的静态流数指向客户端驱动程序的设备对象的指针客户端驱动程序尝试打开无效数量的静态流。流数不能为 0，并且不能大于查询 USB 功能调用中返回给客户端驱动程序的值。0x803 指向开放静态流 IRP 的指针 指向打开静态流 URB的指针指向客户端驱动程序的设备对象的指针客户端驱动程序尝试为已打开静态流的终结点打开静态流。 在打开静态流之前，客户端驱动程序必须关闭以前打开的静态流。0x804 泄漏的句柄上下文。 运行 ！usbanalyze -v 以获取有关泄漏的句柄和 URL 的信息。 必须为客户端驱动程序启用驱动程序验证程序。传递给USBD_CreateHandle的设备对象。预留 客户端驱动程序忘记关闭之前使用USBD_CreateHandle创建的句柄，或者忘记释放它分配的 URB。参数 1 参数 2 参数 3 参数4错误原因0x805 关闭静态流 URB 的WDFREQUEST 句柄指向关闭静态流 URB的指针指向客户端驱动程序的设备对象的指针例如，客户端驱动程序在处理 D0 退出) 后，(发送了处于无效状态的关闭静态流 URB。0x806 指向 IRP 的指针 指向 URB 的指针 指向客户端驱动程序的设备对象的指针客户端驱动程序在查询链接的 MDL 功能之前尝试发送链接的 MDL。 客户端驱动程序在成功查询链接 的 MDL功能之前，无法发送链接的 MDL 。 有关详细信息，请参阅“备注”。0x807 指向链接的 MDL 的指针 指向 URB 的指针 指向客户端驱动程序的设备对象的指针（如果可用）客户端驱动程序将 URB发送到核心堆栈，其传输缓冲区长度长于mmGetMdlByteCount)传入 的 MDL 返回的字节计数 (。 有关详细信息，请参阅“备注”。0x1001 XHCI_LIVEDUMP_CONTEXT 预留 预留 xHCI 控制器断言 HSE位，指示主机系统错误。0x1002 XHCI_LIVEDUMP_CONTEXT 预留 预留 xHCI 控制器断言 HCE位，这指示主控制器错误。0x1003 XHCI_LIVEDUMP_CONTEXT 预留 预留 xHCI 停止终结点命令返回未经处理的完成代码。参数 1 参数 2 参数 3 参数4错误原因0x1004 XHCI_LIVEDUMP_CONTEXT 预留 预留 发出 xHCI 终结点停止命令后，xHCI 终结点状态收到上下文状态错误。0x1005 XHCI_LIVEDUMP_CONTEXT 预留 预留 尝试清除控制终结点上的停止期间，设置取消排队指针失败。0x1006 XHCI_LIVEDUMP_CONTEXT 预留 预留 在尝试清除控制终结点上的停止期间，重置EP 失败。0x1007 XHCI_LIVEDUMP_CONTEXT 预留 预留 在重置恢复期间，xHCI控制器的重置失败。0x1008 XHCI_LIVEDUMP_CONTEXT 预留 预留 在重置恢复期间，xHCI控制器的重启失败。0x1009 XHCI_LIVEDUMP_CONTEXT 预留 预留 命令超时中止后，xHCI控制器命令无法完成。0x100A XHCI_LIVEDUMP_CONTEXT 预留 预留 在终结点停止完成后尝试设置取消排队指针期间，设置取消排队指针失败。0x100B XHCI_LIVEDUMP_CONTEXT 预留 预留 在重置恢复期间停止xHCI 控制器失败。0x100C XHCI_LIVEDUMP_CONTEXT 预留 预留 不支持 xHCI 控制器中的固件。 除非固件已更新，否则 xHCI 驱动程序将不会加载到此控制器上。0x100D XHCI_LIVEDUMP_CONTEXT 预留 预留 检测到控制器已被物理移除。0x100E XHCI_LIVEDUMP_CONTEXT 预留 预留 驱动程序在启用了流的终结点上检测到错误。0x100F XHCI_LIVEDUMP_CONTEXT 预留 预留 xHCI 控制器中的固件已过时。 xHCI 驱动程序将继续使用此控制器，但可能会遇到一些问题。 建议进行固件更新。参数 1 参数 2 参数 3 参数4错误原因0x1010 XHCI_LIVEDUMP_CONTEXT 预留 预留 传输事件 TRB 已完成，但未处理的完成代码。0x1011 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器报告事件环已满。 当发生这种情况时，控制器也会删除事件。0x1012 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器无序地完成了命令。0x1013 XHCI_LIVEDUMP_CONTEXT 预留 预留 命令中止完成后，控制器报告的命令环取消排队指针不正确。0x1014 XHCI_LIVEDUMP_CONTEXT 预留 预留 启用槽完成后，控制器向我们提供了错误的槽ID。0x1015 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器使用 BSR1 失败了 SetAddress 命令。这是出乎意料的。0x1016 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器在 usbdevice 重置期间未能启用插槽。这是意外的。0x1017 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器在取消配置终结点的终结点配置命令中失败。 这是出乎意料的。0x1018 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器无法执行禁用槽命令。 这是出乎意料的。0x1019 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器未能通过 USB设备重置命令。 这是出乎意料的。0x101A XHCI_LIVEDUMP_CONTEXT 预留 预留 终结点重置后，“设置取消排队指针”命令失败。0x101B XHCI_LIVEDUMP_CONTEXT 预留 预留 xHCI 重置终结点命令返回了未经处理的完成代码。参数 1 参数 2 参数 3 参数4错误原因0x101C XHCI_LIVEDUMP_CONTEXT 预留 预留 xHCI 的 D0Entry 失败。0x101D XHCI_LIVEDUMP_CONTEXT 预留 预留 在请求取消期间使用“配置终结点”命令而不是“设置取消排队指针”时，暂时删除并添加流终结点 (为两个命令) 失败。0x101E XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器指示未在控制器上挂起的传输完成。EventData == 1 (取消引用传输事件 TRB 的指针会导致 Bug 检查)0x101F XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器指示未在控制器上挂起的传输完成。EventData == 0 (传输事件中的逻辑地址 TRB不匹配)0x1020 XHCI_LIVEDUMP_CONTEXT 预留 预留 控制器指示未在控制器上挂起的传输完成。EventData == 0 (传输事件 TRB 中的逻辑地址不匹配) 传输事件TRB 可能是冗余 (点靠近最近完成的请求) 。0x1021 XHCI_LIVEDUMP_CONTEXT 预留 预留 使用配置终结点命令作为重置未停止终结点的一部分时，暂时删除并添加流终结点 (为两个命令) 失败。0x1022 XHCI_LIVEDUMP_CONTEXT 预留 预留 删除并添加与一个命令相同的终结点 () 失败。0x3000 USBHUB3_LIVEDUMP_CONTEXT 预留 预留 中心驱动程序成功重置了运行不当的中心。0x3001 USBHUB3_LIVEDUMP_CONTEXT 预留 预留 中心驱动程序无法成功重置运行不当的中心。0x3002 USBHUB3_LIVEDUMP_CONTEXT 预留 预留 中心驱动程序禁用了非正常运行的SuperSpeed 中心。参数 1 参数 2 参数 3 参数4错误原因0x3003 USBHUB3_LIVEDUMP_CONTEXT 预留 预留 USB 设备枚举失败。若要查询 USB 功能，客户端驱动程序必须调用WdfUsbTargetDeviceQueryUsbCapability 或 USBD_QueryUsbCapability若要发送链接的 MDL，客户端驱动程序必须调用 USBD_QueryUsbCapability 并使用URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL 或URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL。通用串行总线 (USB)内核实时转储代码引用Bug 检查代码参考备注另请参阅", "0x145": "BUG代码 0x145：SECURE_BOOT_VIOLATION\n项目 • 2023/06/20SECURE_BOOT_VIOLATION Bug 检查的值为 0x00000145。 这表示由于策略无效或所需操作未完成，无法启动安全启动策略强制实施。参数 描述1 失败的状态代码。2 安全启动策略的地址。3 安全启动策略的大小。4 保留Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SECURE_BOOT_VIOLATION参数另请参阅", "0x147": "BUG代码 0x147：ABNORMAL_RESET_DETECTED\n项目 • 2023/06/20ABNORMAL_RESET_DETECTED Bug 检查 值为 0x00000147。 这表示 Windows 进行了异常重置。 未保存任何上下文或异常记录，并且未调用 Bug 检查回调。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ABNORMAL_RESET_DETECTED参数无请参阅Bug 检查代码参考", "0x14B": "BUG代码 0x14B：SOC_SUBSYSTEM_FAILURE\n项目 • 2023/06/20SOC_SUBSYSTEM_FAILURE Bug 检查 的值为 0x0000014B。 这表示芯片 (SoC) 子系统上的系统遇到不可恢复的错误。参数 描述1 SOC_SUBSYSTEM_FAILURE_DETAILS结构的地址。2 保留。3 保留。4 可选。 供应商提供的数据块的地址。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。dbgcmd） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。0x14B SOC_SUBSYSTEM_FAILURE参数进行 Bug检查解决方法2: kd> !analyze -v******************************************************************************** ** Bugcheck Analysis ** ********************************************************************************SOC_SUBSYSTEM_FAILURE (14b)A SOC subsystem has experienced an unrecoverable critical fault.Arguments:Arg1: 9aa8d630, nt!SOC_SUBSYSTEM_FAILURE_DETAILSArg2: 00000000, ReservedArg3: 00000000, ReservedArg4: a126c000, (Optional) address to vendor supplied general purpose datablock.使用提供的 nt！SOC_SUBSYSTEM_FAILURE_DETAILS结构，使用 dt 命令和 Arg1 提供的地址转储故障数据。dbgcmd2: kd> dt nt!SOC_SUBSYSTEM_FAILURE_DETAILS 9aa8d630 +0x000 SubsysType : 1 ( SOC_SUBSYS_AUDIO_DSP ) +0x008 FirmwareVersion : 0 +0x010 HardwareVersion : 0 +0x018 UnifiedFailureRegionSize : 0x24 +0x01c UnifiedFailureRegion : [1] \"F\"与 SoC 供应商合作以进一步分析数据，包括可选供应商提供的常规用途数据块。可能需要使用 k、kb、kc、kd、kp、kP、kv (Display Stack Backtrace) 命令来检查堆栈跟踪。 可以指定处理器编号来检查所有处理器上的堆栈。还可以在导致此停止代码的代码中设置断点，并尝试单步执行错误代码。有关详细信息，请参阅以下主题：使用 Windows 调试器 (WinDbg) 进行故障转储分析如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。在系统登录事件查看器中查看其他错误消息，这些错误消息可能有助于识别导致此Bug 的设备或驱动程序检查。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。你可尝试运行系统制造商提供的硬件诊断。有关其他常规故障排除信息，请参阅 蓝屏数据。最低受支持的客户端 Windows 8最低受支持的服务器 Windows Server 2012要求", "0x149": "BUG代码 0x149：REFS_FILE_SYSTEM\n项目 • 2023/06/20REFS_FILE_SYSTEM Bug 检查 的值为 0x00000149。 这表示发生了文件系统错误。参数 描述1 __线__2 ExceptionRecord3 ContextRecord4 ExceptionRecord-ExceptionAddress>如果在堆栈上看到 RefsExceptionFilter，则第 2 个和第 3 个参数是异常记录和上下文记录。 对第 2 个参数执行 .exr 以查看异常信息，然后在第 3 个参数和 kb 上执行 .cxr 以获取更详细的堆栈跟踪。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。REFS_FILE_SYSTEM参数解决方法另请参阅", "0x14A": "BUG代码 0x14A：KERNEL_WMI_INTERNAL\n项目 • 2023/06/20KERNEL_WMI_INTERNAL Bug 检查 的值为 0x0000014A。 这表示内部内核 WMI 子系统遇到严重错误。参数 描述1 0：内核 WMI 条目引用计数从 0 递增。参数 2：指向内核 WMI 条目的指针。1：过早删除了内核 WMI 数据源。参数 2：指向内核 WMI 数据源的指针。2 请参阅参数 13 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_WMI_INTERNAL参数", "0x14C": "BUG代码 0x14C：FATAL_ABNORMAL_RESET_ERROR\n项目 • 2023/06/20FATAL_ABNORMAL_RESET_ERROR Bug 检查 值为 0x0000014C。 这表示发生了不可恢复的系统错误，或者系统已异常重置。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FATAL_ABNORMAL_RESET_ERROR参数无原因系统遇到意外错误并重新启动。 可能导致此错误的问题包括：应用程序的硬件监视器计时器或辅助处理器指示系统挂起、用户启动的密钥序列（由于挂起、故障或默认错误检查路径中的失败）。 缓存可能不会刷新，并且生成的完整内存转储可能不包含当前线程上下文。标记 {E1D08891-D5A3-45F9-B811-AD711DFB2607} 的辅助数据包含其他“Blackbox”数据。 使用 .enumtag (枚举辅助回调数据) 来查看数据。", "0x14D": "BUG代码 0x14D：EXCEPTION_SCOPE_INVALID\n项目 • 2023/06/20EXCEPTION_SCOPE_INVALID Bug 检查 的值为 0x0000014D。 这表示已检测到异常调度中的内部不一致。参数 描述1 保留2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。EXCEPTION_SCOPE_INVALID参数", "0x14E": "BUG代码 0x14E：SOC_CRITICAL_DEVICE_REMOVED\n项目 • 2023/06/20SOC_CRITICAL_DEVICE_REMOVED Bug 检查 的值为 0x0000014E。 这表示关键 SOC 设备已意外删除或失败。参数 描述1 如果可用，则指示 (4 个字符的打包代码删除的设备 ID)2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SOC_CRITICAL_DEVICE_REMOVED参数", "0x14F": "BUG代码 0x14F：PDC_WATCHDOG_TIMEOUT\n项目 • 2023/06/20PDC_WATCHDOG_TIMEOUT Bug 检查 的值为 0x0000014F。 这表示系统组件在分配的时间段内无法响应，从而阻止系统退出连接待机。参数 描述1 挂起组件的客户端 ID。2 挂起组件的客户端类型。0x1：通知客户端无法响应。参数 3：指向通知客户端(PDC_NOTIFICATION_CLIENT) 的指针。 参数4：指向 pdc！PDC_14F_TRIAGE结构。0x2：复原客户端无法响应。参数 3：指向复原客户端(PDC_RESILIENCY_CLIENT) 的指针。 参数 4：指向 pdc！PDC_14F_TRIAGE结构。0x3：激活器客户端保留引用的时间太长。参数 3：指向激活客户端 (pdc！_PDC_ACTIVATOR_CLIENT) 的指针。 参数 4：指向 pdc！PDC_14F_TRIAGE结构。0x100：Win32k 未及时完成监视请求。参数 3：此请求的最新POWER_MONITOR_REQUEST_REASON值。 参数 4：一个值，指示用于启动请求的内部路径。3 请参阅参数 24 请参阅参数 2） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PDC_WATCHDOG_TIMEOUT参数解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。0x14F:PDC_WATCHDOG_TIMEOUT\n\n问题原因：\n\nWindows缺陷或第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x150": "BUG代码 0x150：TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK\n项目 • 2023/06/20TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK Bug 检查的值为 0x00000150。 这表示 NIC活动引用应在发送队列完全耗尽时释放。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK参数无请参阅Bug 检查代码参考", "0x151": "BUG代码 0x151：UNSUPPORTED_INSTRUCTION_MODE\n项目 • 2023/06/20UNSUPPORTED_INSTRUCTION_MODE Bug 检查 值为 0x00000151。 这表示尝试使用不受支持的处理器指令模式执行代码 (例如，) 执行经典 Arm 指令而不是 ThumbV2 指令。不允许这样做。参数 描述1 检测到问题时的程序计数器。2 陷阱框架3 保留4 保留Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UNSUPPORTED_INSTRUCTION_MODE参数另请参阅", "0x152": "BUG代码 0x152：INVALID_PUSH_LOCK_FLAGS\n项目 • 2023/06/20INVALID_PUSH_LOCK_FLAGS Bug 检查的值为 0x00000152。 这表示提供给推送锁 API 之一的标志无效。参数 描述1 调用方提供的无效标志2 推送锁的地址3 保留4 保留Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_PUSH_LOCK_FLAGS参数另请参阅", "0x153": "BUG代码 0x153：KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION\n项目 • 2023/06/20KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION Bug 检查 的值为 0x00000153。 这表示线程在释放其所有 AutoBoost 锁条目之前已终止。参数 描述1 线程的地址2 未释放的条目的地址3 指示条目状态的状态代码0x1：锁定指针不为 NULL0x2：已设置线程指针保留位0x3：线程指针已损坏0x4：条目剩余的 IO 或 CPU 提升4 保留这通常是当线程从未释放它以前 (获取的锁时导致的，例如，依赖于另一个线程) 释放它，或者线程未提供一组一致的标志来锁定包 API。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION参数原因另请参阅", "0x154": "BUG代码 0x154：UNEXPECTED_STORE_EXCEPTION\n项目 • 2023/06/15UNEXPECTED_STORE_EXCEPTION Bug 检查 的值为 0x00000154。 此 Bug 检查指示内核内存存储组件捕获了意外异常。参数 说明1 指向存储上下文或数据管理器的指针2 异常信息3 保留4 预留若要确定问题的原因，请使用调试器收集其他信息。 检查多个转储文件，查看此停止代码是否具有类似的特征，例如在停止代码出现时运行的相同代码。 有关详细信息，请参阅 使用 Windows 调试器进行故障转储分析 (WinDbg) 、 使用 ！analyze 扩展 和 ！analyze。有关相关源代码的信息可用后，在执行此代码之前，请在相关代码中设置断点。 单步执行代码，查看用于控制代码流的关键变量的值。 仔细检查代码的此区域，以查找错误假设或其他错误。如果无法使用导致该问题的基础代码，这些故障排除提示可能会有所帮助。） 重要本主题面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UNEXPECTED_STORE_EXCEPTION参数解决方法故障排除提示检查系统登录事件查看器是否有其他错误消息，以帮助查明导致错误的设备或驱动程序。 若要打开事件查看器，请选择键盘快捷方式 Win+R，输入 eventvwr.msc 并按 Enter 键。 在与蓝屏相同的时间范围内查找系统日志中发生的严重错误。选择“开始”，在“搜索”框中输入 “Windows 内存诊断” ，然后按 Enter。 选择是重新启动计算机并立即运行该工具，还是计划该工具在下次重启时运行。 Windows 内存诊断在计算机重启后自动运行，并自动执行标准内存测试。 若要运行扩展测试，请按 F1 并使用向上键和向下键将 Test Mix 设置为 Extended。 按 F10 应用所需的设置并恢复测试。在设备管理器中查看是否用惊叹号 (!) 标记了任何设备。 查看驱动程序属性中显示的事件日志，了解是否有任何故障驱动程序。 请尝试更新相关驱动程序。使用系统文件检查器工具来修复丢失或损坏的系统文件。 系统文件检查器是Windows 中的一个实用工具，允许用户扫描 Windows 系统文件中的损坏并还原损坏的文件。 SFC /scannow使用 命令运行系统文件检查器工具。 有关详细信息，请参阅 使用系统文件检查器工具修复丢失或损坏的系统文件 。另请参阅Bug 检查代码参考0x154:UNEXPECTED_STORE_EXCEPTION\n\n问题原因：\n\n硬件故障（通常是SSD）\n\n解决方案：\n\n请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x155": "BUG代码 0x155：OS_DATA_TAMPERING\n项目 • 2023/06/20OS_DATA_TAMPERING Bug 检查 的值为 0x00000155。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。OS_DATA_TAMPERING参数无请参阅Bug 检查代码参考", "0x157": "BUG代码 0x157：KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION\n项目 • 2023/06/20ATTEMPTED_SWITCH_FROM_DPC Bug 检查 的值为 0x00000157。 这表示尝试在特定线程的优先级下限执行非法操作。参数 描述1 线程的地址2 目标优先级值3 指示冲突性质的状态代码0x1：目标优先级流过0x2的优先级计数器：目标优先级流动不足0x3的优先级计数器：目标优先级值非法4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION参数", "0x158": "BUG代码 0x158：ILLEGAL_IOMMU_PAGE_FAULT\n项目 • 2023/06/20ILLEGAL_IOMMU_PAGE_FAULT Bug 检查 的值为 0x00000158。 这表示 IOMMU 已为无效ASID 传递了页面错误数据包。 这是不安全的，因为 ASID 可能已被重复使用。参数 描述1 无效的 ASID。2 当前正在使用的 ASID 数。3 使用此 ASID 的进程。4 ASID 的引用计数。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ILLEGAL_IOMMU_PAGE_FAULT参数", "0x159": "BUG代码 0x159：HAL_ILLEGAL_IOMMU_PAGE_FAULT\n项目 • 2023/06/20检查HAL_ILLEGAL_IOMMU_PAGE_FAULT Bug 的值为 0x00000159。 这表示 IOMMU 已针对正在释放的 ASID 发出页面错误。 驱动程序负责在此时间点之前完成任何正在进行的请求，此 Bug 检查指示系统中的驱动程序未执行此操作。参数 说明1 IOMMU 供应商消除歧义2 指向错误数据包的指针3 供应商特定的故障数据包数据4 供应商特定的故障数据包数据参数 说明1 IOMMU 供应商消除歧义 = 0x3xxx。2 状态3 PASID4 DirectoryBase） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HAL_ILLEGAL_IOMMU_PAGE_FAULT参数", "0x15A": "BUG代码 0x15A：SDBUS_INTERNAL_ERROR\n项目 • 2023/06/20SDBUS_INTERNAL_ERROR Bug 检查 的值为 0x0000015A。 这表示 SD 连接的设备上发生了不可恢复的硬件故障。参数 描述1 指向导致失败的内部 SD 工作数据包的指针2 控制器套接字信息的指针3 指向发送到总线驱动程序的 SD 请求数据包的指针4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SDBUS_INTERNAL_ERROR参数", "0x15B": "BUG代码 0x15B：WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE\n项目 • 2023/06/20WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE Bug 检查 的值为 0x0000015B。 这表示被调用的工作线程例程泄露了工作线程的系统页优先级。参数 描述1 工作线程例程的地址 (在此地址上执行 ln 操作，以查找有问题的驱动程序)2 当前系统页优先级值3 WorkItem 参数4 WorkItem 地址） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE参数", "0x160": "BUG代码 0x160：WIN32K_ATOMIC_CHECK_FAILURE\n项目 • 2023/06/20WIN32K_ATOMIC_CHECK_FAILURE Bug 检查 的值为 0x00000160。 这表示 Win32k 函数违反了 ATOMICCHECK。参数 描述1 当前位于 ATOMIC 操作内的堆栈上的函数计数2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WIN32K_ATOMIC_CHECK_FAILURE参数", "0x162": "BUG代码 0x162：KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE\n项目 • 2023/06/20KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE Bug 检查 的值为 0x00000162。 这表示由 AutoBoost 跟踪的锁已由不拥有该锁的线程释放。参数 描述1 线程的地址2 锁地址3 线程的会话 ID4 保留这通常是当某个线程代表另一个线程释放锁时， (该锁在启用 AutoBoost 跟踪) 是不合法的，或者当某个线程尝试释放它不再拥有的锁时，就会造成这种情况。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE参数原因", "0x163": "BUG代码 0x163：WORKER_THREAD_TEST_CONDITION\n项目 • 2023/06/20WORKER_THREAD_TEST_CONDITION Bug 检查 的值为 0x00000163。 这表示内核工作线程的测试引发了失败。参数 描述1 活动测试标志2 与触发失败的测试对应的标志3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_TEST_CONDITION参数", "0x164": "BUG代码 0x164：WIN32K_CRITICAL_FAILURE\n项目 • 2023/06/20WIN32K_CRITICAL_FAILURE Bug 检查 的值为 0x00000164。 这表明 Win32k 遇到了严重故障。参数 说明1 1 - 失败的类型。0x1：REGION_VALIDATION_FAILURE区域超出图面边界。2 - 指向 DC 的指针3 - 指向 SURFACE 的指针4 - 指向 REGION 的指针0x2：OPERATOR_NEW_USED - 运算符“new”用于分配内存。2 - 保留3 - 保留4 - 保留0x3：CRITICAL_APISET_EXTENSIONS_MISSING- 缺少关键扩展 APISET API。2 - wchar_t* 为缺失函数的名称3 - 保留4 - 保留0x4：GDI_SPRITE_SURFACE_INVALID_DELETE -在不删除子画面的情况下删除 GDI 子画面的形状。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WIN32K_CRITICAL_FAILURE参数参数 说明2 - SURFACE 的句柄3 - SURFACE 的引用计数4 - SURFACE 所有者的 PID0x5：POINTER_DEVICE_EXCLUSIVE_OPEN_FAILED -无法打开指针设备。2 - 设备的UNICODE_STRING3 - 保留4 - 保留0x8：PUBLIC_DC_INVALID_PRIVATE_MEMBER -公共 DC 具有指向特定进程拥有的对象的指针。2 - 指向 DC 的指针3 - 拥有对象的进程 ID4 - 保留0xA：TTFD_INVOKE_ILLEGAL_ID - TTFD 中使用无效的函数表索引。2 - 保留3 - 保留4 - 保留0xB：OTFD_INVOKE_ILLEGAL_ID - ATMFD 中使用无效的函数表索引。2 - 保留3 - 保留4 - 保留0xC：GFPE_INVOKE_ILLEGAL_ID - 调色板中使用无效的函数表索引。2 - 指向 PALETTE 的指针3 - 无效索引4 - 最大有效索引 + 10x10：USER_SAS_REGISTRATION_FAILED - SAS密钥注册失败。2 - vkey3 - 修饰符参数 说明4 - 标志2 请参阅参数 13 请参阅参数 14 请参阅参数 1!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。解决方法", "0x16C": "BUG代码 0x16C：INVALID_RUNDOWN_PROTECTION_FLAGS\n项目 • 2023/06/20INVALID_RUNDOWN_PROTECTION_FLAGS Bug 检查 的值为 0x0000016C。 这表示提供给其中一个断开保护 API 的标志无效。参数 描述1 调用方提供的无效标志2 断开引用的地址3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_RUNDOWN_PROTECTION_FLAGS参数", "0x16D": "BUG代码 0x16D：INVALID_SLOT_ALLOCATOR_FLAGS\n项目 • 2023/06/20INVALID_SLOT_ALLOCATOR_FLAGS Bug 检查的值为 0x0000016D。 这表示提供给其中一个槽分配器 API 的标志无效。参数 描述1 调用方提供的无效标志2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_SLOT_ALLOCATOR_FLAGS参数", "0x16E": "BUG代码 0x16E：ERESOURCE_INVALID_RELEASE\n项目 • 2023/06/20ERESOURCE_INVALID_RELEASE Bug 检查 的值为 0x0000016E。 这表示提供给ExReleaseResourceForThreadLite 的目标线程指针无效。参数 描述1 正在释放的资源2 当前线程3 传入的错误目标线程4 保留如果 API 客户端跳过了对 ExSetOwnerPointerEx 的调用 (如果打算) 跨线程发布，或者调用方意外传入了 ExGetCurrentResourceThread 提供的其他值，则会命中此 Bug 检查。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ERESOURCE_INVALID_RELEASE参数原因", "0x170": "BUG代码 0x170：CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG\n项目 • 2023/06/20CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG Bug 检查的值为 0x00000170。 这表示群集断开连接未向前推进。参数 描述1 正在处理群集断开连接的线程的 ID。2 超时（以毫秒为单位）。3 保留4 保留群集断开连接未向前推进。使用实时转储排查挂起 (博客)Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG参数原因解决方法另请参阅", "0x171": "BUG代码 0x171：CRYPTO_LIBRARY_INTERNAL_ERROR\n项目 • 2023/06/20CRYPTO_LIBRARY_INTERNAL_ERROR Bug 检查 的值为 0x00000171。 它指示加密库中发生了内部错误。参数 描述1 失败的 ID。2 保留。3 保留。4 保留。此 Bug 检查指示加密库遇到不应发生的异常，并且该库没有向调用方发出错误信号的安全方法。 这可能是主动攻击的症状。Bug 检查代码参考加密 API：下一代） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CRYPTO_LIBRARY_INTERNAL_ERROR参数原因另请参阅", "0x173": "BUG代码 0x173：COREMSGCALL_INTERNAL_ERROR\n项目 • 2023/06/20PFN_SHARE_COUNT Bug 检查 的值为 0x00000173。 这表示 CoreMessageCall 检测到不可恢复的错误。参数 描述1 失败的类型。2 保留。3 保留。4 保留。CoreMessageCall 检测到不可恢复的错误。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。COREMSGCALL_INTERNAL_ERROR参数原因另请参阅", "0x174": "BUG代码 0x174：COREMSG_INTERNAL_ERROR\n项目 • 2023/06/20COREMSG_INTERNAL_ERROR Bug 检查 的值为 0x00000174。 这表示 CoreMessaging 检测到不可恢复的错误。参数 描述1 失败的类型。2 保留。3 保留。4 保留。CoreMessaging 检测到不可恢复的错误。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。COREMSG_INTERNAL_ERROR参数原因另请参阅", "0x178": "BUG代码 0x178：ELAM_DRIVER_DETECTED_FATAL_ERROR\n项目 • 2023/06/20ELAM_DRIVER_DETECTED_FATAL_ERROR Bug 检查 的值为 0x00000178。 这表示 ELAM驱动程序检测到严重错误。参数 描述1 失败的类型。0x0：无法撤销 TPM 证明2 - 指向要检查的驱动程序BDCB_IMAGE_INFORMATION结构的指针 3 -TBS_RESULT失败代码0x10000：ELAM 供应商定义的故障2 - (可选的) ELAM 供应商提供的值 3 - (ELAM 供应商提供的可选) 值2 请参阅参数 13 请参阅参数 14 (可选的) ELAM 供应商提供的常规用途数据块） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ELAM_DRIVER_DETECTED_FATAL_ERROR参数Bug 检查0x17B：PROFILER_CONFIGURATION_ILLEGAL\n项目 • 2023/06/20PROFILER_CONFIGURATION_ILLEGAL Bug 检查 值为 0x0000017B。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PROFILER_CONFIGURATION_ILLEGAL参数无Bug 检查0x17E：MICROCODE_REVISION_MISMATCH\n项目 • 2023/06/20MICROCODE_REVISION_MISMATCH Bug 检查 的值为 0x0000017E。 它指示多处理器配置中的一个或多个处理器加载的微代码不一致。参数 描述1 不匹配的处理器的处理器 CPUID 签名值。2 处理器的预期微代码修订版。3 处理器的实际报告微代码修订。4 不匹配处理器的处理器索引。多处理器配置中的一个或多个处理器加载的微代码不一致。 此 Bug 检查指示有故障的系统固件错误地将微代码更新应用于主机配置中的一部分处理器。 系统固件必须以统一的方式对所有处理器应用微代码更新。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MICROCODE_REVISION_MISMATCH参数原因另请参阅", "0x189": "BUG代码 0x189：BAD_OBJECT_HEADER\n项目 • 2023/06/20BAD_OBJECT_HEADER Bug 检查 的值为 0x00000189。 这表示OBJECT_HEADER已损坏。参数 描述1 指向错误OBJECT_HEADER的指针2 指向基于OBJECT_HEADER中的 TypeIndex 生成的OBJECT_TYPE的指针3 损坏的类型。0x0 ：类型索引已损坏0x1 ：对象安全描述符无效4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BAD_OBJECT_HEADER参数", "0x18B": "BUG代码 0x18B：SECURE_KERNEL_ERROR\n项目 • 2023/06/20SECURE_KERNEL_ERROR Bug 检查 的值为 0x0000018B。 这表示安全内核遇到严重错误。参数 描述1 保留2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SECURE_KERNEL_ERROR参数", "0x18C": "BUG代码 0x18C：HYPERGUARD_VIOLATION\n项目 • 2023/06/20HYPERGUARD_VIOLATION Bug 检查 的值为 0x0000018C。 这表示内核已检测到关键内核代码或数据已损坏。参数 描述1 损坏区域的类型 - 下面列出的值。2 故障类型依赖信息。3 保留。4 保留。损坏区域的类型1001：泛型数据区域1002：页面哈希不匹配1004：处理器 IDT1005：处理器 GDT） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。７ 备注此 Bug 代码仅保留供 Hyperguard 使用。它不是供其他组件在数据损坏方案中使用的常规用途 Bug 代码。相反，请为组件定义唯一的 Bug 代码。请勿在组件中使用此 Bug 代码。HYPERGUARD_VIOLATION参数1007：调试例程修改1008：动态代码区域1009：通用可共享数据区域100a：虚拟机监控程序覆盖区域100b：处理器模式配置错误100c：扩展处理器控制寄存器100d：安全内存区域100e：加载的模块100f：处理器状态区域1010：内核 CFG 位图1011 ：虚拟地址 0 页1012：备用反转函数表1013：按需页面验证失败1016：安全映像区域1017：内核虚拟地址保护不一致1101：内部上下文损坏1102 ：IDTR 修改1103 ：GDTR 修改原因当内核检测到关键内核代码或数据已损坏时，将生成此 Bug 检查。 损坏通常有三个原因：1. 驱动程序无意或故意修改了关键内核代码或数据。2. 开发人员尝试使用启动系统时未附加的内核调试器设置正常的内核断点。 只有在启动时附加调试器时，才能设置正常的断点“bp”。 可以随时设置硬件断点“ba”。3. 发生了硬件损坏，例如，保存内核代码或数据的 RAM 出现故障。另请参阅Bug 检查代码参考", "0x18D": "BUG代码 0x18D：SECURE_FAULT_UNHANDLED\n项目 • 2023/06/20SECURE_FAULT_UNHANDLED Bug 检查 值为 0x0000018D。此 Bug 检查无法处理由安全内核引起的安全故障。参数 说明1 安全故障代码位掩码 - 以下值。2 安全故障 VA (仅适用于某些安全故障类型) 。3 异常记录。4 上下文记录。安全故障代码位掩码text无法处理由安全内核引起的安全错误。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SECURE_FAULT_UNHANDLED参数 0x1 : KSECURE_FAULT_SLAT_NX A no-execute fault occurred due to SLAT page protections. 0x2 : KSECURE_FALT_SLAT_READ A read fault occurred due to SLAT page protections. 0x4 : KSECURE_FAULT_SLAT_WRITE A write fault occurred due to SLAT page protections. 0x8 : KSECURE_FAULT_DOUBLE_FAULT A secure fault occurred before the prior secure fault had beendismissed by the kernel.原因另请参阅Bug 检查代码参考", "0x18E": "BUG代码 0x18E：KERNEL_PARTITION_REFERENCE_VIOLATION\n项目 • 2023/06/20KERNEL_PARTITION_REFERENCE_VIOLATION Bug 检查的值为 0x0000018E。此错误表示分区未正确取消引用。 当内核模式驱动程序未正确取消引用分区对象时，通常会发生这种情况。 当内核中发生严重的数据损坏时，也可能发生此错误。以下参数显示在蓝屏上。参数 1 指示失败的类型。 其他参数的含义取决于参数 1 的值。参数 1 参数 2 参数 3 参数40x0：正在删除具有非零硬引用计数的分区。指向分区的指针。未完成硬引用的数目。 保留0x1：正在删除系统分区 指向分区的指针。预留 预留0x2：正在删除具有未完成的工作队列项的分区。指向分区的指针。指向具有未完成项的 ex 工作队列的指针。保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_PARTITION_REFERENCE_VIOLATION参数", "0x191": "BUG代码 0x191：PF_DETECTED_CORRUPTION\n项目 • 2023/06/20PF_DETECTED_CORRUPTION Bug 检查 的值为 0x00000191。参数 描述1 保留2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PF_DETECTED_CORRUPTION参数", "0x192": "BUG代码 0x192：KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL\n项目 • 2023/06/20KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL Bug 检查的值为 0x00000192。 这表示在以DISPATCH_LEVEL 或更高版本执行时获取了由 AutoBoost 跟踪的锁。参数 描述1 线程的地址2 锁地址3 获取锁的 IRQL4 保留调用方不能阻止APC_LEVEL上面的锁，因为锁可能由中断的线程独占持有，这将导致死锁。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL参数原因", "0x196": "BUG代码 0x196：LOADER_ROLLBACK_DETECTED\n项目 • 2023/06/20LOADER_ROLLBACK_DETECTED Bug 检查 的值为 0x00000196。 这表示 OS 加载程序的版本与操作系统不匹配。参数 描述1 加载程序安全版本2 OS 安全版本3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。LOADER_ROLLBACK_DETECTED参数", "0x197": "BUG代码 0x197：WIN32K_SECURITY_FAILURE\n项目 • 2023/06/20WIN32K_SECURITY_FAILURE Bug 检查 的值为 0x00000197。 这表示在 win32k 中检测到安全故障。参数 描述1 失败类型0x1：对象句柄条目未指向对象。2 - 指向对象类型 3 的指针 - 指向对象句柄条目4 的指针 - 预期对象2 请参阅参数 13 请参阅参数 14 请参阅参数 1） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WIN32K_SECURITY_FAILURE参数", "0x199": "BUG代码 0x199：KERNEL_STORAGE_SLOT_IN_USE\n项目 • 2023/06/20KERNEL_STORAGE_SLOT_IN_USE Bug 检查 的值为 0x00000199。 这表示无法释放存储槽，因为有对象使用它。参数 描述1 存储阵列的地址2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。KERNEL_STORAGE_SLOT_IN_USE参数", "0x19A": "BUG代码 0x19A：WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO\n项目 • 2023/06/20WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO Bug 检查 的值为 0x0000019A。 这表示工作线程已附加到 silo，并且未在返回之前分离。参数 描述1 工作线程例程的地址2 Workitem 参数3 Workitem 地址4 保留若要进行调查，请使用参数 1 上的 ln (List Nearest Symbols) 命令来帮助识别行为不当的驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO参数原因", "0x19B": "BUG代码 0x19B：TTM_FATAL_ERROR\n项目 • 2023/06/20TTM_FATAL_ERROR Bug 检查 的值为 0x0000019B。 这表示终端拓扑管理器遇到严重错误。参数 描述1 失败类型0x1：无法生成终端对象。2 - 失败的 NT 状态代码 3 - 保留 4 - 保留2 请参阅参数 13 请参阅参数 14 请参阅参数 1） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TTM_FATAL_ERROR参数", "0x19C": "BUG代码 0x19C：WIN32K_POWER_WATCHDOG_TIMEOUT\n项目 • 2023/06/20WIN32K_POWER_WATCHDOG_TIMEOUT Bug 检查 的值为 0x0000019C。 这表明 Win32k未及时打开监视器。参数 说明1 失败类型 (win32kbase！POWER_WATCHDOG_TYPE)0x10 : The power request queue is not makingprogress 2 - Pointer to the thread processingpower requests, if any 3 - Pointer to thewin32k user lock 4 - Pointer to the powerrequest (win32kbase!PPOWERREQUEST) beingprocessed, if any 0x20 : Calling PO to setpower state 2 - Pointer to the power requestworker thread 3 - Reserved 4 - Reserved 0x30: Calling GDI to power on 2 - Pointer to thepower request worker thread 3 - Reserved 4 -Reserved 0x40 : Calling DWM to render 2 -Pointer to the power request worker thread 3- Reserved 4 - Reserved 0x50 : Callingmonitor driver to power on 2 - Pointer to thepower request worker thread 3 - Reserved 4 -Reserved2 请参阅参数 13 请参阅参数 14 请参阅参数 1） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WIN32K_POWER_WATCHDOG_TIMEOUT参数解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。0x19C:WIN32K_POWER_WATCHDOG_TIMEOUT\n\n问题原因：\n\n第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x1A2": "BUG代码 0x1A2：WIN32K_CALLOUT_WATCHDOG_BugCHECK\n项目 • 2023/06/20WIN32K_CALLOUT_WATCHDOG_BugCHECK实时转储的值为 0x000001A2。 它表示对Win32k 的标注未立即返回。以下参数显示在蓝屏上。参数 描述1 线程阻塞提示从 Win32k 标注返回。2 保留。3 保留。4 保留。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WIN32K_CALLOUT_WATCHDOG_BugCHECK参数另请参阅", "0x1AA": "BUG代码 0x1AA：EXCEPTION_ON_INVALID_STACK\n项目 • 2023/06/15EXCEPTION_ON_INVALID_STACK Bug 检查 的值为 0x000001AA。 此 Bug 检查指示异常调度已交叉到无效的内核堆栈中。 这可能表示内核堆栈指针在异常调度或展开 (已损坏，例如，由于帧指针) 的堆栈损坏，或者驱动程序正在从不是合法内核堆栈的堆栈上执行。参数 说明1 指向当前堆栈的指针。2 堆栈的类型限制（如 NormalStackLimits） (3) 。 由于堆栈无效，这表示内核对给定计算机状态时应处于活动状态的内核堆栈类型的最佳估计。堆栈限制类型：0x0 - 如果在 Bug 检查期间计算堆栈限制，则 Bug 检查堆栈 (任何堆栈)0x1 - 处理器 DPC 堆栈0x2 - KeExpandKernelStackAndCallout (Ex) 堆栈0x3 - 普通内核线程堆栈0x4 - 线程上下文交换期间的内核线程堆栈 (不明确哪个线程处于活动状态)0x5 - win32k 内核/用户标注堆栈0x6 - 处理器 ISR 堆栈0x7 - 内核调试器堆栈在处理 KD I/O) 时 (任何堆栈0x8 - 处理器 NMI 处理堆栈0x9 - 处理堆栈检查处理器计算机0xA - 处理器异常堆栈 (用于调度某些引发的 IRQL 异常)3 指向上下文记录的指针，表示在遇到无效堆栈时为异常) 解除 (或调度的上下文。4 提供表示正在调度的活动异常的异常记录。） 重要本主题面向程序员。 如果你是使用计算机时收到此错误代码的客户，请参阅 蓝屏错误疑难解答 。EXCEPTION_ON_INVALID_STACK参数原因尝试访问无效堆栈。 由于内核堆栈的大小有限，因此开发人员需要小心跟踪它的限制，例如，当使用它复制视频内存块时。 有关 Windows 内核堆栈的信息，请参阅 使用内核堆栈。解决方法使用完整内核转储或附加的调试器，以下命令可能有助于收集信息并跟踪错误访问内存的代码。首先使用 ！analyze 命令收集信息，特别是 Bug 检查参数。 此外，检查出错的源行和模块名称（如果可用）。dbgcmdArguments:Arg1: 00000018940ffbe8Arg2: 0000000000000003Arg3: ffffe301c8db2900Arg4: ffffdc0e9ee665d8使用 ！analyze 输出中提供的 .trap 命令链接将上下文设置为陷阱帧。dbgcmd2: kd> .trap 0xffffdc0e9ee66680NOTE: The trap frame does not contain all registers.Some register values may be zeroed or incorrect.rax=003f8b813f20b6e0 rbx=0000000000000000 rcx=ee7defdd9c530000rdx=ffffcb81660ea078 rsi=0000000000000000 rdi=0000000000000000rip=fffff8002b7f8933 rsp=ffffdc0e9ee66810 rbp=ffffcb81511c3010 r8=0000000000000001 r9=0000000000004014 r10=ffffdc0e9ee66910r11=0000000000000000 r12=0000000000000000 r13=0000000000000000r14=0000000000000000 r15=0000000000000000iopl=0 nv up ei pl zr na po ncdxgmms2!RemoveHeadList+0xd [inlined indxgmms2!VidSchiSignalRegisteredSyncObjects+0x3f]:fffff800`2b7f8933 48395808 cmp qword ptr [rax+8],rbxds:003f8b81`3f20b6e8=????????????????使用 ！vm 命令检查内存使用情况，例如，查看正在使用的内核堆栈内存量。dbgcmd0: kd> !vmPhysical Memory: 1541186 ( 6164744 Kb)Available Pages: 470550 ( 1882200 Kb)ResAvail Pages: 1279680 ( 5118720 Kb)...Kernel Stacks: 13686 ( 54744 Kb)在此示例中，使用的内存量较少。使用 ！thread 命令收集有关正在运行的内容的信息。 在此示例中，它看起来像一个视频计划程序工作线程正在运行。dbgcmd2: kd> !threadTHREAD ffffcb816348b040 Cid 0c58.4a1c Teb: 0000000000000000 Win32Thread:0000000000000000 RUNNING on processor 2Not impersonatingDeviceMap ffff840f38c04170Owning Process ffffcb81648980c0 Image: YourPhone.exeAttached Process N/A Image: N/AWait Start TickCount 34501403 Ticks: 0Context Switch Count 43 IdealProcessor: 3 UserTime 00:00:00.000KernelTime 00:00:00.015Win32 Start Address 0x00007fff34656d00Stack Init ffffdc0e9ee675b0 Current ffffdc0e9ee66610Base ffffdc0e9ee68000 Limit ffffdc0e9ee61000 Call 0000000000000000Priority 8 BasePriority 8 PriorityDecrement 0 IoPriority 2 PagePriority 5...然后使用 kb (显示堆栈回溯) 和 f 选项显示堆栈和内存使用情况，以查看是否存在较大的内存用户。dbgcmd2: kd> kf...02 40 ffffdc0e`9ee66850 fffff800`2b7f8801 dxgmms2!VidSchiMarkDeviceAsError+0x4d ...如果代码的特定部分看起来可疑，请使用 u、ub、uu (Unassemble) 命令检查关联的汇编语言代码。dbgcmd2: kd> u ffffdc0e`9ee66850 l10ffffdc0e`9ee66850 1030 adc byte ptr [rax],dhffffdc0e`9ee66852 1c51 sbb al,51hffffdc0e`9ee66854 81cbffffc068 or ebx,68C0FFFFhffffdc0e`9ee6685a e69e out 9Eh,alffffdc0e`9ee6685c 0e ???ffffdc0e`9ee6685d dcff fdiv st(7),stffffdc0e`9ee6685f ff00 inc dword ptr [rax]ffffdc0e`9ee66861 0000 add byte ptr [rax],alffffdc0e`9ee66863 0000 add byte ptr [rax],alffffdc0e`9ee66865 0000 add byte ptr [rax],alffffdc0e`9ee66867 000e add byte ptr [rsi],clffffdc0e`9ee66869 0000 add byte ptr [rax],alffffdc0e`9ee6686b 0000 add byte ptr [rax],alffffdc0e`9ee6686d 0000 add byte ptr [rax],alffffdc0e`9ee6686f 0010 add byte ptr [rax],dlffffdc0e`9ee66871 301c51 xor byte ptr [rcx+rdx*2],bl使用 .cxr (显示上下文记录) 命令，使用 ！analyze 提供的参数 3 值显示上下文记录。dbgcmd2: kd> .cxr ffffe301c8db2900rax=003f8b813f20b6e0 rbx=ffffcb813f607650 rcx=ee7defdd9c530000rdx=ffffcb81660ea078 rsi=0000000000000000 rdi=ffffcb81511c30a8rip=fffff8002b7f8933 rsp=ffffdc0e9ee66810 rbp=ffffcb81511c3010 r8=0000000000000001 r9=0000000000004014 r10=ffffdc0e9ee66910r11=0000000000000000 r12=ffffdc0e9ee66910 r13=ffffcb814019c000r14=0000000000000000 r15=ffffdc0e9ee66910iopl=0 nv up ei pl zr na po nccs=0010 ss=0018 ds=002b es=002b fs=0053 gs=002b efl=00050246dxgmms2!RemoveHeadList+0xd [inlined indxgmms2!VidSchiSignalRegisteredSyncObjects+0x3f]:fffff800`2b7f8933 48395808 cmp qword ptr [rax+8],rbxds:002b:003f8b81`3f20b6e8=????????????????使用 .exr (显示异常记录) 命令，使用 ！analyze 提供的参数 4 值显示异常记录。dbgcmd2: kd> .exr ffffdc0e9ee665d8ExceptionAddress: fffff8002b7f8933(dxgmms2!RemoveHeadList+0x000000000000000d) ExceptionCode: c0000005 (Access violation) ExceptionFlags: 00000000NumberParameters: 2 Parameter[0]: 0000000000000000 Parameter[1]: ffffffffffffffffAttempt to read from address ffffffffffffffff异常记录指示尝试读取 和 地址 ffffffffffffffff，这将是一个需要进一步调查的区域。另请参阅Bug 检查代码参考", "0x1AB": "BUG代码 0x1AB：UNWIND_ON_INVALID_STACK\n项目 • 2023/06/20UNWIND_ON_INVALID_STACK Bug 检查 的值为 0x000001AB。 它表示尝试访问有效内核堆栈范围之外的内存。 具体而言，此 BugCheck 指示堆栈展开交叉到无效的内核堆栈。这可能表示内核堆栈指针在异常调度或展开 (已损坏，例如，由于帧指针) 的堆栈损坏，或者驱动程序正在从不是合法内核堆栈的堆栈上执行。发生无效访问时，异常记录不可用。参数 描述1 指向当前堆栈的指针。2 堆栈的类型限制（如 NormalStackLimits） (3) 。 由于堆栈无效，这表示内核对给定计算机状态时应处于活动状态的内核堆栈类型的最佳估计。堆栈限制类型：0x0 - 如果在 Bug 检查期间计算堆栈限制，则 Bug 检查堆栈 (任何堆栈)0x1 - 处理器 DPC 堆栈0x2 - KeExpandKernelStackAndCallout (Ex) 堆栈0x3 - 普通内核线程堆栈0x4 - 线程上下文交换期间的内核线程堆栈 (不明确哪个线程处于活动状态)0x5 - win32k 内核/用户标注堆栈0x6 - 处理器 ISR 堆栈0x7 - 内核调试器堆栈在处理 KD I/O) 时 (任何堆栈0x8 - 处理器 NMI 处理堆栈0x9 - 处理堆栈检查处理器计算机0xA - 处理器异常堆栈 (用于调度某些引发的 IRQL 异常)3 指向上下文记录的指针，表示在遇到无效堆栈时为异常) 解除 (或调度的上下文。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UNWIND_ON_INVALID_STACK参数参数 描述4 ExceptionRecord - 保留，UNWIND_ON_INVALID_STACK始终为 0。尝试访问无效堆栈。 由于内核堆栈的大小有限，开发人员需要小心跟踪它的限制，例如，当使用它复制视频内存块时。 有关 Windows 内核堆栈的信息，请参阅 使用内核堆栈。使用完整内核转储或附加的调试器，以下命令可能有助于收集信息并跟踪错误访问内存的代码。首先使用 ！analyze 命令收集信息，特别是 Bug 检查参数。 此外，检查出错的源行和模块名称（如果可用）。dbgcmd使用 ！analyze 输出中提供的 .trap 命令链接将上下文设置为陷阱帧。dbgcmd使用 ！thread 命令收集有关正在运行的内容的信息。 在此示例中，它看起来像一个视频计划程序工作线程正在运行。dbgcmd原因解决方法Arguments:Arg1: 89344350fffff607Arg2: 0000000000000003Arg3: fffff607893436c4Arg4: fffff60789343ea8TRAP_FRAME: fffff60789343f50 -- (.trap 0xfffff60789343f50)NOTE: The trap frame does not contain all registers.Some register values may be zeroed or incorrect.rax=fffff607893441e8 rbx=0000000000000000 rcx=0000000010000004rdx=0000000000000002 rsi=0000000000000000 rdi=0000000000000000rip=fffff8026dc296cf rsp=fffff607893440e8 rbp=fffff60789344350 r8=fffff8028e7a08b2 r9=0000000000000008 r10=fffff8029e9c3980r11=fffff607893440f8 r12=0000000000000000 r13=0000000000000000r14=0000000000000000 r15=00000000000000002: kd> !threadTHREAD ffff8f8e9af25080 Cid 0004.0378 Teb: 0000000000000000 Win32Thread:0000000000000000 RUNNING on processor 2Not impersonatingDeviceMap ffffd601dbe63e30Owning Process ffff8f8e99ab4040 Image: SystemAttached Process N/A Image: N/AWait Start TickCount 14361 Ticks: 0Context Switch Count 64607 IdealProcessor: 1 UserTime 00:00:00.000KernelTime 00:00:06.046Win32 Start Address dxgmms2!VidSchiWorkerThread (0xfffff8027a70d100)Stack Init fffff60789344c70 Current fffff607893445c0Base fffff60789345000 Limit fffff6078933f000 Call 0000000000000000Priority 16 BasePriority 16 PriorityDecrement 0 IoPriority 2 PagePriority 5...然后使用 kb (显示堆栈回溯) 和 f 选项显示堆栈和内存使用情况，以查看是否存在较大的内存用户。dbgcmd2: kd> kf...02 198 fffff607`89344460 fffff802`8e6b41d5 amdkmdag+0x2308b203 120 fffff607`89344580 fffff802`8e59eb35 amdkmdag+0x1441d504 30 fffff607`893445b0 fffff802`8e62b5e8 amdkmdag+0x2eb3505 c0 fffff607`89344670 fffff802`8e623f6c amdkmdag+0xbb5e8...如果代码的特定部分看起来可疑，请使用 u、ub、uu (Unassemble) 命令检查关联的汇编语言代码。dbgcmd2: kd> u fffff607`893442c8 l10fffff607`893442c8 d04234 rol byte ptr [rdx+34h],1fffff607`893442cb 8907 mov dword ptr [rdi],eaxfffff607`893442cd f6ff idiv bhfffff607`893442cf ff01 inc dword ptr [rcx]fffff607`893442d1 17 ???fffff607`893442d2 c4 ???fffff607`893442d3 9f lahffffff607`893442d4 8e8fffff0060 mov cs,word ptr [rdi+6000FFFFh]fffff607`893442da 5a pop rdxfffff607`893442db 9f lahffffff607`893442dc 8e8fffff0000 mov cs,word ptr [rdi+0FFFFh]fffff607`893442e2 0000 add byte ptr [rax],alfffff607`893442e4 0000 add byte ptr [rax],alfffff607`893442e6 0000 add byte ptr [rax],alfffff607`893442e8 7527 jne fffff607`89344311fffff607`893442ea 6e outs dx,byte ptr [rsi]使用 .cxr (显示上下文记录) 命令，使用 ！analyze 提供的参数 3 值显示上下文记录。dbgcmd.cxr fffff607893436c4使用 ！vm 命令检查内存使用情况，例如，查看正在使用的内核堆栈内存量。dbgcmd0: kd> !vmPhysical Memory: 1541186 ( 6164744 Kb)Available Pages: 470550 ( 1882200 Kb)ResAvail Pages: 1279680 ( 5118720 Kb)...Kernel Stacks: 13686 ( 54744 Kb)使用具有 2 参数的 ！stacks 命令查看有关堆栈的信息。 此命令可能需要一些时间才能运行。 检查输出中可能指向 和 区域进行进一步调查的受阻执行的重复模式。另请参阅Bug 检查代码参考", "0x1C6": "BUG代码 0x1C6：FAST_ERESOURCE_PRECONDITION_VIOLATION\n项目 • 2023/06/20FAST_ERESOURCE_PRECONDITION_VIOLATION Bug 检查值为 0x000001C6。 它指示当前线程正在对快速资源例程执行无效调用。参数 描述1 冲突类型。 请参阅下面的值。2 请参阅下面的值。3 请参阅下面的值。4 请参阅下面的值。冲突类型text） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。FAST_ERESOURCE_PRECONDITION_VIOLATION参数 0x0 : The Irql of the caller was greater than the maximumallowed Irql for the routine. 2 - Irql of the caller. 3 - Maximum allowed Irql of the routine. 0x1 : The caller specified an invalid (i.e. uninitialized) owner entry. 2 - Pointer to the owner entry. 0x2 : The caller specified an owner entry that was already associated with a lock acquisition. 2 - Pointer to the owner entry. 3 - Pointer to the resource to which the owner entry isalready associated. 0x3 : The caller passed a legacy resource to a fast resource routine. 2 - Pointer to the resource. 0x4 : The caller specified a resource that has outstanding lock acquisitions. 2 - Pointer to the resource. 0x5 : The caller was executing inside of a DPC. 0x6 : The caller was executing inside of a Special Kernel APC. 0x7 : The caller did not ensure Normal Kernel APCs weredisabled. 0x8 : The caller specified an owner entry that was notassociated with a lock acquisition of the specified resource. 2 - Pointer to the resource specified. 3 - Pointer to the owner entry. 4 - Pointer to the resource with which the owner entry is associated. 0x9 : The caller specified an owner entry that was notassociated with the calling thread. 2 - Pointer to the owner entry. 3 - Pointer to the thread with which the owner entry is associated. 0xa : The caller specified an owner entry which has beendisowned. 2 - Pointer to the owner entry. 0xb : The caller specified an owner entry with a different acquisition type than the caller indicated. 2 - Pointer to the owner entry. 3 - High-16 bits indicate the acquisition type of the owner entry. Bottom-16 bits indicate the acquisition type specified. 1 = Shared, 0 = Exclusive. 0xc : The caller specified an owner entry that was notassociated with a lock acquisition of the specified resource. 2 - Pointer to the resource specified. 3 - Pointer to the owner entry. 4 - Pointer to the resource with which the owner entry is associated. 0xd : The caller specified an owner entry that has not been disowned. 2 - Pointer to the owner entry. 0xe : The caller passed a fast resource to a legacy routine that does not support fast resources. 2 - Pointer to the resource. 0xf : The caller passed a fast resource to a legacy routine that supports fast resources, but the fast resource was not initialized with EX_FAST_RESOURCE_ENABLE_LEGACY_APIS. 2 - Pointer to the resource. 0x10 : The caller passed invalid flags toExInitializeFastResource. 2 - Pointer to the resource specified. 3 - The flags specified. 0x11 : The caller passed a thread other than the current threadto ExReleaseResourceForThreadLite. 2 - Pointer to the resource specified. 3 - The thread specified. 0x12 : The caller attempted to disown a resource that had been recursively acquired exclusive by the current thread. 2 - Pointer to the resource specified. 0x13 : The caller attempted to convert a resource acquisitionwhile the calling thread had outstanding recursive acquisitionsof the resource. 2 - Pointer to the resource specified. 0x14 : A thread exited with outstanding lock acquisitions. 2 - The thread. 3 - Pointer to one of the outstanding owner entries. 0x15 : A thread exited with outstanding disowned lockacquisitions. 2 - The thread. 3 - Pointer to one of the outstanding owner entries. 0x16 : A call to ExConvertExclusiveToSharedLite was made by athread that did not hold the specified resource exclusive. 2 - Pointer to the resource. 3 - Pointer to the thread.原因当前线程正在对快速资源例程执行无效调用。解决方法!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。另请参阅Bug 检查代码参考", "0x1C7": "BUG代码 0x1C7：STORE_DATA_STRUCTURE_CORRUPTION\n项目 • 2023/06/20STORE_DATA_STRUCTURE_CORRUPTION Bug 检查 值为 0x000001C7。 它指示存储组件在其数据结构中检测到损坏。参数 描述1 损坏 ID。 请参阅下面的值。2 请参阅下面的值。3 请参阅下面的值。4 请参阅下面的值。损坏 IDtext） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。STORE_DATA_STRUCTURE_CORRUPTION参数 0x0 : A chunk heap buffer's hash doesn't match. 2 - Chunk heap buffer whose hash didn't match. 3 - Expected buffer hash. 4 - Page frame number of the corrupted page. 0x1 : An unhandled exception occurred on the store thread and a chunk heapbuffer's hash doesn't match, which is likely the source of the exception. 2 - Chunk heap buffer whose hash didn't match. 3 - Expected buffer hash. 4 - Page frame number of the corrupted page. 0x2 : Page data appears corrupt during a read and the corresponding pagerecord's heap buffer hash doesn't match. 2 - Chunk heap buffer whose hash didn't match containing the page recordof the data being read. 3 - Expected buffer hash. 4 - Page frame number of the corrupted page. 0x3 : Page data appears corrupt during a read and the corresponding pagerecord has changed since the start of the read operation. 2 - Pointer to the page location information snapped from the pagerecord that was found when the read was initiated. 3 - Pointer to the page record currently in the page tree for the samepage key. 4 - Reserved.原因存储组件检测到其数据结构损坏。由于物理内存访问，内存损坏可能会导致此 Bug 检查。 物理内存损坏的原因包括：1. RAM 硬件有缺陷2. 驱动程序或设备通过错误的 DMA 操作或关联的 MDL 错误地修改物理页面。3. 硬件设备损坏或固件损坏内存导致的损坏，例如固件在电源转换中非法修改物理页面。有关 Windows 内存管理器的详细信息，请参阅由 Pavel Yosifovich、Mark E.Russinovich、David A. Solomon 和 Alex Ionescu 撰写的 Windows Internals 7th Edition第 1 部分 。解决方法Windows 内存诊断工具若要调查此 Bug 检查是否由 RAM 硬件缺陷引起的，请运行 Windows 内存诊断工具。 在控制面板搜索框中，键入“内存”，然后选择“ 诊断计算机的内存问题”。运行测试后，使用事件查看器查看系统日志下的结果。 查找“内存诊断结果”条目以查看结果 。另请参阅Bug 检查代码参考Windows 内核模式内存管理器Bug 检查0x1C8：MANUALLY_INITIATED_POWER_BUTTON_HOLD\n项目 • 2023/06/20MANUALLY_INITIATED_POWER_BUTTON_HOLD的值为 0x000001C8。系统配置为在用户按住电源按钮一段指定时间长度时启动 Bug 检查。 这是一种诊断错误检查，用于在系统即将使用长电源按钮保持进行硬重置时捕获转储。请注意，当出现此 Bug 检查而不是显示标准“蓝屏”时，将显示具有以下文本的黑色背景以及完成百分比指示器：“请松开电源按钮。 我们只需要几秒钟的时间就关机了。蓝屏上会显示以下参数。参数 描述1 按下电源按钮的时间（以毫秒为单位）。2 指向 nt！_POP_POWER_BUTTON_TRIAGE_BLOCK 的指针。3 保留。4 保留。使用电源按钮强制系统崩溃Inside Show - Bugcheck 0x1C8 MANUALLY_INITIATED_POWER_BUTTON_HOLD） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MANUALLY_INITIATED_POWER_BUTTON_HOLD参数另请参阅ACPI 按钮设备", "0x1CA": "BUG代码 0x1CA：SYNTHETIC_WATCHDOG_TIMEOUT\n项目 • 2023/06/20SYNTHETIC_WATCHDOG_TIMEOUT Bug 检查 值为 0x000001CA。 系统范围的监视器已过期。 这表示系统已挂起，并且未处理计时器计时周期。参数 描述1 自监视器上次重置以来的时间（以中断时间为单位）。2 当前中断时间。3 当前 QPC 时间戳。4 时钟处理器的索引。系统范围的监视器已过期。 这表示系统已挂起，并且未处理计时器计时周期。!analyze 调试程序扩展显示有关 Bug 检查的信息，有助于确定根本原因。 有关 WinDbg和 ！analyze 的详细信息，请参阅 使用 ！analyze 扩展 和 ！analyze。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SYNTHETIC_WATCHDOG_TIMEOUT参数原因解决方法另请参阅", "0x1CB": "BUG代码 0x1CB：INVALID_SILO_DETACH\n项目 • 2023/06/20INVALID_SILO_DETACH Bug 检查 的值为 0x000001CB。 它表示线程在退出之前无法从silo 分离。参数 说明1 指向附加线程的指针。2 以前附加的 silo。3 指向线程进程的指针。4 保留。线程在退出之前未能从 silo 中分离。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_SILO_DETACH参数原因另请参阅", "0x1CD": "BUG代码 0x1CD：INVALID_CALLBACK_STACK_ADDRESS\n项目 • 2023/06/20） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_CALLBACK_STACK_ADDRESS Bug 检查 的值为 0x000001CD。 回调堆栈是非法的用户模式地址。INVALID_CALLBACK_STACK_ADDRESS参数无", "0x1CE": "BUG代码 0x1CE：INVALID_KERNEL_STACK_ADDRESS\n项目 • 2023/06/20） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。INVALID_KERNEL_STACK_ADDRESS Bug 检查 的值为 0x000001CE。 在上下文切换期间遇到无效的初始内核堆栈地址。INVALID_KERNEL_STACK_ADDRESS参数无", "0x1CF": "BUG代码 0x1CF：HARDWARE_WATCHDOG_TIMEOUT\n项目 • 2023/06/20HARDWARE_WATCHDOG_TIMEOUT Bug 检查 的值为 0x000001CF。 这表示系统已挂起，并且未处理计时器计时周期。参数 描述1 自监视器上次重置以来的时间（以中断时间为单位）。2 当前中断时间。3 当前 QPC 时间戳。4 时钟处理器的索引。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HARDWARE_WATCHDOG_TIMEOUT参数Bug 检查0x1D0：ACPI_FIRMWARE_WATCHDOG_TIMEOUT\n项目 • 2023/06/20ACPI_FIRMWARE_WATCHDOG_TIMEOUT Bug 检查 的值为 0x000001D0。ACPI 驱动程序未能在预期的分配时间内完成操作。蓝屏上会显示以下参数。参数 描述1 指向 AMLI 上下文的指针2 指向 Aml 上下文的 Unicode 名称的指针3 指向 ACPI 设备扩展的指针。4 指向 ACPI 会审块的指针。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ACPI_FIRMWARE_WATCHDOG_TIMEOUT参数", "0x1D2": "BUG代码 0x1D2：WORKER_THREAD_INVALID_STATE\n项目 • 2023/06/20WORKER_THREAD_INVALID_STATE Bug 检查 的值为 0x000001D2。此错误指示执行工作线程处于无效状态。参数 描述1 故障类型2 工作线程的地址3 保留4 保留参数 1 值0x0：终止过程中的工作线程具有未完成的 I/O2 - 工作线程的地址3 - 保留4 - 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_INVALID_STATE参数", "0x1D3": "BUG代码 0x1D3：WFP_INVALID_OPERATION\n项目 • 2023/06/20WFP_INVALID_OPERATION Bug 检查 的值为 0x000001D3。 这表示 Windows 筛选平台标注执行了无效操作。参数 描述1 Bug 检查的子类型。2 保留3 保留4 保留参数 1 值0x1：标注注入了具有多个入站NET_BUFFERS的 NBL。2 - 保留。3 - 指向 NBL 的指针。4 - 保留。！analyze 调试扩展检查显示有关 Bug 的信息，在确定根本原因方面非常有用。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WFP_INVALID_OPERATION参数解决方法", "0x1D5": "BUG代码 0x1D5：DRIVER_PNP_WATCHDOG\n项目 • 2023/06/20DRIVER_PNP_WATCHDOG Bug 检查 的值为 0x000001D5。 这表示驱动程序在特定时间内未能完成 PnP 操作。参数 描述1 与开发节点关联的服务的前几个字符。2 指向 nt！TRIAGE_PNP_WATCHDOG Win10 RS4 及更高版本。3 负责 PnP 监视程序的线程。4 自监视器持械以来已过毫秒。这表示驱动程序在特定时间内未能完成 PnP 操作。 !analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DRIVER_PNP_WATCHDOG参数原因另请参阅", "0x1D6": "BUG代码 0x1D6：WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS\n项目 • 2023/06/20WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS Bug 检查 的值为 0x000001D6。 它指示工作线程更改了其工作负荷类，并且未在返回之前还原它。参数 说明1 工作线程例程的地址 (在此上使用 ln 来查找负责任的驱动程序)2 当前工作负荷类值。3 WorkItem 参数。4 WorkItem 地址。工作线程更改了其工作负荷类，在返回之前未还原它。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS参数原因另请参阅", "0x1D7": "BUG代码 0x1D7：EFS_FATAL_ERROR\n项目 • 2023/06/20EFS_FATAL_ERROR Bug 检查 的值为 0x000001D7。 它指示发生了 EFS 错误条件，因此在数据丢失或数据损坏的情况下无法处理。参数 描述1 Bug 检查子类： 01 - 预卸载失败。2 NTSTATUS 返回操作的代码。3 发生故障时的当前 IRP。4 失败时的文件加密上下文。出现 EFS 错误情况，因此无法在不丢失数据或数据损坏的情况下进行处理。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。检查参数 2 NTSTATUS 字段，尝试确定为何不返回NT_SUCCESS。 对于调用加密预卸载的文件系统，这是预期的且唯一允许的值。使用调试器 ！用于 调查参数 3 的 IRP 命令，以查找可能存在的冲突 IRP 代码或其他问题。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。EFS_FATAL_ERROR参数原因解决方法另请参阅Bug 检查代码参考", "0x1D8": "BUG代码 0x1D8：UCMUCSI_FAILURE\n项目 • 2023/06/20UCMUCSI_FAILURE Bug 检查 的值为 0x000001D8。 它指示 UCSI 类扩展遇到错误。参数描述1 失败类型。 值： 0x0 ：UCSI 命令已超时，因为固件未及时响应该命令。 0x1 ：由于客户端驱动程序返回失败或固件返回错误代码，UCSI 命令执行失败。2 UCSI 命令值。3 如果为非零，则指向其他信息的指针 (使用 dt UcmUcsiCx!UCMUCSICX_TRIAGE ) 。4 保留。UcmUcsi 驱动程序遇到错误。 驱动程序已找到用于触发系统崩溃的设置，而不是使用livedump。当 UCSI 固件无响应且 UcmUcsiCx 在 UCSI 命令上超时，或者 UCSI 固件在响应UcmUcsiCx 发送的关键 UCSI 命令时指示错误时，UCSI 命令通常会失败。运行 !rcdrkd.rcdrlogdump UcmUcsiCx 以获取有关此失败原因的详细信息。有关分析此 Bug 检查的详细信息，请参阅此博客文章 - 调试 UCSI 固件故障 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。UCMUCSI_FAILURE参数原因解决方法另请参阅Bug 检查代码参考", "0x1D9": "BUG代码 0x1D9：HAL_IOMMU_INTERNAL_ERROR\n项目 • 2023/06/20HAL_IOMMU_INTERNAL_ERROR Bug 检查 的值为 0x000001D9。 它指示在 HAL IOMMU库中检测到内部错误。参数 描述1 指示失败的操作。 请参阅下面的值。2 请参阅下面的值。3 请参阅下面的值。4 请参阅下面的值。失败的操作值text） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HAL_IOMMU_INTERNAL_ERROR参数0x00 : Failed to delete IOMMU domain Parameter 2 - Status Parameter 3 - Pointer to the IOMMU domain object0x01 : Failed to unmap pages from IOMMU domain Parameter 2 - Status Parameter 3 - Pointer to the IOMMU domain object Parameter 4 - Logical address0x02 : Failed to leave IOMMU domain Parameter 2 - Status Parameter 3 - Pointer to the IOMMU domain object原因在 HAL IOMMU 库中检测到内部错误。另请参阅Bug 检查代码参考", "0x1DA": "BUG代码 0x1DA：HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR\n项目 • 2023/06/20HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR的值为 0x000001DA。 它指示在阻止的处理器库中检测到内部错误。蓝屏上会显示以下参数。参数 描述1 故障类型 - 请参阅下文2 请参阅下文。3 请参阅下文。4 请参阅下文。plaintext） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR参数参数一值 0x01 : Library initialization failure 2 - NT status code 0x02 : Processor start failure 2 - Processor index 3 - APIC ID 0x03 : PPM package ID query failure 2 - Processor index 0x04 : PPM operation failure 2 - Operation 0x01 : MSR read 0x02 : MSR write 0x03 : I/O port read 0x04 : I/O port write 0x05 : Idle state registration 3 - Processor index 4 - PPM mailbox 0x05 : A blocked processor has encountered a fatal exception. 2 - Processor index 3 - Vector number 4 - Trap frame 0x06 : PPM operation timeout 2 - Operation 0x01 : MSR read 0x02 : MSR write 0x03 : I/O port read 0x04 : I/O port write 0x05 : Idle state registration 3 - Processor index 4 - PPM mailbox", "0x1DB": "BUG代码 0x1DB：IPI_WATCHDOG_TIMEOUT\n项目 • 2023/06/20IPI_WATCHDOG_TIMEOUT Bug 检查 值为 0x000001DB。 它表示处理器在 IPI 循环中卡住的时间超过允许的时间。参数 描述1 指示 QPC 频率。2 指示当前 QPC。3 指示基线 QPC。4 保留。处理器在 IPI 循环中卡住的时间超过允许的时间。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。IPI_WATCHDOG_TIMEOUT参数原因另请参阅", "0x1DC": "BUG代码 0x1DC：DMA_COMMON_BUFFER_VECTOR_ERROR\n项目 • 2023/06/20DMA_COMMON_BUFFER_VECTOR_ERROR Bug 检查 的值为 0x000001DC。 它表示驱动程序已滥用 DMA 矢量通用缓冲区 API。参数 描述1 指示失败的类型。 请参阅下面的值。2 请参阅下面的值。3 请参阅下面的值。4 请参阅下面的值。故障类型text） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DMA_COMMON_BUFFER_VECTOR_ERROR参数0x01 : Wrong IRQL 2 - Current IRQL.x02 : Vector not empty. 2 - Index of remaining buffer. 3 - Virtual Address of remaining buffer. 4 - Logical address of remaining buffer.0x03 : Index out of bounds. 2 - Number of available entries. 3 - Index requested.0x04 : Index freed. 2 - Index requested.0x05 : Common buffer leaked.原因驱动程序误用了 DMA 矢量通用缓冲区 API。 !analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。另请参阅Bug 检查代码参考Bug 检查0x1DD：BugCODE_MBBADAPTER_DRIVER\n项目 • 2023/06/20BugCODE_MBBADAPTER_DRIVER Bug 检查 的值为 0x000001DD。 这表示操作系统遇到由 MBBCx 管理的网络驱动程序导致的错误。 MBBCx 以基于 KMDF 的 MBB 客户端驱动程序的形式为 MBB 设备提供移动宽带 (MBB) 媒体特定功能。 有关详细信息，请参阅 移动宽带 (MBB) WDF 类扩展简介 (MBBCx) 。参数 描述1 以下故障代码之一0 - FailureCode_CorruptedPrivateGlobals1 - FailureCode_IrqlIsNotPassive2 - FailureCode_IrqlNotLessOrEqualDispatch3 - FailureCode_InvalidStructTypeSize4 - FailureCode_InvalidPowerCapabilities5 - FailureCode_InvalidWakeReason6 - FailureCode_DisarmNotInProgress7 - FailureCode_WdfObjectCreateFailed2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BugCODE_MBBADAPTER_DRIVER参数解决方法！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因。参数 1 描述冲突的类型。 查看调用堆栈以确定行为不当的驱动程序。另请参阅移动宽带 (MBB) WDF 类扩展 (MBBCx) 的简介Bug 检查代码参考Bug 检查0x1DE：BugCODE_WIFIADAPTER_DRIVER\n项目 • 2023/06/20BugCODE_WIFIADAPTER_DRIVER Bug 检查 的值为 0x000001DE。 这表示操作系统遇到由 WiFiCx 管理的网络驱动程序导致的错误。 wiFiCx) (Wi-Fi WDF 类扩展支持适用于Wi-Fi设备的基于 KMDF 的 Wi-Fi 客户端驱动程序。 有关详细信息，请参阅 wiFiCx) (Wi-Fi WDF类扩展简介 。参数 描述1 此处列出的 WiFiCx BugCheck 子代码值。0x0 - WiFiCx 专用全局已损坏。0x1：名为 WiFiCx API 的驱动程序，要求在非法IRQL 下使用被动 IRQL。2 - 当前 IRQL。0x2：名为 WiFiCx API 的驱动程序，要求 IRQL小于或等于非法 IRQL 的调度。2 - 当前 IRQL。0x3：向 WiFiCx API 传递了大小无效的结构。2 - 驱动程序传递的结构的大小。3 - OS 的 WiFiCx 版本使用的结构大小。 请注意，不需要与传递的结构完全匹配，但较旧WiFiCx 版本中的结构大小应比较新版本的结构大小<= 。0x4：驱动程序报告了唤醒原因无效。2 - 报告的唤醒原因。0x5：驱动程序将无效或损坏的WIFI_POWER_OFFLOAD_LIST传递给 WiFiCxAPI。2 - 指向WIFI_POWER_OFFLOAD_LIST的指针。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BugCODE_WIFIADAPTER_DRIVER参数参数 描述0x6：驱动程序将无效或损坏的WIFI_WAKE_SOURCE_LIST传递给 WiFiCx API。2 - 指向WIFI_WAKE_SOURCE_LIST的指针。0x7：驱动程序将无效或未初始化的WIFI_INTERFACE_CONTEXT传递给 WiFiCx API。2 - 指向传递的WIFI_INTERFACE_CONTEXT的指针。0x8：驱动程序将具有无效WIFI_ADAPTER_TX_DEMUX_TYPE的WIFI_ADAPTER_TX_DEMUX传递给 WiFiCx API。2 - 指向传递的WIFI_ADAPTER_TX_DEMUX的指针。3 - 通过WIFI_ADAPTER_TX_DEMUX的WIFI_ADAPTER_TX_DEMUX_TYPE。0x9：驱动程序将具有无效范围的WIFI_ADAPTER_TX_DEMUX传递给 WiFiCx API。2 - 指向传递的WIFI_ADAPTER_TX_DEMUX的指针。3 - 传递WIFI_ADAPTER_TX_DEMUX的范围。0xA：驱动程序在无效时间报告唤醒原因。 应从解除武装唤醒回调中报告唤醒原因。0xB：驱动程序在 WiFiCx 结构中使用已弃用的字段。2 - 指向表示已弃用字段的字符串的指针。2 依赖于 Param 13 依赖于 Param 14 保留！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因。参数 1 描述冲突的类型。 查看调用堆栈以确定行为不端的驱动程序。Wi-Fi WDF 类扩展 (WiFiCx) 简介解决方法另请参阅Bug 检查代码参考Bug 检查0x1DF：PROCESSOR_START_TIMEOUT\n项目 • 2023/06/20PROCESSOR_START_TIMEOUT Bug 检查 的值为 0x000001DF。 这表示处理器未能在允许的时间内启动。 处理器启动发生在操作系统初始化的早期。参数 描述1 处理器状态的虚拟地址。2 保留。3 NT 处理器编号。4 处理器的本地单元 ID。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PROCESSOR_START_TIMEOUT参数解决方法另请参阅", "0x1E4": "BUG代码 0x1E4：VIDEO_DXGKRNL_SYSMM_FATAL_ERROR\n项目 • 2023/06/20VIDEO_DXGKRNL_SYSMM_FATAL_ERROR Bug 检查 的值为 0x000001E4。 这表示Microsoft DirectX 图形内核系统内存管理器检测到冲突。参数 描述1 BugCheck 的子代码0x1：物理对象类型无效0x2：启用 IOMMU 但原因无效0x3 ：IOMMU 已禁用，原因无效0x4：正在针对非锁定内存生成 ADL0x5：当 ADL 存在时，内存正在解锁0x6：适配器对象已泄漏0x7：ADL 泄漏0x8：逻辑块池泄漏0x9：逻辑块池分配器泄漏0xA：失败的域重新附加2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。", "0x1E9": "BUG代码 0x1E9：ILLEGAL_ATS_INITIALIZATION\n项目 • 2023/06/20ILLEGAL_ATS_INITIALIZATION Bug 检查 的值为 0x000001E9。 这表示驱动程序尝试在已为共享虚拟内存启用 (SVM) 的设备上非法启用地址转换服务 (ATS) 。参数 描述1 物理设备对象。2 保留3 保留4 保留！analyze 调试扩展显示有关 Bug 检查的信息，有助于确定根本原因。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。ILLEGAL_ATS_INITIALIZATION参数解决方法", "0x1EA": "BUG代码 0x1EA：SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION\n项目 • 2023/06/20SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION Bug 检查的值为 0x000001EA。 这表示禁止通过直接映射 PCI MCFG 范围从 VTL0 访问 PCI 配置空间区域，因为启用了安全PCI。参数 描述1 导致异常的操作码。2 导致异常的设备 RID。3 配置空间访问偏移量。4 导致异常的指令的地址。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION参数解决方法", "0x1EB": "BUG代码 0x1EB：DAM_WATCHDOG_TIMEOUT\n项目 • 2023/06/20DAM_WATCHDOG_TIMEOUT Bug 检查的值为 0x000001EB。 这表明桌面活动审查器(DAM) 无法在设备从新式待机恢复后的分配时间段内取消冻结非豁免用户会话进程。参数 描述1 指向 DAM 用户会话延迟上下文的指针。2 保留3 保留4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。DAM_WATCHDOG_TIMEOUT参数解决方法Bug 检查0x1ED：HANDLE_ERROR_ON_CRITICAL_THREAD\n项目 • 2023/06/20HANDLE_ERROR_ON_CRITICAL_THREAD Bug 检查 的值为 0x000001ED。 这表示在系统关键线程的内核模式下检测到无效的句柄访问问题。参数 描述1 保留2 保留3 保留4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。Bug 检查代码参考） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HANDLE_ERROR_ON_CRITICAL_THREAD参数解决方法另请参阅", "0x356": "BUG代码 0x356：XBOX_ERACTRL_CS_TIMEOUT\n项目 • 2023/06/20XBOX_ERACTRL_CS_TIMEOUT Bug 检查 的值为 0x00000356。eractrl.sys驱动程序在长时间后无法将 Xbox 主机转换到连接待机或从连接待机转换。eractrl.sys驱动程序适用于 KM 驱动程序，该驱动程序可启动支持 VM 并帮助管理 VM 生存期。参数 描述1 CS 退出2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。XBOX_ERACTRL_CS_TIMEOUT参数", "0xBFE": "BUG代码 0xBFE：BC_BLUETOOTH_VERIFIER_FAULT\n项目 • 2023/06/20BC_BLUETOOTH_VERIFIER_FAULT Bug 检查 的值为 0x00000BFE。 这表示驱动程序已导致冲突。参数 描述1 蓝牙验证程序故障的子类型。0x1 : An attempt was made to submit aBluetooth Request Block that is already inuse 2 - Brb pointer 3 - Reserved 4 - Reserved0x2 : An attempt was made to free a BluetoothRequest Block that is in use 2 - Brb pointer3 - Reserved 4 - Reserved 0x3 : An attemptwas made to allocate or initialize an invalidBRB type 2 - Brb pointer 3 - pdo extension(if available) 4 - Reserved 0x4 : InvalidBluetooth Request Block pointer was submitted2 - Brb pointer 3 - Reserved 4 - Reserved 0x5: A Bluetooth Request Block with an invalidsize was submitted 2 - Brb pointer 3 - ActualSize 4 - Expected Size 0x6 : TheIOCTL_BTH_GET_DEVICE_INFO was called withinvalid parameters 2 - Reserved 3 - Reserved4 - Reserved 0x7 : BRB_L2CA_UNREGISTER_SERVERwas submitted with an invalid server handle 2- Server handle 3 - Reserved 4 - Reserved 0x8: BRB_L2CA_CLOSE_CHANNEL was submitted withan invalid channel handle 2 - Brb pointer 3 -Channel handle 4 - Reserved 0x9 :BRB_SCO_UNREGISTER_SERVER was submitted withan invalid server handle 2 - Server handle 3- Reserved 4 - Reserved） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BC_BLUETOOTH_VERIFIER_FAULT参数参数 描述2 请参阅参数 13 请参阅参数 14 请参阅参数 1!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 参数 1 描述冲突的类型。 查看调用堆栈以确定行为不当的驱动程序。解决方法", "0xBFF": "BUG代码 0xBFF：BC_BTHMINI_VERIFIER_FAULT\n项目 • 2023/06/20BC_BTHMINI_VERIFIER_FAULT Bug 检查 的值为 0x00000BFF。 这表示蓝牙微型端口可扩展驱动程序验证程序已捕获到冲突。参数 描述1 蓝牙验证程序错误的子类型。0x1 : An attempt was made to return a packetwith type that mis-matched its originalrequest. 2 - Returned packet type 3 -Expected packet type 4 - Reserved 0x2 : Anattempt was made to return an unexpectedstatus code and caused the packet to bediscarded. 2 - Unexpected return status 3 -Reserved 4 - Reserved 0x3 : Incorrect outputbuffer size was returned to indicate numberof bytes written by the lower transportdriver. 2 - Unexpected buffer size 3 -Expected buffer size 4 - Reserved2 请参阅参数 13 请参阅参数 14 请参阅参数 1!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 参数 1 描述冲突的类型。 查看调用堆栈以确定行为不端的驱动程序。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。BC_BTHMINI_VERIFIER_FAULT参数解决方法", "0x20001": "BUG代码 0x20001：HYPERVISOR_ERROR\n项目 • 2023/06/20HYPERVISOR_ERROR Bug 检查 的值为 0x00020001。 这表示虚拟机监控程序遇到严重错误。参数 描述1 保留2 保留3 保留4 保留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。HYPERVISOR_ERROR参数解决方法", "0x1000007E": "BUG代码 0x1000007E与0x1000007E:SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M\n\n问题原因：\n\n第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x1000007F": "BUG代码 0x1000007F：UNEXPECTED_KERNEL_MODE_TRAP_M\n项目 • 2023/06/20UNEXPECTED_KERNEL_MODE_TRAP_M Bug 检查 的值为 0x1000007F。 这表示 Intel CPU生成了陷阱，内核无法捕获此陷阱。0x1000007F:UNEXPECTED_KERNEL_MODE_TRAP_M\n\n问题原因：\n\n第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常\n\n", "0x1000008E": "BUG代码 0x1000008E：KERNEL_MODE_EXCEPTION_NOT_HANDLED_M\n项目 • 2023/06/20KERNEL_MODE_EXCEPTION_NOT_HANDLED_M Bug 检查 的值为 0x1000008E。 这表示内核模式程序生成了错误处理程序未捕获的异常。", "0x100000EA": "BUG代码 0x100000EA与", "0x4000008A": "BUG代码 0x4000008A：THREAD_TERMINATE_HELD_MUTEX\n项目 • 2023/06/20THREAD_TERMINATE_HELD_MUTEX Bug 检查 的值为 0x4000008A。 这表示驱动程序在释放互斥之前在退出的线程上获取了互斥体。 原因可能是驱动程序在不释放互斥体的情况下返回到用户模式，或者驱动程序获取互斥体，然后导致异常导致运行它的线程被终止。参数 描述1 拥有 KMUTEX 的 KTHREAD 的地址。2 拥有的 KMUTEX 的地址。3 保留4 保留若要进行调查，请查看调用堆栈。 如果堆栈上有直接后跟系统异常处理例程和线程终止例程的驱动程序，则此驱动程序有故障，需要修复，以便在持有内核互斥体时不会导致未经处理的异常。 如果堆栈仅显示正常的线程终止代码且未涉及任何驱动程序，请运行 ！pool 或使用 ln (list Nearest Symbols) 在互斥 (参数 2) 的地址上，并查看是否可以发现谁拥有它。 此 Bug 几乎肯定会出现在该互斥体所有者的代码中。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。THREAD_TERMINATE_HELD_MUTEX参数原因", "0xC0000218": "BUG代码 0xC0000218：STATUS_CANNOT_LOAD_REGISTRY_FILE\n项目 • 2023/06/20STATUS_CANNOT_LOAD_REGISTRY_FILE Bug 检查 的值为 0xC0000218。 这表示无法加载注册表文件。参数 描述1 无法加载的注册表配置单元名称的地址。2 零 (保留)3 零 (保留)4 零 (保留)此 Bug 检查显示描述性文本消息。 损坏的文件的名称显示为消息的一部分。如果无法加载必要的注册表配置单元文件，则会发生此错误。 通常，这意味着文件已损坏或缺失。在极少数情况下，此错误可能是由于驱动程序损坏了内存中的注册表映像，或者此区域中的内存错误。请尝试使用启动恢复机制 (例如操作系统提供的启动修复、恢复控制台或紧急恢复磁盘)。 如果问题是注册表文件缺失或损坏，则通常可修复此问题。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。STATUS_CANNOT_LOAD_REGISTRY_FILE参数原因解决方法", "0xC000021A": "BUG代码 0xC000021A：WINLOGON_FATAL_ERROR\n项目 • 2023/06/15WINLOGON_FATAL_ERROR Bug 检查 的值为 0xC000021A。 这意味着 Winlogon 进程意外终止。参数 说明1 标识问题的字符串2 错误代码3 保留4 预留当用户模式子系统（如 WinLogon 或客户端服务器Run-Time子系统 (CSRSS) ）受到严重威胁且无法再保证安全性时，会发生此错误。 作为响应，操作系统将切换到内核模式。在没有 WinLogon 或 CSRSS 的情况下，Microsoft Windows 无法运行。 因此，这是少数用户模式服务发生故障可能会关闭系统的情况之一。不匹配的系统文件也可能导致此错误。 如果已从备份还原硬盘，则可能会出现此不匹配情况。 某些备份程序可能会跳过还原确定正在使用的系统文件。在这种情况下，运行内核调试器可能没有用，因为实际错误发生在用户模式进程中。） 重要本主题面向程序员。 如果您是在使用计算机时收到蓝屏错误代码的客户，请参阅蓝屏错误疑难解答 。WINLOGON_FATAL_ERROR参数原因解决方法解决用户模式设备驱动程序、系统服务或第三方应用程序中的错误由于", "0xC0000221": "BUG代码 0xC0000221：STATUS_IMAGE_CHECKSUM_MISMATCH\n项目 • 2023/06/15STATUS_IMAGE_CHECKSUM_MISMATCH Bug 检查 的值为 0xC0000221。 Bug 检查指示驱动程序或系统 DLL 已损坏。） 重要本文面向程序员。 如果你是 Microsoft 客户，并且计算机显示蓝屏错误代码，请参阅 蓝屏错误疑难解答 。STATUS_IMAGE_CHECKSUM_MISMATCH参数无。原因此 Bug 检查驱动程序或其他系统文件中的严重错误导致。 文件头校验和与预期的校验和不匹配。此 Bug 检查也可能是由文件 I/O 路径中的硬件故障引起的，例如磁盘错误、RAM 故障或页面文件损坏。解决方法若要解决此 Bug 检查，请尝试以下选项：如果可以登录到系统，检查系统登录事件查看器以获取更多错误消息，这些错误消息可能有助于识别导致错误的设备或驱动程序。使用系统文件检查器工具修复丢失或损坏的系统文件。 系统文件检查器 (SFC.exe)是一种 Windows 实用工具，可用于扫描和还原损坏的 Windows 系统文件。使用以下命令运行系统文件检查器：控制台SFC /scannow有关详细信息，请参阅 使用系统文件检查器工具修复丢失或损坏的系统文件 。使用 Windows 磁盘扫描实用工具检查文件系统错误。 在“文件资源管理器”中，选择并按住或右键单击要扫描的驱动器，然后选择“属性”。 选择“ 工具 ”选项卡。在“错误检查”下，选择“ 检查”。检查硬盘上是否有足够的可用空间。 操作系统和某些应用程序需要足够的可用空间来创建交换文件和完成其他功能。 确切的要求因系统配置而异，但通常最好有 10%到 15% 的可用空间。磁盘错误可能会导致文件损坏。 运行 Chkdsk /f /r 以检测并解决文件系统中的任何结构损坏。 在系统分区上开始磁盘扫描之前，必须重启系统。请与制造商联系，了解是否有更新的系统 BIOS 或固件可用。 禁用 BIOS 或其他固件设置的内存缓存也可能解决此错误。可以通过现有 Windows 副本运行就地安装或恢复。 就地安装或恢复会保留所有注册表设置和配置信息，但会替换所有系统文件。运行病毒检测程序。 病毒可感染针对 Windows 格式化的所有类型的硬盘。 由此产生的磁盘损坏可能会生成系统 Bug 检查代码。 确保病毒检测程序检查主启动记录是否存在感染。如果这些方法失败，请重新安装 Windows，然后从备份还原系统。另请参阅Bug 检查代码参考", "0xDEADDEAD": "BUG代码 0xDEADDEAD：MANUALLY_INITIATED_CRASH1\n项目 • 2023/06/20MANUALLY_INITIATED_CRASH1 Bug 检查 的值为 0xDEADDEAD。 这表示发生了手动启动的崩溃。参数 描述1 保留2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。MANUALLY_INITIATED_CRASH1参数内核实时转储代码引用\n项目 • 2023/03/08本部分包含可能会出现的常见内核实时转储代码的说明。 实时转储会不重置 OS，但允许在操作系统可继续的异常情况下捕获内存信息。７ 备注本主题面向程序员。 如果你是一个客户，你的系统显示了带有 Bug 检查代码的蓝屏，请参阅蓝屏错误疑难解答 。内核实时转储与 Bug 检查的比较使用传统 Bug 检查时，PC 将重置，并且用户的工作将中断。 内核实时转储的目标是收集数据以对异常情况进行故障排除，但允许 OS 继续操作。 与“非致命”但影响严重的失败和挂起的 Bug 检查相比，这可以减少停机时间。 如果可以将 OS 恢复到已知的良好状态，则使用内核实时转储。 例如，子系统的硬件重置（如视频/显示、USB3 或 Wi-Fi）可以允许这些系统恢复到已知的良好状态，同时对用户的影响降到最低。内核实时转储创建内核内存的一致性快照，并将其保存到转储文件以供将来分析。 为了最大限度地减少对性能的影响，使用内存复制技术在短时间内创建转储文件。 此外，还会限制实时转储的收集，从而最大程度地减少对用户的影响。内核实时转储适用于一类问题，即需要花费很长时间，但并未出现任何技术故障的问题。启动操作时，可以初始化监视器计时器。 如果监视器在预期时间内在操作完成之前过期，则可以执行系统的实时转储。 然后，可以通过遍历该操作的调用堆栈和相关等待链来分析转储，以调查它未在预期的时间范围内完成的原因。当某些操作失败，代码所有者记录失败的原因并能确定原因时，系统日志很有用。 使用监视器计时器的实时转储尝试捕获预期和记录外的故障路径。 但与每个故障一样，系统日志可能会标识其他问题，这些原因可能提供有关失败的特定根本原因的线索。内核实时转储文件内容与常规转储文件类似，实时转储文件可能包含（具有次要数据）的小型转储以及完整的内核转储，后者中也可能包含与活动转储类似的用户模式内存。 有关转储文件内容的常规信息，请参阅多种内核模式转储文件。 某些实时转储只会尝试捕获小型转储，因为它们旨在捕获特定的硬件相关数据，而另一些则可能尝试捕获更大的内核实时转储。为了性能、文件大小以及转储捕获的可靠性，某些信息不包括在内，例如来自备用列表和文件缓存的页面。实时转储文件通常包含内存页面，例如：KdDeBuggerBlock加载的模块列表对于每个处理器，内核转储中会捕获以下信息：KiProcessorBlockPRCBs当前堆栈当前页面目录表KI_USER_SHARED_DATANTOS 内核映像HAL 映像内核转储中的其他信息可能包括：线程/内存状态内存中日志记录某些实时转储可能包含用户模式进程页面。某些实时转储可能包含其他特定于域的数据，例如 USB 故障种特定于 USB 的数据。部分内核实时转储文件当实时转储无法可靠地捕获所有预期的内存页面时，可能会生成部分内核实时转储文件。将通过捕获包含在其他页面之前生成有效转储所需的重要数据的页面，筛选在部分转储中捕获的信息并确定其优先级。 例如，当实时转储包括用户页面时，内核页面优先于用户页面。 在某些情况下，没有足够的资源可用于捕获所有预期的可选内存页面，因此转储文件中可能缺少内存。 WinDbg 调试器仍应识别转储文件，但在尝试转储内存时可能会显示错误。 如果调试器在尝试转储位于某个地址的内存时显示错误，则可以使用 !pte 扩展来检查地址的 PTE 是否有效。 这可以帮助确定是内存地址确实无效，还是页面有效只是在转储文件中不可用。分析实时转储文件发生实时转储时，可以使用用于其他内存转储文件的技术来分析转储文件。 若要了解故障期间的内存内容，需要了解处理器内存寄存器和程序集编程。有关详细信息，请参阅：使用 WinDbg 分析内核模式转储文件!analyze处理器体系结构如果此主题中没有某个实时转储代码的说明信息，请在 Windows 调试程序 (WinDbg) 中使用以下语法（内核模式）和 !analyze 扩展，并将 <code> 替换为某个 Bug 检查代码：!analyze -show <code>输入此命令会使 WinDbg 显示指定的实时转储代码的相关信息。 如果默认数字基数不是16，则为 <code> 添加前缀 0x。向 !analyze 命令提供实时转储代码参数，以显示任何可用的参数信息。 例如，若要显示有关参数 1 值为 0x3003 的", "0x161": "BUG代码 0x161：LIVE_SYSTEM_DUMP\n项目 • 2023/03/08LIVE_SYSTEM_DUMP实时转储的值为 0x00000161。 这表示系统管理员已请求收集实时系统内存转储。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)参数 说明1 0x005461736b6d6772，它是文本字符串“Taskmgr”的十六进制编码。2 预留3 保留4 预留从 Windows 22H2 版本 25276 开始，可以使用任务管理器创建实时系统内存转储。 有关详细信息，请参阅 任务管理器实时内存转储。任务管理器实时内存转储内核实时转储代码引用LIVE_SYSTEM_DUMP参数注解另请参阅", "0xAB": "BUG代码 0xAB：SESSION_HAS_VALID_POOL_ON_EXIT\n项目 • 2023/06/22SESSION_HAS_VALID_POOL_ON_EXIT实时转储的值为 0x000000AB。 此 Bug 检查指示会话驱动程序仍保留内存时发生了会话卸载。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)参数 说明1 会话 ID。2 正在泄漏的分页池字节数。3 正在泄漏的非分页池字节数。4 正在泄漏的分页和非分页分配的总数。 (非分页分配数在此单词的上半部分，分页分配位于此单词的下半部分。)发生SESSION_HAS_VALID_POOL_ON_EXIT Bug 检查是因为会话驱动程序在会话卸载之前未释放其池分配。 此 Bug 检查可以指示Win32k.sys、Atmfd.dll、Rdpdd.dll、视频或其他驱动程序中的 Bug。！analyze 调试扩展检查显示有关 Bug 的信息，在确定根本原因方面非常有用。Bug 检查代码参考SESSION_HAS_VALID_POOL_ON_EXIT参数原因备注另请参阅", "0x141": "BUG代码 0x141：VIDEO_ENGINE_TIMEOUT_DETECTED\n项目 • 2023/06/20VIDEO_ENGINE_TIMEOUT_DETECTED实时转储的值为 0x00000141。 这表示其中一个显示引擎未能及时响应。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 描述1 指向内部 TDR 恢复上下文 (TDR_RECOVERY_CONTEXT) 的可选指针。2 指向负责任设备驱动程序模块的指针 (例如所有者标记) 。3 辅助驱动程序特定的存储桶密钥。4 可选的内部上下文相关数据。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。标记 {270A33FD-3DA6-460D-BA89-3C1BAE21E39B} 的辅助数据包含其他 TDR 相关数据。 使用 .enumtag 查看数据。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_ENGINE_TIMEOUT_DETECTED参数备注", "0x142": "BUG代码 0x142：VIDEO_TDR_APPLICATION_BLOCKED\n项目 • 2023/06/20VIDEO_TDR_APPLICATION_BLOCKED实时转储的值为 0x00000142。 这表示已阻止应用程序访问图形硬件。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 描述1 指向内部 TDR 恢复上下文 (TDR_RECOVERY_CONTEXT) 的可选指针。2 指向负责任设备驱动程序模块的指针 (例如所有者标记) 。3 辅助驱动程序特定的存储桶密钥。4 阻止访问 GPU 的进程 ID。！analyze 调试扩展检查显示有关 Bug 的信息，在确定根本原因方面非常有用。标记 {270A33FD-3DA6-460D-BA89-3C1BAE21E39B} 的辅助数据包含其他 TDR 相关数据。 使用 .enumtag (枚举辅助回调数据) 来查看数据。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_TDR_APPLICATION_BLOCKED参数备注", "0x156": "BUG代码 0x156：WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP\n项目 • 2023/06/15WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP实时转储的值为 0x00000156。 这表示Winsock 检测到挂起的传输终结点关闭请求。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 AFD 终结点指针 (！afdkd.endp <ptr>) ！afdkd 调试器扩展仅适用于硬件开发合作伙伴。2 传输终结点类型0x1：UDP 数据报0x2：RAW 数据报0x3：TCP 侦听器0x4 ：TCP 终结点3 数据报终结点的缓冲发送字节数4 渔农 处！NETIO_SUPER_TRIAGE_BLOCK处理 closesocket 请求时，Winsock 检测到挂起的传输终结点关闭请求。 系统生成了用于分析的实时转储，然后关闭请求完成，而无需等待挂起的传输终结点关闭请求的完成。WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP参数原因", "0x15C": "BUG代码 0x15C：PDC_WATCHDOG_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15PDC_WATCHDOG_TIMEOUT_LIVEDUMP实时转储的值为 0x0000015C。 这表示系统组件在分配的时间段内无法响应，从而阻止系统进入或退出连接待机。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 挂起组件的客户端 ID。2 挂起组件的客户端类型。0x1：通知客户端无法响应。3 - 指向通知客户端的指针 (pdc！_PDC_NOTIFICATION_CLIENT) 。4 - 指向 pdc！ 的指针PDC_14F_TRIAGE结构。0x2：复原客户端无法响应。3 - 指向复原客户端 (pdc！_PDC_RESILIENCY_CLIENT) 的指针。4 - 指向 pdc！ 的指针PDC_14F_TRIAGE结构。0x3：激活器客户端的引用保留时间过长3 - 指向激活客户端的指针 (pdc！_PDC_ACTIVATOR_CLIENT) 。4 - 指向 pdc！ 的指针PDC_14F_TRIAGE结构。3 请参阅参数 24 请参阅参数 2内核实时转储代码引用Bug 检查代码参考PDC_WATCHDOG_TIMEOUT_LIVEDUMP参数另请参阅", "0x15D": "BUG代码 0x15D：SOC_SUBSYSTEM_FAILURE_LIVEDUMP\n项目 • 2023/06/15SOC_SUBSYSTEM_FAILURE_LIVEDUMP实时转储的值为 0x0000015D。 这表示芯片上的系统 (SoC) 子系统遇到严重故障，并捕获了实时内核转储。 在这种情况下，SoC 子系统不会生成 Bug 检查。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 SOC_SUBSYSTEM_FAILURE_DETAILS结构的地址。2 保留。3 保留。4 可选。 供应商提供的数据块的地址。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。使用提供的 nt！SOC_SUBSYSTEM_FAILURE_DETAILS结构，使用 dt 命令和 Arg1 提供的地址转储故障数据。dbgcmd与 SoC 供应商合作以进一步分析数据，包括可选供应商提供的常规用途数据块。0x14B SOC_SUBSYSTEM_FAILURE参数进行 Bug检查解决方法2: kd> dt nt!SOC_SUBSYSTEM_FAILURE_DETAILS 9aa8d630 +0x000 SubsysType : 1 ( SOC_SUBSYS_AUDIO_DSP ) +0x008 FirmwareVersion : 0 +0x010 HardwareVersion : 0 +0x018 UnifiedFailureRegionSize : 0x24 +0x01c UnifiedFailureRegion : [1] \"F\"可能需要使用 k、kb、kc、kd、kp、kP、kv (Display Stack Backtrace) 命令来检查堆栈跟踪。 可以指定处理器编号来检查所有处理器上的堆栈。还可以在导致此停止代码的代码中设置断点，并尝试单步执行错误代码。有关详细信息，请参阅以下主题：使用 Windows 调试器 (WinDbg) 进行故障转储分析如果你没有能力使用 Windows 调试器来解决此问题，则可以使用一些基本的故障排除技术。在系统登录事件查看器中查看其他错误消息，这些错误消息可能有助于识别导致此Bug 的设备或驱动程序检查。如果驱动程序标识在错误检查消息中，禁用该驱动程序或咨询驱动程序更新的制造商。你可尝试运行系统制造商提供的硬件诊断。有关其他常规故障排除信息，请参阅 蓝屏数据。最低受支持的客户端 Windows 8最低受支持的服务器 Windows Server 2012内核实时转储代码引用Bug 检查代码参考要求另请参阅", "0x15E": "BUG代码 0x15E：BugCODE_NDIS_DRIVER_LIVE_DUMP\n项目 • 2023/06/15BugCODE_NDIS_DRIVER_LIVE_DUMP实时转储的值为 0x0000015E。 此 Bug 代码指示 NDIS 已捕获实时内核转储。 在这种情况下，NDIS 不会生成 Bug 检查。参数 1 指示冲突的类型。 其他参数的含义取决于参数 1 的值。 如果参数的值为“0”，则表示不使用它。参数1参数 1 值和错误原因 参数 2 参数 30x01 NDIS_BugCHECK_MINIPORT_FATAL_ERROR微型端口驱动程序遇到严重错误并请求重新枚举。微型端口块的地址。 使用此地址运行 ！ndiskd.minidriver 以获取详细信息。微型端口的物理设备对象的地址(PDO)BugCODE_NDIS_DRIVER参数参数1参数 1 值和错误原因 参数 2 参数 30x25 NDIS_BugCHECK_WATCHDOG尝试管理网络堆栈花费的时间太长。 当NDIS 调用其他驱动程序时，NDIS 会启动一个监视器计时器，以确保调用立即完成。如果调用时间过长，NDIS 会注入 Bug 检查。这可以由简单的死锁引起。 使用“！stacks 2ndis”或类似值查看，以查看是否有任何线程看起来可疑。 请特别注意NDIS_WATCHDOG_TRIAGE_BLOCK中的PrimaryThread。这可能是由丢失的 NBL 引起的，在这种情况下 ！ndiskd.pendingnbls 可能会有所帮助。 检查使用 ！ndiskd.oid 卡住的 OID。耗时过长的操作。 可能的值：0x01 ： NDIS_BugCHECK_WATCHDOG_PROTOCOL_PAUSE暂停协议驱动程序时超时。0x02 ：NDIS_BugCHECK_WATCHDOG_PROTOCOL_NETPNPEVENT向协议驱动程序传送NET_PNP_EVENT_NOTIFICATION时超时。0x03 ：NDIS_BugCHECK_WATCHDOG_PROTOCOL_STATUS_INDICATION向协议驱动程序提供状态指示时出现超时。0x04 ： NDIS_BugCHECK_WATCHDOG_PROTOCOL_UNBIND解除协议驱动程序绑定时出现超时。0x11 ： NDIS_BugCHECK_WATCHDOG_FILTER_PAUSE暂停筛选器驱动程序时超时。0x12 ： NDIS_BugCHECK_WATCHDOG_FILTER_NETPNPEVENT向筛选器驱动程序传送NET_PNP_EVENT_NOTIFICATION时超时。0x13 ：NDIS_BugCHECK_WATCHDOG_FILTER_STATUS_INDICATION向筛选器驱动程序提供状态指示时超时。0x14 ： NDIS_BugCHECK_WATCHDOG_FILTER_DETACH分离筛选器驱动程序时超时。0x21 ： NDIS_BugCHECK_WATCHDOG_MINIPORT_PAUSE暂停微型端口适配器时超时。0x22 ： NDIS_BugCHECK_WATCHDOG_MINIPORT_HALT在停止微型端口适配器时超时。0x23 ： NDIS_BugCHECK_WATCHDOG_MINIPORT_OID将 OID 请求传送到微型端口适配器时超时。0x24 ： NDIS_BugCHECK_WATCHDOG_FILTER_OID向筛选器驱动程序传递 OID 请求时超时。0x25 ： NDIS_BugCHECK_WATCHDOG_MINIPORT_IDLE闲接微型端口适配器时超时。0x26 ： NDIS_BugCHECK_WATCHDOG_CANCEL_IDLE取消微型端口适配器上的空闲请求时出现超时。投向 ndis！NDIS_WATCHDOG_TRIAGE_BLOCK。有用字段：StartTime 显示操作开始的时间（以 100ns 为单位），由KeQueryInterruptTime 返回。TimeoutMilliseconds 显示NDIS 在触发此 Bug 检查之前至少等待了多长时间。TargetObject 是 NDIS 正在等待的协议、筛选器模块或微型端口适配器的句柄。 使用此句柄运行 ！ndiskd.protocol、！ndiskd.filter 或 ！ndiskd.netadapter 以获取详细信息。PrimaryThread 是 NDIS 启动操作的线程。 通常，这是第一个查找位置，但如果异步处理操作，线程可能已移动到其他位置。0x30 NDIS_BugCHECK_STUCK_NBL微型端口驱动程序有一段时间没有将 NBL返回到堆栈。微型端口块的地址。 使用此地址运行 ！ndiskd.minidriver 以获取详细信息。0!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。 参数 1 指示BugCODE_NDIS_DRIVER_LIVE_DUMP Bug 检查的具体原因。NDIS 已检测到另一个网络驱动程序中的严重问题并已从中恢复。 尽管系统未停止，但此问题以后可能会导致连接问题或致命的 Bug 检查。此 Bug 代码仅在 Windows 8.1 及更高版本的 Windows 中出现。原因注解", "0x15F": "BUG代码 0x15F：CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP实时转储的值为 0x0000015F。 这表示已发生连接待机监视器超时。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP参数参数 说明1 CS 监视器子代码0x1：DRIPS 监视器超时。 系统一直处于连接待机的复原阶段，没有激活器处于活动状态，也没有设备约束不满足太长时间，没有进入 DRIPS (最深的运行时空闲平台状态) 。2 - 指向其他信息的指针 (nt！POP_DRIPS_WATCHDOG_METRICS)3 - 非 DRIPS 持续时间（以毫秒为单位）4 - 保留0x2：DRIPS 监视器设备约束超时。 由于设备约束不满意，没有激活器处于活动状态，系统长时间没有进入DRIPS (最深的运行时空闲平台状态) 处于连接待机的复原阶段。2 - nt！TRIAGE_POP_FX_DEVICE 设备3 - 组件索引4 - 保留0x3：DRIPS 监视器预报超时。 由于活动的 PEP 预否决且没有激活器，系统已长时间处于连接待机的复原阶段，没有进入 DRIPS (最深的运行时空闲平台状态) 。2 - 否决代码3 - 指向 PWSTR) (否决名称字符串的指针4 - 指向 PEP PPM 回调的指针0x4：深度睡眠监视器2 - 指标3 -NonDeepSleepDurationMs4 - 保留0x5：深度睡眠电源设置监视器2 - 指标3 -NonDeepSleepDurationMs4 - 保留2 请参阅参数 13 请参阅参数 14 请参阅参数 1此计算机表现出了缩短屏幕关闭电池使用时间的行为。 通常，这是由 CPU 活动、设备活动或处于不足空闲状态的设备引起的。原因另请参阅内核实时转储代码引用Bug 检查代码参考", "0x165": "BUG代码 0x165：CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP\n项目 • 2023/06/20CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP实时转储的值为 0x00000165。 这表明非协调节点上的 SMB 客户端抱怨协调节点上的 IO 耗时过长，导致所有 IO 都失败，STATUS_IO_TIMEOUT。参数 描述1 可选的群集服务 PID。2 观察到STATUS_IO_TIMEOUT的节点的群集节点 ID。3 保留。4 保留。非协调节点上的 SMB 客户端会抱怨协调节点上的 IO 耗时过长，导致所有 IO 失败，STATUS_IO_TIMEOUT。转储的辅助数据流中提供了其他信息。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储，包括群集共享卷 telemetry.)） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP参数原因解决方法另请参阅使用实时转储排查挂起 (博客)内核实时转储代码引用Bug 检查代码参考", "0x166": "BUG代码 0x166：CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP实时转储的值为 0x00000166。 这表示群集资源调用花费的时间超过配置的超时时间。参数说明1 资源主机监视器 PID。2 处理资源调用的线程的 TID。3 资源调用类型 - 下面列出。4 子代码。 当参数 3 等于 8 时，此参数包含群集资源控制代码。 当参数 3 等于 9 时，此参数包含群集资源类型控制代码。资源调用类型1 打开2 关闭3 联机4 脱机5 TERMINATE6 ARBITRATE7 发布8 资源控制9 资源类型控制CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP参数10 看起来还活着11 为活动状态12 失败通知13 关闭过程14 取消原因群集资源调用花费的时间比配置的超时时间长。 系统生成了实时转储，用于分析延迟。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)解决方法另请参阅使用实时转储 (排查挂起问题博客)内核实时转储代码引用Bug 检查代码参考", "0x167": "BUG代码 0x167：CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP实时转储的值为 0x00000167。 这表示群集服务调用 volsnap 来查询快照信息花费的时间过长。参数 说明1 群集服务 PID。2 处理 volsnap 查询的线程的 TID。3 如果 CSV 卷处于活动状态时超时，则此参数的值为 1;如果即使在降低 CSV 卷后超时，则此参数的值为 2。4 保留。群集服务调用 volsnap 来查询快照信息花费的时间太长。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)使用实时转储 (排查挂起问题博客)内核实时转储代码引用Bug 检查代码参考CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP参数原因解决方法另请参阅", "0x168": "BUG代码 0x168：CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15实时转储CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP值为 0x00000168。 这表示群集共享卷状态转换花费的时间太长。参数 说明1 群集服务 PID。2 CSV 目标状态 ID - 下面列出。3 保留4 预留CSV 目标状态 ID0 正在等待卷转换为 Init 状态。1 等待卷转换为“已暂停”状态。2 等待卷转换为“正在清空”状态。3 等待卷转换为“设置-下层”状态。4 等待卷转换为活动状态。群集共享卷状态转换花费的时间太长。 系统生成了实时转储，用于分析延迟。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)使用实时转储排查挂起 (博客)CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP参数原因解决方法另请参阅Bug 检查代码参考", "0x169": "BUG代码 0x169：CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP\n项目 • 2023/06/15CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP实时转储的值为 0x00000169。 这表示已要求群集共享卷管理器创建新的卷设备对象，但卷尚未及时到达。参数 说明1 群集服务 PID。2 保留。3 保留。4 保留。群集共享卷管理器被要求创建新的卷设备对象，但卷尚未及时到达。系统生成了实时转储，用于分析延迟。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)使用实时转储排查挂起 (博客)内核实时转储代码引用Bug 检查代码参考CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP参数原因解决方法另请参阅", "0x16A": "BUG代码 0x16A：CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP\n项目 • 2023/06/15CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP实时转储的值为 0x0000016A。 这表示群集共享卷管理器卷删除请求已超时。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 群集服务 PID2 保留。3 保留。4 保留。群集共享卷管理器卷删除请求已超时。系统生成了实时转储，用于分析延迟。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)使用实时转储 (排查挂起问题博客)内核实时转储代码引用CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP参数原因解决方法另请参阅Bug 检查代码参考", "0x16B": "BUG代码 0x16B：CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP\n项目 • 2023/03/08实时转储CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP值为 0x0000016B。 这表示群集服务用户模式监视器检测到线程长时间未向前推进。参数 说明1 群集服务 PID。2 卡住的线程的 ID。3 保留。4 保留。群集服务用户模式监视器检测到线程长时间未向前推进。系统生成了实时转储，用于分析延迟。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)使用实时转储排查挂起 (博客)内核实时转储代码引用Bug 检查代码参考CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP参数原因解决方法另请参阅", "0x16F": "BUG代码 0x16F：CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP实时转储的值为 0x0000016F。 这表示群集共享卷的下一个状态转换请求尚未到达。参数 说明1 群集服务 PID。2 CSV 目标状态 ID - 下面列出。3 保留4 预留CSV 目标状态 ID0 等待卷转换为 Init 状态。1 等待卷转换为“已暂停”状态。2 等待卷转换为“排出”状态。3 等待卷转换到“设置下级”状态。4 等待卷转换为活动状态。群集共享卷的下一个状态转换请求尚未到达。系统生成了实时转储，用于分析延迟。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)使用实时转储 (排查挂起问题博客)内核实时转储代码引用Bug 检查代码参考CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP参数原因解决方法另请参阅", "0x175": "BUG代码 0x175：PREVIOUS_FATAL_ABNORMAL_RESET_ERROR\n项目 • 2023/06/20PREVIOUS_FATAL_ABNORMAL_RESET_ERROR实时转储的值为 0x00000175。 这表示发生了不可恢复的系统错误，或者系统在 Windows Phone 设备上异常重置。 系统生成了实时转储来收集上一个错误中的设备故障数据。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 描述1 保留2 保留3 保留4 保留Windows Phone设备上的系统遇到意外错误并重启。 可能导致此错误的问题包括：应用程序中的硬件监视器计时器或辅助处理器指示系统挂起、用户启动的键序列因挂起等。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。PREVIOUS_FATAL_ABNORMAL_RESET_ERROR参数原因", "0x179": "BUG代码 0x179：CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP实时转储的值为 0x00000179。 这表示发起方节点上的 SMB 客户端抱怨到目标节点的 IO 耗时过长，导致所有 IO 失败，STATUS_IO_TIMEOUT。参数 说明1 遇到超时的 IRP。2 保留。3 保留。4 保留。发起方节点上的 SMB 客户端会抱怨目标节点上的 IO 耗时过长，导致所有 IO 失败，STATUS_IO_TIMEOUT。为此，群集发起程序在发起程序节点上捕获实时转储，以便我们可以分析 IO 花费的时间。转储的辅助数据流中提供了其他信息。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)使用实时转储排查挂起 (博客)内核实时转储代码引用CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP参数原因解决方法另请参阅Bug 检查代码参考Bug 检查 17C：PDC_LOCK_WATCHDOG_LIVEDUMP\n项目 • 2023/06/15PDC_LOCK_WATCHDOG_LIVEDUMP实时转储的值为 0x0000017C。 这表示线程持有 PDC锁的时间过长。参数 说明1 持有 PDC 锁的线程。2 锁定监视器超时（以毫秒为单位）。3 保留。4 保留。线程持有 PDC 锁的时间太长。 创建一个 livedump 来提供调查信息。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)使用调试器 ！thread 命令显示包含参数 1 中提供的锁的线程。 分析该代码以确定其锁定时间超过超时期限的原因。！线程内核实时转储代码引用Bug 检查代码参考PDC_LOCK_WATCHDOG_LIVEDUMP参数原因解决方法另请参阅Bug 检查0x17D：PDC_UNEXPECTED_REVOCATION_LIVEDUMP\n项目 • 2023/06/15实时转储PDC_UNEXPECTED_REVOCATION_LIVEDUMP值为 0x0000017D。 它指示激活器已意外吊销。参数 说明1 吊销的激活器的客户端 ID。2 吊销的激活器客户端。3 吊销的激活实例。4 pdc！_PDC_CLIENT_PROCESS_INFO激活器意外吊销。创建一个 livedump 来提供信息进行调查。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)内核实时转储代码引用Bug 检查代码参考PDC_UNEXPECTED_REVOCATION_LIVEDUMP参数原因另请参阅", "0x187": "BUG代码 0x187：VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD\n项目 • 2023/06/20VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD实时转储的值为 0x00000187。 这表示视频回退到 BDD，而不是使用 IHV 驱动程序。 这始终会生成实时转储。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 描述1 原因代码。0x1：DWM 在重试、停止显示适配器并回退到BDD 后无法初始化2 保留3 保留4 保留） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD参数", "0x188": "BUG代码 0x188：CLUSTER_CSVFS_LIVEDUMP\n项目 • 2023/06/15实时转储CLUSTER_CSVFS_LIVEDUMP值为 0x00000188。 这表示 CSVFS 启动了此livedump 以帮助调试不一致的状态。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明1 原因代码0x1：oplock 降级为 none 时缓存清除失败2- CSVFS 的地址！_SCB0x2：从无进行 oplock 升级时缓存清除失败2- CSVFS 的地址！_SCB0x3：在设置清除失败模式时清除缓存2- CSVFS 的地址！_SCB0x4：oplock 降级为 none 时缓存刷新失败2- CSVFS 的地址！_SCB2 请参阅参数 13 保留4 预留第一个参数包含原因代码 当 CSVFS 检测到当前状态可能导致数据损坏或其他类型的不一致时，它将生成具有此状态代码的实时转储。 Parameter1 的代码指向创建此实时转储的场景。 应在原因代码的上下文中解释其他参数。内核实时转储代码引用CLUSTER_CSVFS_LIVEDUMP参数原因另请参阅Bug 检查代码参考", "0x190": "BUG代码 0x190：WIN32K_CRITICAL_FAILURE_LIVEDUMP\n项目 • 2023/06/15WIN32K_CRITICAL_FAILURE_LIVEDUMP实时转储的值为 0x00000190。 这表示 Win32k 遇到严重故障。 捕获实时转储以收集调试信息。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 失败的类型0x1：REGION_VALIDATION_FAILURE - 区域超出表面边界。2- 指向 DC 的指针 3 - 指向 SURFACE 的指针 4 -指向 REGION 的指针0x2：OPERATOR_NEW_USED - 运算符“new”用于分配内存。2 - 保留 3 - 保留 4 - 保留2 请参阅参数 13 请参阅参数 14 请参阅参数 1内核实时转储代码引用Bug 检查代码参考WIN32K_CRITICAL_FAILURE_LIVEDUMP参数另请参阅", "0x193": "BUG代码 0x193：VIDEO_DXGKRNL_LIVEDUMP\n项目 • 2023/06/15VIDEO_DXGKRNL_LIVEDUMP实时转储的值为 0x00000193。 这表示发生了由 dxgkrnl 触发的实时转储。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明1 原因代码0x100 内部2 预留3 保留4 预留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。内核实时转储代码引用Bug 检查代码参考VIDEO_DXGKRNL_LIVEDUMP参数解决方法另请参阅", "0x195": "BUG代码 0x195：SMB_SERVER_LIVEDUMP\n项目 • 2023/06/15实时转储SMB_SERVER_LIVEDUMP值为 0x00000195。 这表示 SMB 服务器检测到问题，并捕获了内核转储以收集调试信息。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明1 0x1：I/O 未能在合理的时间内完成。2 - 指向 I/O SRV2_WORK_ITEM的指针2 请参阅参数 13 保留4 预留内核实时转储代码引用Bug 检查代码参考SMB_SERVER_LIVEDUMP参数另请参阅", "0x198": "BUG代码 0x198：UFX_LIVEDUMP\n项目 • 2023/06/15UFX_LIVEDUMP实时转储的值为 0x00000198。 这表示发生了 UFX 实时转储。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 失败类型0x1：类驱动程序无法激活总线。2 - 枚举子 PDO 的掩码 3 - 已激活子 PDO 4 的掩码 - 保留2 请参阅参数 13 请参阅参数 14 请参阅参数 1内核实时转储代码引用Bug 检查代码参考UFX_LIVEDUMP参数另请参阅", "0x19D": "BUG代码 0x19D：CLUSTER_SVHDX_LIVEDUMP\n项目 • 2023/03/08CLUSTER_SVHDX_LIVEDUMP实时转储的值为 0x0000019D。 这表示 SVHDX 已启动此实时转储，以帮助调试不一致状态。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)参数 说明1 原因代码0x1：装载共享虚拟磁盘失败2 - Svhdxflt！_SVHDX_VIRTUALDISK_CONTEXT3 - 地址 nt！_FILE_OBJECT 4 - NTSTATUS2 请参阅参数 13 请参阅参数 14 请参阅参数 1当 SVHDX 检测到当前状态可能导致某种不一致时，它将使用此状态代码生成实时转储。Parameter1 的代码指向创建此实时转储的场景。 应在原因代码的上下文中解释其他参数。内核实时转储代码引用Bug 检查代码参考CLUSTER_SVHDX_LIVEDUMP参数原因另请参阅", "0x1A0": "BUG代码 0x1A0：TTM_WATCHDOG_TIMEOUT\n项目 • 2023/06/20TTM_WATCHDOG_TIMEOUT Bug 检查 的值为 0x000001A0。 它指示终端拓扑管理器检测到，对于配置的超时，某些特定于设备的操作未完成。参数 描述1 失败类型 - 下面列出的值。2 指向设备的指针。3 指向工作线程的指针。4 指向标注例程的指针。失败类型0x1：设备分配到终端未取得进展。0x2：设备的关闭回调未取得进展。0x3：设备的 set-input-mode 回调未取得进展。0x4：设备的 set-display-state 回调未取得进展。0x5：设置设备的内置面板状态未取得进展。0x6：更新设备的主要显示可见状态未取得进展。终端拓扑管理器检测到，对于配置的超时，某些特定于设备的操作未完成。） 重要本文面向程序员。 如果你是使用计算机时收到蓝屏错误代码的客户，请参阅 蓝屏错误疑难解答 。TTM_WATCHDOG_TIMEOUT参数原因另请参阅Bug 检查代码参考", "0x1A1": "BUG代码 0x1A1：WIN32K_CALLOUT_WATCHDOG_LIVEDUMP\n项目 • 2023/06/15WIN32K_CALLOUT_WATCHDOG_LIVEDUMP实时转储的值为 0x000001A1。 对 Win32k 的标注未立即返回。以下参数显示在蓝屏上。参数 说明1 线程阻塞提示从 Win32k 标注返回。2 保留。3 保留。4 保留。对 Win32k 的标注未立即返回。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)有关使用线程的一般信息，请参阅：控制进程和线程Windows 内核模式进程和线程管理器WIN32K_CALLOUT_WATCHDOG_LIVEDUMP参数原因注解另请参阅内核实时转储代码引用Bug 检查代码参考", "0x1A3": "BUG代码 0x1A3：CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP\n项目 • 2023/03/08在超时期限内未返回调用。CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP实时转储的值为 0x000001A3。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)以下参数显示在蓝屏上。参数 说明1 其调用未立即返回的线程的进程。2 其调用未立即返回的线程。3 超时（以毫秒为单位）。4 dt nt！_PO_CALL_HAS_NOT_RETURNED_WATCHDOG内核实时转储代码引用Bug 检查代码参考CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP参数另请参阅", "0x1A4": "BUG代码 0x1A4：DRIPS_SW_HW_DIVERGENCE_LIVEDUMP\n项目 • 2023/03/08实时转储DRIPS_SW_HW_DIVERGENCE_LIVEDUMP值为 0x000001A4。软件和硬件 DRIPS 差异超过默认/编程的阈值时间。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)以下参数显示在蓝屏上。参数 说明1 软件 DRIPS 花费的时间（以微秒为单位）。2 硬件 DRIPS 花费的时间（以微秒为单位）。3 保留。4 保留。内核实时转储代码引用Bug 检查代码参考DRIPS_SW_HW_DIVERGENCE_LIVEDUMP参数另请参阅", "0x1A5": "BUG代码 0x1A5：USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP\n项目 • 2023/06/15USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP实时转储的值为 0x000001A5。 它表示USB 设备会意外删除，因为它正在阻止 DRIPS。参数 说明1 阻止设备的 PDO。2 保留。3 保留。4 保留。USB 设备阻止顶级控制器在新式待机期间关闭电源，因此会意外移除。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)内核实时转储代码引用Bug 检查代码参考USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP参数原因另请参阅", "0x1A6": "BUG代码 0x1A6：BLUETOOTH_ERROR_RECOVERY_LIVEDUMP\n项目 • 2023/06/15BLUETOOTH_ERROR_RECOVERY_LIVEDUMP实时转储的值为 0x000001A6。 它表示蓝牙无线电驱动程序 (bthport.sys) 已启动错误恢复，以尝试从无法修复的内部状况恢复和重置无线电。参数 说明1 蓝牙无线电 (设备) 的 PDO。2 保留。3 保留。4 保留。蓝牙无线电驱动程序 (bthport.sys) 已启动错误恢复，以尝试从无法修复的内部状况恢复和重置无线电。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)内核实时转储代码引用Bug 检查代码参考BLUETOOTH_ERROR_RECOVERY_LIVEDUMP参数原因另请参阅", "0x1A7": "BUG代码 0x1A7：SMB_REDIRECTOR_LIVEDUMP\n项目 • 2023/06/15实时转储SMB_REDIRECTOR_LIVEDUMP值为 0x000001A7。 它表示 SMB 重定向程序检测到问题，并捕获了内核转储以收集调试信息。参数 说明1 原因代码 - 请参阅下面的值。2 请参阅下面的值。3 保留。4 保留。SMB 重定向程序检测到问题，并捕获了内核转储以收集调试信息。原因代码textSMB 重定向程序检测到问题，并捕获了内核转储以收集调试信息。仅当设置了以下注册表值时，才会生成包含此 Bug 检查代码的实时转储。registry设置此注册表项并且 RDR 在 IO 上超时时，将发生 livedump。SMB_REDIRECTOR_LIVEDUMP参数0x1 : An I/O failed to complete in a reasonable amount of time. 2 - Pointer to the connection object. 3 - Reserved. 4 - Reserved.原因HKLM\\System\\CurrentControlSet\\Services\\Lanmanworkstation\\Parameters [DWORD]LiveDumpFilter = 1(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)另请参阅内核实时转储代码引用Bug 检查代码参考", "0x1A8": "BUG代码 0x1A8：VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP\n项目 • 2023/06/15VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP实时转储的值为 0x000001A8。 它表示发生了用户针对黑屏场景发起的 DXGKRNL 实时转储。参数 说明1 触发 DXGKRNL 黑屏实时转储的源 - 下面列出。2 保留。3 保留。4 保留。源值0x1：黑屏热键生成 DXGKRNL 黑屏实时转储0x2：卷组合键生成的 DXGKRNL 黑屏实时转储0x4：内部生成的 DXGKRNL 黑屏实时转储0x8：长电源按钮保持 (LPBH) 生成的 DXGKRNL 黑屏实时转储针对黑屏方案，用户发起的 DXGKRNL 实时转储。 有关触发的实时转储的源，请参阅参数 1 的值。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP参数原因另请参阅内核实时转储代码引用Bug 检查代码参考", "0x1A9": "BUG代码 0x1A9：DIRECTED_FX_TRANSITION_LIVEDUMP\n项目 • 2023/03/08DIRECTED_FX_TRANSITION_LIVEDUMP实时转储的值为 0x000001A9。 它表示设备已失败其定向 Fx 转换调用。 有关定向 Fx 的详细信息，请参阅 定向电源管理框架简介。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)参数 说明1 指向 POP_FX_DEVICE 对象实例的指针。2 如果此转换是电源关闭，则为 1;如果此转换为电源，则为 0。3 保留。4 保留。设备已失败其定向 Fx 转换调用。内核实时转储代码引用Bug 检查代码参考DIRECTED_FX_TRANSITION_LIVEDUMP参数原因另请参阅", "0x1B0": "BUG代码 0x1B0：VIDEO_MINIPORT_FAILED_LIVEDUMP\n项目 • 2023/03/08VIDEO_MINIPORT_FAILED_LIVEDUMP实时转储的值为 0x000001B0。参数 说明1 原因代码。 值：0x1： 添加设备失败。 0x2： 启动设备失败。2 NTSTATUS3 保留。4 保留。DXGKRNL 检测到问题并捕获了实时转储以收集调试信息。 视频微型端口驱动程序发生故障时，dxgkrnl 会触发这些 lifeumps。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)内核实时转储代码引用Bug 检查代码参考VIDEO_MINIPORT_FAILED_LIVEDUMP参数原因另请参阅", "0x1B8": "BUG代码 0x1B8：VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP\n项目 • 2023/06/15VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP实时转储的值为 0x000001B8。 它表示用户针对黑屏方案启动了 MINIPORT 实时转储。参数 说明1 触发 MINIPORT 黑屏实时转储的源 - 下面列出。2 保留。3 保留。4 保留。源值0x1：黑屏热键生成的 MINIPORT 黑屏实时转储0x2：音量组合键生成的 MINIPORT 黑屏实时转储0x4：内部生成的 MINIPORT 黑屏实时转储0x8：长电源按钮保持 (LPBH) 生成的 MINIPORT 黑屏实时转储用户为黑屏方案启动的 MINIPORT 实时转储。 有关触发的实时转储的源，请参阅参数 1的值。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP参数原因另请参阅内核实时转储代码引用Bug 检查代码参考", "0x1C4": "BUG代码 0x1C4：DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP\n项目 • 2023/06/15DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP实时转储的值为 0x000001C4。 这表示已检测到尝试损坏系统的设备驱动程序。 这是因为驱动程序在注册表中被指定为管理员)怀疑 (，并且内核启用了对此驱动程序的大量检查。 有关详细信息，请参阅驱动程序验证程序。参数 说明1 驱动程序冲突的子类。 请参阅下面的值。2 请参阅下面的值。3 请参阅下面的值。4 请参阅下面的值。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)值valuesDRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP参数0x00081001: ID of the 'KsDeviceMutex' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00081002: ID of the 'KsStreamPointerClone' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00081003: ID of the 'KsStreamPointerLock' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00081004: ID of the 'KsStreamPointerUnlock' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00081005: ID of the 'KsCallbackReturn' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00081006: ID of the 'KsIrqlDeviceCallbacks' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00081007: ID of the 'KsIrqlFilterCallbacks' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00081008: ID of the 'KsIrqlPinCallbacks' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00081009: ID of the 'KsIrqlDDIs' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0008100A: ID of the 'KsFilterMutex' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0008100B: ID of the 'KsProcessingMutex' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00082001: ID of the 'KsTimedPinSetDeviceState' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00082002: ID of the 'KsTimedDeviceCallbacks' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00082003: ID of the 'KsTimedFilterCallbacks' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00082004: ID of the 'KsTimedPinCallbacks' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00082005: ID of the 'KsTimedProcessingMutex' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00071001: ID of the 'PcIrqlDDIs' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00071003: ID of the 'PcIrqlIport' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00071004: ID of the 'PcUnmapAllocatedPages' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00071005: ID of the 'PcAllocatedPages' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00071006: ID of the 'PcRegisterAdapterPower' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00071007: ID of the 'PcAddAdapterDevice' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00071008: ID of the 'PcPropertyRequest' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00071009: ID of the 'PcAllocateAndMapPages' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0007100A: ID of the 'PcPoRequestPowerIrp' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00072001: ID of the 'PcTimedWaveRtStreamSetState' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00020002: ID of the 'IrqlApcLte' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020003: ID of the 'IrqlDispatch' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020004: ID of the 'IrqlExAllocatePool' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020005: ID of the 'IrqlExApcLte1' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020006: ID of the 'IrqlExApcLte2' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020007: ID of the 'IrqlExApcLte3' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020008: ID of the 'IrqlExPassive' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020009: ID of the 'IrqlIoApcLte' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002000A: ID of the 'IrqlIoPassive1' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002000B: ID of the 'IrqlIoPassive2' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002000C: ID of the 'IrqlIoPassive3' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002000D: ID of the 'IrqlIoPassive4' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002000E: ID of the 'IrqlIoPassive5' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002000F: ID of the 'IrqlKeApcLte1' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020010: ID of the 'IrqlKeApcLte2' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020011: ID of the 'IrqlKeDispatchLte' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020015: ID of the 'IrqlKeReleaseSpinLock' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020016: ID of the 'IrqlKeSetEvent' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020019: ID of the 'IrqlMmApcLte' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002001A: ID of the 'IrqlMmDispatch' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002001B: ID of the 'IrqlObPassive' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002001C: ID of the 'IrqlPsPassive' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002001D: ID of the 'IrqlReturn' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0002001E: ID of the 'IrqlRtlPassive' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0002001F: ID of the 'IrqlZwPassive' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00020022: ID of the 'IrqlIoDispatch' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00040003: ID of the 'CriticalRegions' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00040006: ID of the 'QueuedSpinLock' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00040007: ID of the 'QueuedSpinLockRelease' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00040009: ID of the 'SpinLock' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0004000A: ID of the 'SpinlockRelease' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0004000E: ID of the 'GuardedRegions' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0004100B: ID of the 'RequestedPowerIrp' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x0004100F: ID of the 'IoSetCompletionExCompleteIrp' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00043006: ID of the 'PnpRemove' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00091001: ID of the 'NdisOidComplete' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00091002: ID of the 'NdisOidDoubleComplete' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0009100E: ID of the 'NdisOidDoubleRequest' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00092003: ID of the 'NdisTimedOidComplete' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0009200D: ID of the 'NdisTimedDataSend' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0009200F: ID of the 'NdisTimedDataHang' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00092010: ID of the 'NdisFilterTimedPauseComplete' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00092011: ID of the 'NdisFilterTimedDataSend' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00092012: ID of the 'NdisFilterTimedDataReceive' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00093004: ID of the 'WlanAssociation' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00093005: ID of the 'WlanConnectionRoaming' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00093006: ID of the 'WlanDisassociation' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00093101: ID of the 'WlanAssert' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Reserved  Parameter 4 - Reserved 0x00094007: ID of the 'WlanTimedAssociation' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00094008: ID of the 'WlanTimedConnectionRoaming' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x00094009: ID of the 'WlanTimedConnectRequest' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0009400B: ID of the 'WlanTimedLinkQuality' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo). 0x0009400C: ID of the 'WlanTimedScan' rule that was violated. Parameter 2 - A pointer to the string describing the violated rulecondition. Parameter 3 - Address of internal rule state (second argument to!ruleinfo). Parameter 4 - Address of supplemental states (third argument to!ruleinfo).另请参阅内核实时转储代码引用Bug 检查代码参考", "0x1C5": "BUG代码 0x1C5：IO_THREADPOOL_DEADLOCK_LIVEDUMP\n项目 • 2023/06/15IO_THREADPOOL_DEADLOCK_LIVEDUMP实时转储的值为 0x000001C5。 这表示内核模式线程池遇到死锁情况。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 池编号。0x0 ：ExPoolUntrusted2 指向PEX_WORK_QUEUE的指针3 保留4 预留内核实时转储代码引用Bug 检查代码参考IO_THREADPOOL_DEADLOCK_LIVEDUMP参数另请参阅", "0x1C9": "BUG代码 0x1C9：USER_MODE_HEALTH_MONITOR_LIVEDUMP\n项目 • 2023/06/15实时转储USER_MODE_HEALTH_MONITOR_LIVEDUMP值为 0x000001C9。 它表示一个或多个关键用户模式组件无法满足运行状况检查。参数说明1 在配置的超时时间内无法满足运行状况检查的进程。2 运行状况监视超时 (秒) 。3 监视器源。 结合进程地址，这有助于识别源。 请参见下面可能的值。 这些值与USER_MODE_HEALTH_MONITOR 共享。4 保留。监视器源值0 : WatchdogSourceDefault Source was not specified1 : WatchdogSourceRhsCleanup Monitors that RHS process goes away when terminating on graceful exit2 : WatchdogSourceRhsResourceDeadlockBugcheckNow RHS was asked to immediately Bugcheck machine on resource deadlock3 : WatchdogSourceRhsExceptionFromResource Resource has leaked unhandled exception from an entry point, RHS is terminating and this watchdog monitors that process will go away4 : WatchdogSourceRhsUnhandledException Unhandled exception in RHS. RHS is terminating and this watchdog monitors that process will go away5 : WatchdogSourceRhsResourceDeadlock Monitors that RHS process goes away when terminating on resource deadlockUSER_MODE_HEALTH_MONITOR_LIVEDUMP参数6 : WatchdogSourceRhsResourceTypeDeadlock Monitors that RHS process goes away when terminating on resource type deadlock7 : WatchdogSourceClussvcUnhandledException Unhandled exception in clussvc. clussvc is terminating and this watchdog monitors that process will go away8 : WatchdogSourceClussvcBugcheckMessageRecieved Another cluster node has sent message asking to Bugcheck this node.9 : WatchdogSourceClussvcWatchdogBugcheck User mode watchdog has expired and created netft watchdog to Bugchecked the node. 0xA : WatchdogSourceClussvcIsAlive Cluster service sends heartbeat to netft every 500 millseconds. By default, netft expects at least 1 heartbeat per second. If this watchdog was triggered that means clussvc is not getting CPU to send heartbeats. 0x65 : WatchdogSourceRhsResourceDeadlockPhysicalDisk A subclass of WatchdogSourceRhsResourceDeadlock. 0x66 : WatchdogSourceRhsResourceDeadlockStoragePool A subclass of WatchdogSourceRhsResourceDeadlock. 0x67 : WatchdogSourceRhsResourceDeadlockFileServer A subclass of WatchdogSourceRhsResourceDeadlock. 0x68 : WatchdogSourceRhsResourceDeadlockSODAFileServer A subclass of WatchdogSourceRhsResourceDeadlock. 0x69 : WatchdogSourceRhsResourceDeadlockStorageReplica A subclass of WatchdogSourceRhsResourceDeadlock. 0x6A : WatchdogSourceRhsResourceDeadlockStorageQOS A subclass of WatchdogSourceRhsResourceDeadlock. 0x6B : WatchdogSourceRhsResourceDeadlockStorageNFSV2 A subclass of WatchdogSourceRhsResourceDeadlock. 0xC9 : WatchdogSourceRhsResourceTypeDeadlockPhysicalDisk A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCA : WatchdogSourceRhsResourceTypeDeadlockStoragePool A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCB : WatchdogSourceRhsResourceTypeDeadlockFileServer A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCC : WatchdogSourceRhsResourceTypeDeadlockSODAFileServer A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCD : WatchdogSourceRhsResourceTypeDeadlockStorageReplica A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCE : WatchdogSourceRhsResourceTypeDeadlockStorageQOS A subclass of WatchdogSourceRhsResourceTypeDeadlock. 0xCF : WatchdogSourceRhsResourceTypeDeadlockStorageNFSV2 A subclass of WatchdogSourceRhsResourceTypeDeadlock.原因一个或多个关键用户模式组件无法满足运行状况检查。硬件机制（如监视器计时器）可以检测基本内核服务未执行。 但是，资源不足问题（包括内存泄漏、锁争用和计划优先级配置错误）可能会阻止关键用户模式组件，而不会阻止DPC 或清空非分页池。内核组件可以通过定期监视关键应用程序，将监视器计时器功能扩展到用户模式。 此livedump 表示用户模式运行状况检查失败，因此我们将尝试终止此应用程序，并在终止及时完成时继续监视。 如果终止未及时完成，则计算机将被 Bug 检查它通过重新启动和/或允许应用程序故障转移到其他服务器来还原关键服务。(此代码永远不能用于真正的 Bug 检查;它用于标识实时 dumps.)另请参阅使用 Windows 错误报告排查故障转移群集问题故障转移群集系统日志事件Bug 检查0x1C9 USER_MODE_HEALTH_MONITOR内核实时转储代码引用Bug 检查代码参考", "0x1CC": "BUG代码 0x1CC：EXRESOURCE_TIMEOUT_LIVEDUMP\n项目 • 2023/06/15EXRESOURCE_TIMEOUT_LIVEDUMP实时转储的值为 0x000001CC。内核 ERESOURCE 已超时。这可能指示死锁条件或大量争用，这可能会导致性能问题。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)蓝屏上会显示以下参数。参数 说明1 已超时的 ERESOURCE。2 检测到超时的线程3 ERESOURCE 争用计数4 配置的超时（以秒为单位）内核实时转储代码引用Bug 检查代码参考EXRESOURCE_TIMEOUT_LIVEDUMP参数另请参阅", "0x1D1": "BUG代码 0x1D1：TELEMETRY_ASSERTS_LIVEDUMP\n项目 • 2023/06/15TELEMETRY_ASSERTS_LIVEDUMP实时转储的值为 0x000001D1。遥测断言验证失败。此代码永远不会用于真正的 Bug 检查;它用于识别实时转储，包括设备遥测。若要排查此问题，请检查调用堆栈，了解MICROSOFT_TELEMETRY_ASSERT (表达式) 中的表达式无效的原因。参数 说明1 Rva2 ModuleName3 时间戳4 SizeOfImage内核实时转储代码引用Bug 检查代码参考TELEMETRY_ASSERTS_LIVEDUMP参数另请参阅", "0x1D4": "BUG代码 0x1D4：UCMUCSI_LIVEDUMP\n项目 • 2023/06/15实时转储UCMUCSI_LIVEDUMP值为 0x000001D4。 这表示 UcmUcsi 类扩展遇到错误。例如，原因可能是 UCSI 命令已超时，或者由于客户端驱动程序返回失败而导致 UCSI 命令执行失败。UcmUcsiCx.sys是包含的 UCSI 类扩展。 有关详细信息，请参阅 USB Type-C 连接器系统软件接口 (UCSI) 驱动程序。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明1 故障类型 - 请参阅下面的值2 UCSI 命令值。3 如果为非零，则为指向其他信息的指针。 使用 dt UcmUcsiCx!UCMUCSICX_TRIAGE 显示。4 保留。故障类型0x0：UCSI 命令已超时，因为固件未及时响应该命令。0x1：由于客户端驱动程序返回失败或固件返回错误代码，UCSI 命令执行失败。USB 团队博客 - 调试 UCSI 固件故障通用串行总线 (USB)内核实时转储代码引用UCMUCSI_LIVEDUMP参数另请参阅Bug 检查0x1E1：DEVICE_DIAGNOSTIC_LOG_LIVEDUMP\n项目 • 2023/06/15DEVICE_DIAGNOSTIC_LOG_LIVEDUMP的值为 0x000001E1。 这表示设备遇到错误并生成了诊断数据。(此代码永远不会用于实际 Bug 检查;它用于标识实时转储。)参数 说明1 设备类。0x1：存储设备。2 - 存储问题类型。0x1：设备崩溃。3 - IEEE 组织 ID。4 - 保留2 请参阅上面的说明。3 请参阅上面的说明。4 请参阅上面的说明。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。内核实时转储代码引用Bug 检查代码参考解决方法另请参阅Bug 检查0x1F5：APPLICATION_HANG_KERNEL_LIVEDUMP\n项目 • 2023/06/15APPLICATION_HANG_KERNEL_LIVEDUMP的值为 0x000001F5。 这表示应用程序在尝试终止时挂起。(此代码永远不会用于真正的 Bug 检查;它用于标识实时 dumps.)参数 说明1 保留2 预留3 保留4 预留应用程序挂起报告 (（例如，可以使用 WerReportHang 函数创建）) 完成后，调用了TerminateProcess，但目标进程无法终止，这可能是因为线程在内核模式下挂起。此实时内核会审转储可能包含挂起进程的内核线程状态。 内核转储仅包含 WER 无法终止的进程线程，并且仅包含内核，而不包含用户内存。!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。内核实时转储代码引用Bug 检查代码参考APPLICATION_HANG_KERNEL_LIVEDUMP参数原因解决方法另请参阅Bug 检查0x21C8：MANUALLY_INITIATED_BLACKSCREEN_HOTKEY_LIVE_DUMP\n项目 • 2023/06/15实时转储MANUALLY_INITIATED_BLACKSCREEN_HOTKEY_LIVE_DUMP值为 0x000021C8。 这表明系统配置为捕获实时转储，并且用户已按下黑屏热键 (CTRL + SHIFT + WIN + B) 。 实时转储可能有助于确定用户观察到的黑屏的根本原因。(此代码永远不能用于真正的 Bug 检查;它用于标识实时转储。)参数 说明1 保留2 预留3 保留4 预留!analyze 调试扩展显示有关 Bug 检查的信息，并有助于确定根本原因 。内核实时转储代码引用MANUALLY_INITIATED_BLACKSCREEN_HOTKEY_LIVE_DUMP参数解决方法另请参阅", "0x7F": "BUG代码 0x7F:UNEXPECTED_KERNEL_MODE_TRAP\n\n问题原因：\n\nWinodws系统故障或第三方软件故障\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x101": "BUG代码 0x101:CLOCK_WATCHDOG_TIMEOUT\n\n问题原因：\n\n硬件故障（通常是CPU）\n\n解决方案：\n\n请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x133": "BUG代码 0x133:DPC_WATCHDOG_VIOLATION\n\n问题原因：\n\n第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\nDPC_WATCHDOG_VIOLATION Bug 检查 的值为 0x00000133。 此 Bug 检查指示执行 DPC 监视器，可能\n\n是因为它检测到一个长时间运行的延迟过程调用 (DPC) ，或者因为系统长时间在中断请求级别花费了\n\n(IRQL) DISPATCH_LEVEL 或更高版本。\n\n参数 1 的值指示单个 DPC 是否超过超时，或者系统是否累积花费了在 IRQL DISPATCH_LEVEL 或更高版\n\n本的时间。 DPC 的运行时间不应超过 100 微秒，ISR 的运行时间不应超过 25 微秒，但系统上的实际超\n\n时值设置要高得多。\n\n有关 DPC 的详细信息，请参阅由 Pavel Yosifovich、Mark E. Russinovich、David A. Solomon 和 Alex\n\nIonescu 撰写的 DPC 对象 和 Windows 内部 7th 版简介第 1 部分 。\n\n参数 1 指示冲突的类型。 其他参数的含义取决于 参数 1 的值。", "0x13A": "BUG代码 0x13A:KERNEL_MODE_HEAP_CORRUPTION\n\n问题原因：\n\n第三方软件冲突\n\n解决方案：\n\n卸载第三方杀毒软件和电脑管家软件，更新Windows补丁和驱动。\n\n若未恢复，请提前备份好数据，连接电源然后在开机时长按或点按F10，使用系统恢复出厂功能将计算机还原到出厂状态。\n\n如故障依旧，建议携机去联想售后服务中心检测硬件是否正常。\n\n", "0x17E": "BUG代码 0x17E:MICROCODE_REVISION_MISMATCH\n\n问题原因：\n\nBIOS固件版本故障\n\n解决方案：\n\n此蓝屏通常只会出现一次，后面不再出现。\n\n如故障频繁出现，建议携机去联想售后服务中心检测硬件是否正常\n\n", "0x7B": "BUG代码 0x7B:INACESSIBLE_BOOT_DEVICE\n错误分析：Windows在启动过程中无法访问系统分区或启动卷。 一般发生在更换主板后第一次启动时，主要是因为新主板和旧主板的IDE控制器使用了不同芯片组造成的。 有时也可能是病毒或硬盘损伤所引起的。\n解决方案：一般只要用安装光盘启动电脑， 然后执行修复安装即可解决问题。 对于病毒则可使用DOS版的杀毒软件进行查杀（主战有kv25DOS版下载）。 如果是硬盘本身存在问题， 请将其安装到其他电脑中，然后使用“chkdsk /r”来检查并修复磁盘错误。\n"}